# دو مرحله‌ای تایید (2PC) - از دیدگاه طراحی سیستم

## مقدمه

دو مرحله‌ای تایید (2PC) یک الگوریتم توزیع‌شده است که برای اطمینان از اتمی بودن در تراکنش‌های توزیع‌شده در چندین گره یا پایگاه داده استفاده می‌شود. این الگوریتم تضمین می‌کند که یا همه شرکت‌کنندگان در یک تراکنش توزیع‌شده تغییرات خود را تایید می‌کنند، یا همه آنها لغو می‌کنند، و ویژگی‌های ACID را در سیستم‌های توزیع‌شده حفظ می‌کند.

## بیان مسئله

در سیستم‌های توزیع‌شده، اغلب نیاز به انجام عملیاتی داریم که چندین پایگاه داده یا سرویس را شامل می‌شود. چالش این است:

- **اتمی بودن توزیع‌شده**: چگونه اطمینان حاصل کنیم که یک تراکنش یا با موفقیت در همه گره‌ها کامل می‌شود یا در همه آنها ناموفق است؟
- **شکست‌های جزئی**: اگر برخی گره‌ها موفق و برخی دیگر ناموفق شوند چه اتفاقی می‌افتد؟
- **سازگاری**: چگونه از سناریوهایی جلوگیری کنیم که نیمی از داده‌ها تایید شده و نیمی دیگر بازگشت داده شوند؟

بدون هماهنگی، ممکن است به وضعیت ناسازگاری برسید که:
- پول از یک حساب بانکی برداشت می‌شود اما هرگز به حساب دیگری واریز نمی‌شود
- یک سفارش ایجاد می‌شود اما موجودی کاهش نمی‌یابد
- داده‌های کاربر در یک سیستم به‌روزرسانی می‌شود اما در سیستم‌های مرتبط به‌روزرسانی نمی‌شود

## مرور راه‌حل

دو مرحله‌ای تایید این مسئله را با معرفی یک **هماهنگ‌کننده** که تراکنش را در چندین **شرکت‌کننده** (گره‌ها/پایگاه‌های داده) در دو مرحله متمایز هماهنگ می‌کند، حل می‌کند:

1. **مرحله آماده‌سازی** (مرحله رأی‌گیری): از همه شرکت‌کنندگان بپرسید که آیا می‌توانند تایید کنند
2. **مرحله تایید** (مرحله تصمیم‌گیری): بر اساس آرا به همه شرکت‌کنندگان بگویید که تایید کنند یا لغو کنند

نکته کلیدی: **هیچ شرکت‌کننده‌ای تایید نمی‌کند تا زمانی که همه شرکت‌کنندگان موافقت کنند که می‌توانند تایید کنند**.

## تجزیه دقیق مراحل

### مرحله ۱: آماده‌سازی (مرحله رأی‌گیری)

```
هماهنگ‌کننده                      شرکت‌کنندگان
    |                                     |
    |--- PREPARE (تراکنش) -------------->| گره ۱
    |                                     |
    |--- PREPARE (تراکنش) -------------->| گره ۲
    |                                     |
    |--- PREPARE (تراکنش) -------------->| گره ۳
    |                                     |
    |<-------- بله (آماده) --------------|
    |<-------- بله (آماده) --------------|
    |<-------- بله (آماده) --------------|
    |                                     |
```

**آنچه در این مرحله اتفاق می‌افتد:**

1. **هماهنگ‌کننده درخواست PREPARE را ارسال می‌کند** به همه شرکت‌کنندگان
   - شامل جزئیات تراکنش و عملیات‌های قابل انجام

2. **هر شرکت‌کننده:**
   - تلاش می‌کند تراکنش را به صورت محلی انجام دهد
   - تغییرات را در یک ناحیه موقت می‌نویسد (تایید نشده)
   - همه قفل‌های لازم را به دست می‌آورد
   - یک رکورد PREPARE را در Write-Ahead Log (WAL) خود می‌نویسد
   - با یکی از موارد زیر پاسخ می‌دهد:
     - **بله** - "اگر همه دیگران بتوانند، من می‌توانم تایید کنم"
     - **خیر** - "نمی‌توانم این تراکنش را تایید کنم"

3. **هماهنگ‌کننده همه آرا را جمع‌آوری می‌کند**
   - منتظر پاسخ از همه شرکت‌کنندگان می‌ماند
   - تصمیم را در WAL خود ثبت می‌کند

### مرحله ۲: تایید/لغو (مرحله تصمیم‌گیری)

**سناریو الف: همه شرکت‌کنندگان بله رأی دادند**

```
هماهنگ‌کننده                      شرکت‌کنندگان
    |                                     |
    |--- COMMIT ----------------------->| گره ۱
    |                                     |
    |--- COMMIT ----------------------->| گره ۲
    |                                     |
    |--- COMMIT ----------------------->| گره ۳
    |                                     |
    |<-------- ACK --------------------|
    |<-------- ACK --------------------|
    |<-------- ACK --------------------|
    |                                     |
```

**سناریو ب: هر شرکت‌کننده‌ای خیر رأی داد (یا زمان انقضا)**

```
هماهنگ‌کننده                      شرکت‌کنندگان
    |                                     |
    |--- ABORT ------------------------>| گره ۱
    |                                     |
    |--- ABORT ------------------------>| گره ۲
    |                                     |
    |--- ABORT ------------------------>| گره ۳
    |                                     |
    |<-------- ACK --------------------|
    |<-------- ACK --------------------|
    |<-------- ACK --------------------|
    |                                     |
```

**آنچه در این مرحله اتفاق می‌افتد:**

1. **هماهنگ‌کننده تصمیم می‌گیرد:**
   - اگر همه آرا بله هستند → COMMIT را به همه شرکت‌کنندگان ارسال کن
   - اگر هر رأی خیر یا زمان انقضا باشد → ABORT را به همه شرکت‌کنندگان ارسال کن
   - قبل از ارسال، تصمیم را در WAL می‌نویسد

2. **هر شرکت‌کننده:**
   - پیام COMMIT یا ABORT را دریافت می‌کند
   - دستور را اجرا می‌کند (تغییرات را دائمی می‌کند یا دور می‌اندازد)
   - همه قفل‌ها را آزاد می‌کند
   - رکورد COMMIT/ABORT را در WAL می‌نویسد
   - ACK را به هماهنگ‌کننده برمی‌گرداند

3. **هماهنگ‌کننده کامل می‌کند:**
   - منتظر همه ACK‌ها می‌ماند
   - رکورد تکمیل را در WAL می‌نویسد
   - تراکنش کامل است

## مثال عملی: انتقال بانکی

**سناریو:** انتقال ۱۰۰ دلار از حساب A (بانک DB 1) به حساب B (بانک DB 2)

### جریان گام به گام

```
۱. مشتری درخواست می‌کند: انتقال ۱۰۰ دلار از A به B

۲. مرحله ۱ - آماده‌سازی:

   هماهنگ‌کننده → DB1: "می‌توانی ۱۰۰ دلار از حساب A برداشت کنی؟"
   اقدامات DB1:
     - بررسی موجودی (A دارای ۵۰۰ دلار است) ✓
     - قفل حساب A
     - نوشتن "PREPARE: برداشت ۱۰۰ دلار از A" در WAL
     - کنار گذاشتن تغییر (هنوز تایید نکن)
   DB1 → هماهنگ‌کننده: "بله، آماده تایید"

   هماهنگ‌کننده → DB2: "می‌توانی ۱۰۰ دلار به حساب B واریز کنی؟"
   اقدامات DB2:
     - بررسی وجود حساب B ✓
     - قفل حساب B
     - نوشتن "PREPARE: واریز ۱۰۰ دلار به B" در WAL
     - کنار گذاشتن تغییر (هنوز تایید نکن)
   DB2 → هماهنگ‌کننده: "بله، آماده تایید"

۳. مرحله ۲ - تایید:

   تصمیم هماهنگ‌کننده: هر دو بله گفتند → تایید

   هماهنگ‌کننده می‌نویسد: "تصمیم: COMMIT" در WAL

   هماهنگ‌کننده → DB1: "تراکنش را تایید کن"
   اقدامات DB1:
     - برداشت را دائمی کن (A: ۵۰۰ دلار → ۴۰۰ دلار)
     - نوشتن "COMMIT" در WAL
     - آزادسازی قفل حساب A
   DB1 → هماهنگ‌کننده: "ACK"

   هماهنگ‌کننده → DB2: "تراکنش را تایید کن"
   اقدامات DB2:
     - واریز را دائمی کن (B: ۲۰۰ دلار → ۳۰۰ دلار)
     - نوشتن "COMMIT" در WAL
     - آزادسازی قفل حساب B
   DB2 → هماهنگ‌کننده: "ACK"

۴. تراکنش کامل! ۱۰۰ دلار با موفقیت منتقل شد.
```

## سناریوهای شکست و بازیابی

### سناریو ۱: شرکت‌کننده در مرحله آماده‌سازی شکست می‌خورد

```
هماهنگ‌کننده PREPARE را به همه شرکت‌کنندگان ارسال می‌کند
  → گره ۱: بله
  → گره ۲: [خراب شد - پاسخی وجود ندارد]
  → گره ۳: بله

اقدام هماهنگ‌کننده:
  - زمان انقضا در انتظار گره ۲
  - تصمیم: ABORT (همه شرکت‌کنندگان آماده نیستند)
  - ارسال ABORT به گره ۱ و گره ۳
  - گره ۲ هنگام بازیابی لغو خواهد کرد (PREPARE در لاگ وجود ندارد)
```

### سناریو ۲: شرکت‌کننده خیر رأی می‌دهد

```
هماهنگ‌کننده PREPARE را به همه شرکت‌کنندگان ارسال می‌کند
  → گره ۱: بله (دارای وجه)
  → گره ۲: خیر (وجه ناکافی)
  → گره ۳: بله

اقدام هماهنگ‌کننده:
  - رأی خیر دریافت شد
  - تصمیم: ABORT فوری
  - ارسال ABORT به همه شرکت‌کنندگان
  - همه شرکت‌کنندگان تغییرات را بازگشت می‌دهند
```

### سناریو ۳: هماهنگ‌کننده بعد از جمع‌آوری آرا خراب می‌شود

**قبل از نوشتن تصمیم در WAL:**
```
شرکت‌کنندگان در وضعیت "نامشخص" هستند (بله رأی دادند، منتظر تصمیم)

بازیابی:
  - هماهنگ‌کننده جدید انتخاب شده یا هماهنگ‌کننده اصلی بازیابی می‌شود
  - خواندن WAL → هیچ تصمیمی ثبت نشده
  - شرکت‌کنندگان هنوز رکوردهای PREPARE دارند
  - گزینه‌ها:
    الف) راه‌اندازی مجدد مرحله آماده‌سازی
    ب) لغو تراکنش (پیش‌فرض ایمن‌تر)
    ج) پرس و جو از شرکت‌کنندگان برای بازسازی وضعیت
```

**بعد از نوشتن تصمیم COMMIT در WAL:**
```
بازیابی:
  - هماهنگ‌کننده جدید WAL را می‌خواند → تصمیم COMMIT را می‌بیند
  - COMMIT را مجدداً به همه شرکت‌کنندگان ارسال می‌کند
  - شرکت‌کنندگانی که قبلاً تایید کرده‌اند: ایدم‌پوتنت (بی‌اثر)
  - شرکت‌کنندگانی که تایید نکرده‌اند: اکنون تایید می‌کنند
  - همه شرکت‌کنندگان در نهایت تایید می‌کنند
```

### سناریو ۴: پارتیشن شبکه

```
هماهنگ‌کننده COMMIT را به شرکت‌کنندگان ارسال می‌کند:
  → گره ۱: ACK دریافت شد
  → گره ۲: [پارتیشن شبکه - پیام از دست رفت]
  → گره ۳: ACK دریافت شد

اقدام هماهنگ‌کننده:
  - تلاش مجدد برای ارسال COMMIT به گره ۲
  - گره ۲ در نهایت دریافت و تایید می‌کند
  - اگر گره ۲ قبلاً تایید شده بود: عملیات ایدم‌پوتنت

مشکل: در حالی که پارتیشن شده، گره ۲ قفل‌ها را نگه می‌دارد!
  - مشکل مسدودسازی: تراکنش‌های دیگر در انتظار
  - می‌تواند منجر به زمان‌های انقضا و عملکرد ضعیف شود
```

## نقش Write-Ahead Log (WAL)

WAL برای دوام و بازیابی حیاتی است:

### آنچه ثبت می‌شود

```
WAL هماهنگ‌کننده:
  [T1] شروع تراکنش T1
  [T1] PREPARE ارسال شد به [گره۱، گره۲، گره۳]
  [T1] رأی-بله از گره۱
  [T1] رأی-بله از گره۲
  [T1] رأی-بله از گره۳
  [T1] تصمیم: COMMIT
  [T1] COMMIT ارسال شد به همه
  [T1] ACK از گره۱
  [T1] ACK از گره۲
  [T1] ACK از گره۳
  [T1] کامل

WAL شرکت‌کننده:
  [T1] PREPARE دریافت شد
  [T1] تغییرات محلی آماده (تصویر قبل ذخیره شد)
  [T1] رأی: بله ارسال شد
  [T1] COMMIT دریافت شد
  [T1] تغییرات اعمال شد
  [T1] ACK ارسال شد
```

### روش بازیابی

**بازیابی هماهنگ‌کننده:**
1. خواندن WAL برای یافتن تراکنش‌های در حال انجام
2. برای هر تراکنش:
   - اگر تصمیمی ثبت نشده → ABORT
   - اگر تصمیم COMMIT ثبت شده → ارسال مجدد COMMIT
   - اگر تصمیم ABORT ثبت شده → ارسال مجدد ABORT
   - اگر COMPLETE ثبت شده → کاری لازم نیست

**بازیابی شرکت‌کننده:**
1. خواندن WAL برای یافتن تراکنش‌های در حال انجام
2. برای هر تراکنش:
   - اگر فقط PREPARE ثبت شده → تماس با هماهنگ‌کننده برای تصمیم
   - اگر COMMIT ثبت شده → اطمینان از اعمال تغییرات
   - اگر ABORT ثبت شده → اطمینان از بازگشت تغییرات

## مصالحه‌های طراحی سیستم

### مزایا

**✓ تضمین سازگاری قوی**
- اطمینان از اتمی بودن همه یا هیچ در سیستم‌های توزیع‌شده
- به‌روزرسانی‌های جزئی ممکن نیست

**✓ درک ساده**
- پروتکل دو مرحله‌ای واضح
- استدلال درباره صحت آسان است

**✓ انطباق با ACID**
- حفظ تضمین‌های پایگاه داده سنتی در توزیع

**✓ اثبات شده و بالغ**
- حالت‌های شکست به خوبی درک شده
- ابزارها و پشتیبانی گسترده

### معایب

**✗ پروتکل مسدودکننده**
- شرکت‌کنندگان قفل‌ها را در طول هر دو مرحله نگه می‌دارند
- اگر هماهنگ‌کننده شکست بخورد، شرکت‌کنندگان در انتظار گیر می‌کنند
- **تأثیر عمده:** می‌تواند تراکنش‌های دیگر را برای مدت نامحدود مسدود کند

```
مثال:
  زمان ۰: تراکنش T1 حساب‌های A و B را قفل می‌کند
  زمان ۱: هماهنگ‌کننده قبل از ارسال COMMIT خراب می‌شود
  زمان ۲: تراکنش T2 می‌خواهد به حساب A دسترسی پیدا کند
  نتیجه: T2 مسدود است تا T1 حل شود (ممکن است دقیقه‌ها/ساعت‌ها)
```

**✗ نقطه واحد شکست**
- شکست هماهنگ‌کننده همه تراکنش‌ها را متوقف می‌کند
- نیاز به مکانیزم‌های failover هماهنگ‌کننده
- خود failover می‌تواند پیچیده باشد

**✗ سربار عملکرد**
- حداقل دو دور شبکه (آماده‌سازی + تایید)
- مسدودسازی همزمان در هر مرحله
- تأخیر = ۲ × (کندترین شرکت‌کننده) + تأخیرهای شبکه

```
مثال محاسبه تأخیر:
  مرحله آماده‌سازی: max(گره۱: ۵۰ms، گره۲: ۱۰۰ms، گره۳: ۷۵ms) = ۱۰۰ms
  مرحله تایید:  max(گره۱: ۵۰ms، گره۲: ۱۰۰ms، گره۳: ۷۵ms) = ۱۰۰ms
  کل حداقل: ۲۰۰ms به ازای هر تراکنش
```

**✗ محدودیت‌های مقیاس‌پذیری**
- شرکت‌کنندگان بیشتر = سربار هماهنگی بیشتر
- عملکرد با مقیاس توزیع‌شده کاهش می‌یابد
- برای سیستم‌های بسیار توزیع‌شده (بیش از ۱۰۰ گره) مناسب نیست

**✗ نگرانی‌های در دسترس بودن**
- در دسترس بودن را در [قضیه CAP](../fundamentals/cap-theorem.fa.md) نقض می‌کند
- سازگاری را به جای در دسترس بودن انتخاب می‌کند
- در طول پارتیشن‌های شبکه، سیستم ممکن است متوقف شود

**✗ پیچیدگی زمان انقضا**
- نیاز به تنظیم زمان‌های انقضای مناسب
- خیلی کوتاه: منفی‌های کاذب
- خیلی بلند: منابع برای مدت طولانی‌تر قفل شده
- هیچ مقدار زمان انقضای کاملی وجود ندارد

## کاربردهای دنیای واقعی

### جایی که 2PC استفاده می‌شود

**۱. پایگاه‌های داده توزیع‌شده سنتی**
- **MySQL Cluster (NDB)**: از 2PC برای تراکنش‌های بین shard استفاده می‌کند
- **PostgreSQL**: از 2PC از طریق `PREPARE TRANSACTION` پشتیبانی می‌کند
- **Oracle RAC**: هماهنگی تراکنش توزیع‌شده

**۲. باس‌های سرویس سازمانی (ESB)**
- **IBM WebSphere**: تراکنش‌های XA در صف‌های JMS
- **Oracle SOA Suite**: هماهنگی فراخوانی‌های سرویس

**۳. میکروسرویس‌ها (استفاده محدود)**
- وقتی سازگاری قوی کاملاً مورد نیاز است
- تراکنش‌های مالی (پرداخت‌ها، انتقال‌ها)
- سیستم‌های رزرو موجودی

**۴. API تراکنش جاوا (JTA)**
- برنامه‌های جاوا سازمانی با استفاده از پروتکل XA
- سرورهای برنامه که پایگاه داده + صف پیام را هماهنگ می‌کنند

### جایی که 2PC استفاده نمی‌شود

**۱. سیستم‌های مقیاس وب**
- **Google، Facebook، Amazon**: از سازگاری نهایی استفاده می‌کنند
- برای مقیاس عظیم خیلی کند و مسدودکننده
- BASE را به ACID ترجیح می‌دهند

**۲. میکروسرویس‌های مدرن**
- Netflix، Uber، Airbnb: به جای آن از [الگوی Saga](saga.fa.md) استفاده می‌کنند
- در دسترس بودن و تحمل پارتیشن را ترجیح می‌دهند
- سازگاری نهایی را می‌پذیرند

**۳. پایگاه‌های داده NoSQL**
- MongoDB، Cassandra، DynamoDB: پشتیبانی از 2PC ندارند
- برای در دسترس بودن و تحمل پارتیشن طراحی شده‌اند
- سازگاری را با مقیاس معامله می‌کنند

## الگوهای جایگزین

### ۱. سه مرحله‌ای تایید (3PC)

یک مرحله "پیش-تایید" برای کاهش مسدودسازی اضافه می‌کند:

```
مرحله ۱: CanCommit (مانند آماده‌سازی)
مرحله ۲: PreCommit (هماهنگ‌کننده تصمیم را اعلام می‌کند)
مرحله ۳: DoCommit (تایید واقعی)

مزیت: پنجره مسدودسازی را کاهش می‌دهد
معایب: پیچیده‌تر، هنوز با پارتیشن‌های شبکه مشکل دارد
```

### ۲. الگوی Saga

شکستن تراکنش به دنباله‌ای از تراکنش‌های محلی با اقدامات جبرانی:

```
انتقال ۱۰۰ دلار از A به B:

جریان رو به جلو:
  ۱. برداشت ۱۰۰ دلار از A (تراکنش محلی)
  ۲. واریز ۱۰۰ دلار به B (تراکنش محلی)

جریان جبرانی (اگر #۲ شکست بخورد):
  ۱. واریز ۱۰۰ دلار به A (جبران)

مزیت: بدون قفل‌های توزیع‌شده، در دسترس بودن بهتر
معایب: واقعاً ACID نیست، سازگاری نهایی
```

### ۳. Event Sourcing + CQRS

ذخیره رویدادها به جای وضعیت، بازسازی وضعیت از رویدادها:

```
رویدادها:
  - MoneyDebited(accountA, $100, txId)
  - MoneyCredited(accountB, $100, txId)

مزیت: ردیابی حسابرسی، مدل‌های سازگاری انعطاف‌پذیر
معایب: پیچیدگی، سازگاری نهایی
```

### ۴. رویکرد پایگاه داده واحد

اجتناب از توزیع به طور کلی:

```
به جای:
  - DB1: UserService
  - DB2: OrderService
  - نیاز به 2PC برای سفارشات کاربر

استفاده کنید:
  - یک پایگاه داده با چندین schema
  - تراکنش‌های ACID محلی

مزیت: ساده، سریع، سازگار
معایب: محدودیت‌های مقیاس‌پذیری، نقطه واحد شکست
```

## ملاحظات طراحی

### چه زمانی از 2PC استفاده کنیم

**✓ استفاده کنید وقتی:**
- سازگاری قوی کاملاً مورد نیاز است (تراکنش‌های مالی)
- تعداد شرکت‌کنندگان کم است (۲-۵ گره)
- نیازهای تأخیر آرام است (صدها میلی‌ثانیه قابل قبول)
- سیستم بسیار توزیع‌شده نیست
- شبکه قابل اعتماد و با تأخیر کم است
- در دسترس بودن می‌تواند برای سازگاری قربانی شود

**✗ اجتناب کنید وقتی:**
- ساخت سیستم‌های مقیاس وب (هزاران گره)
- توان عملیاتی بالا مورد نیاز است (هزاران TPS)
- تأخیر کم حیاتی است (زیر ۱۰۰ms)
- پارتیشن‌های شبکه رایج هستند
- در دسترس بودن بر سازگاری اولویت دارد
- شرکت‌کنندگان جغرافیایی توزیع شده‌اند

### ماتریس تصمیم

| نیازمندی | 2PC مناسب؟ | جایگزین |
|------------|---------------|-------------|
| دقت مالی | ✓ بله | هیچ - از 2PC استفاده کنید |
| لایک رسانه‌های اجتماعی | ✗ خیر | سازگاری نهایی |
| انتقال‌های بانکی | ✓ بله | 2PC یا Saga با اعتبارسنجی |
| سبد خرید | ✗ خیر | سازگاری نهایی |
| رزرو موجودی | ~ شاید | الگوی Saga ترجیح داده می‌شود |
| تکرار چند منطقه‌ای | ✗ خیر | تکرار ناهمزمان |
| میکروسرویس‌ها (۲-۳) | ~ شاید | Saga را در نظر بگیرید |
| میکروسرویس‌ها (۱۰+) | ✗ خیر | Saga یا Event Sourcing |

## پیامدهای طراحی سیستم مدرن

### رویکرد سنتی (2PC)

```
سرویس سفارش                سرویس موجودی
     |                               |
     |--- PREPARE: رزرو SKU123 ---->|
     |<-- بله -----------------------|
     |                               |
     |--- COMMIT: تایید سفارش ------->|
     |<-- ACK -----------------------|

زمان: ~۲۰۰-۵۰۰ms
قفل‌های نگهداری شده: ~۲۰۰-۵۰۰ms
در دسترس بودن: کاهش یافته در طول شکست هماهنگ‌کننده
```

### رویکرد مدرن (Saga/رویداد-محور)

```
سرویس سفارش              باس رویداد              سرویس موجودی
     |                            |                            |
     |-- رویداد OrderCreated ---->|                            |
     |                            |--- OrderCreated --------->|
     |                            |                            |
     |                            |<-- InventoryReserved ------|
     |<-- InventoryReserved ------|                            |

زمان: ~۵۰-۱۰۰ms (ناهمزمان)
قفل‌های نگهداری شده: حداقل (فقط محلی)
در دسترس بودن: بالا (سازگاری نهایی)
```

### خلاصه مصالحه‌های کلیدی

| جنبه | 2PC | Saga/رویداد-محور |
|--------|-----|-------------------|
| سازگاری | قوی (فوری) | نهایی |
| تأخیر | بالاتر (مسدودکننده) | پایین‌تر (ناهمزمان) |
| در دسترس بودن | پایین‌تر | بالاتر |
| پیچیدگی | پایین‌تر (پروتکل) | بالاتر (جبران) |
| مقیاس‌پذیری | محدود | بالا |
| اشکال‌زدایی | آسان‌تر | سخت‌تر |

## نکات کلیدی

1. **2PC اتمی بودن را تضمین می‌کند** در سیستم‌های توزیع‌شده اما به قیمت در دسترس بودن و عملکرد

2. **ماهیت مسدودکننده** بزرگترین محدودیت است - هماهنگ‌کنندگان شکست خورده شرکت‌کنندگان را برای مدت نامحدود قفل می‌کنند

3. **Write-Ahead Logs** برای دوام و بازیابی پس از شکست‌ها ضروری هستند

4. **مقیاس وب نیست** - سیستم‌های توزیع‌شده مدرن الگوهای سازگاری نهایی را ترجیح می‌دهند (Saga، Event Sourcing)

5. **هنوز ارزشمند** برای تراکنش‌های توزیع‌شده در مقیاس کوچک که سازگاری قوی غیرقابل مذاکره است (سیستم‌های مالی، تراکنش‌های کسب‌وکار حیاتی)

6. **پیامدهای [قضیه CAP](../fundamentals/cap-theorem.fa.md)** - 2PC CP را انتخاب می‌کند (سازگاری + تحمل پارتیشن) به قیمت در دسترس بودن

7. **با احتیاط استفاده کنید** - در نظر بگیرید که آیا واقعاً به تراکنش‌های توزیع‌شده نیاز دارید یا مشکل شما می‌تواند با:
   - یک پایگاه داده با طراحی schema مناسب
   - سازگاری نهایی با اقدامات جبرانی
   - عملیات ایدم‌پوتنت با منطق تلاش مجدد
   حل شود

8. **جایگزین‌های مدرن** (Saga، Event Sourcing، CQRS) سازگاری قوی را با در دسترس بودن و مقیاس‌پذیری بهتر معامله می‌کنند - اغلب یک معامله ارزشمند در سیستم‌های توزیع‌شده

---

**موضوعات مرتبط برای کاوش:**
- Paxos و Raft (الگوریتم‌های اجماع)
- [الگوی Saga](saga.fa.md) (جایگزین تراکنش توزیع‌شده)
- Event Sourcing و CQRS
- [قضیه CAP](../fundamentals/cap-theorem.fa.md)
- قفل‌های توزیع‌شده (Redlock، Zookeeper)
- پروتکل XA (استاندارد پیاده‌سازی 2PC)
