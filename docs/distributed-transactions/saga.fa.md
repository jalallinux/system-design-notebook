# الگوی Saga

## ۱. مقدمه

**الگوی Saga** یک الگوی طراحی برای مدیریت تراکنش‌های توزیع‌شده در سرویس‌های مختلف میکروسرویس است. در سیستم‌های توزیع‌شده مدرن که هر میکروسرویس پایگاه داده خود را دارد (الگوی پایگاه داده به ازای هر سرویس)، حفظ سازگاری داده‌ها در بین سرویس‌ها چالش‌برانگیز می‌شود. الگوی Saga این مشکل را با شکستن یک تراکنش توزیع‌شده به دنباله‌ای از تراکنش‌های محلی حل می‌کند، جایی که هر تراکنش داده‌ها را در یک سرویس واحد به‌روزرسانی کرده و یک رویداد یا پیام را برای راه‌اندازی مرحله بعدی تراکنش منتشر می‌کند.

برخلاف تراکنش‌های ACID سنتی که سازگاری فوری ارائه می‌دهند، Sagaها سازگاری نهایی (Eventual Consistency) را فراهم می‌کنند و به‌ویژه در معماری‌های میکروسرویس مفید هستند، جایی که سرویس‌ها نیاز دارند استقلال خود را حفظ کنند و در عین حال فرآیندهای کسب‌وکار پیچیده را هماهنگ کنند.

الگوی Saga به عنوان یک جایگزین عملی برای پروتکل‌های تراکنش توزیع‌شده مانند [Two-Phase Commit (2PC)](two-phase-commit.fa.md) عمل می‌کند، به‌ویژه در محیط‌هایی که:
- سرویس‌ها از انواع مختلف پایگاه داده استفاده می‌کنند (SQL و NoSQL)
- دسترس‌پذیری بالا مهم‌تر از سازگاری فوری است
- عملیات مسدودکننده غیرقابل قبول است
- سرویس‌ها نیاز دارند به‌صورت loosely coupled باقی بمانند

## ۲. بیان مسئله

در یک معماری میکروسرویس با الگوی پایگاه داده به ازای هر سرویس، هر سرویس مالک پایگاه داده خود است و هیچ سرویس دیگری نمی‌تواند مستقیماً به آن دسترسی داشته باشد. این طراحی استقلال عالی سرویس و اتصال سست فراهم می‌کند اما یک چالش بزرگ ایجاد می‌کند: **چگونه سازگاری داده‌ها را در چندین سرویس هنگام اجرای تراکنش‌های کسب‌وکار که چندین سرویس را در بر می‌گیرند حفظ کنیم؟**

تراکنش‌های ACID سنتی در مرزهای سرویس کار نمی‌کنند زیرا:
- هر سرویس پایگاه داده خود را دارد
- سرویس‌ها در فرآیندها یا ماشین‌های مختلف توزیع شده‌اند
- تراکنش‌های پایگاه داده محلی یک پایگاه داده واحد هستند

استفاده از پروتکل‌های تراکنش توزیع‌شده مانند Two-Phase Commit (2PC) مشکل‌ساز است زیرا:
- **ماهیت مسدودکننده**: 2PC یک پروتکل مسدودکننده است که سرویس‌ها در طول هماهنگی قفل نگه می‌دارند و دسترس‌پذیری را کاهش می‌دهد
- **اتصال محکم**: سرویس‌ها باید به‌طور همزمان در دسترس باشند تا تراکنش موفق شود
- **ناسازگاری با NoSQL**: بسیاری از پایگاه‌های داده مدرن NoSQL از 2PC پشتیبانی نمی‌کنند
- **کاهش دسترس‌پذیری**: اگر هر سرویسی از کار بیفتد، کل تراکنش شکست می‌خورد
- **سربار عملکرد**: پروتکل هماهنگی تأخیر قابل‌توجهی اضافه می‌کند

یک سیستم تجارت الکترونیک را در نظر بگیرید که ایجاد یک سفارش شامل:
1. تأیید حد اعتبار مشتری (سرویس مشتری)
2. شارژ روش پرداخت (سرویس پرداخت)
3. رزرو موجودی (سرویس موجودی)
4. زمان‌بندی تحویل (سرویس تحویل)

بدون الگویی مانند Saga، اطمینان از اینکه همه این مراحل یا همه موفق شوند یا همه شکست بخورند بسیار پیچیده می‌شود.

## ۳. مرور راه‌حل

الگوی Saga مشکل تراکنش توزیع‌شده را با شکستن تراکنش کلی به دنباله‌ای از تراکنش‌های محلی حل می‌کند. هر تراکنش محلی داده‌ها را در یک سرویس واحد به‌روزرسانی کرده و یک رویداد یا پیام را برای راه‌اندازی تراکنش محلی بعدی در saga منتشر می‌کند.

**ویژگی‌های کلیدی:**

1. **دنباله‌ای از تراکنش‌های محلی**: هر مرحله یک تراکنش ACID محلی در یک سرویس واحد است
2. **انتشار رویداد/پیام**: پس از هر تراکنش محلی، سرویس یک رویداد برای راه‌اندازی مرحله بعدی منتشر می‌کند
3. **تراکنش‌های جبرانی**: اگر یک مرحله شکست بخورد، saga تراکنش‌های جبرانی را برای لغو تغییرات ایجاد شده توسط تراکنش‌های قبلی اجرا می‌کند
4. **سازگاری نهایی**: saga سازگاری نهایی را در بین سرویس‌ها فراهم می‌کند نه سازگاری فوری

**دو رویکرد هماهنگی:**

الگوی Saga می‌تواند با استفاده از دو مکانیزم هماهنگی مختلف پیاده‌سازی شود:

1. **کوریوگرافی (Choreography)**: هر سرویس به رویدادها گوش می‌دهد و تصمیم می‌گیرد چه زمانی عمل کند (غیرمتمرکز)
2. **ارکستراسیون (Orchestration)**: یک هماهنگ‌کننده مرکزی به سرویس‌ها می‌گوید چه تراکنش‌های محلی را اجرا کنند (متمرکز)

هر دو رویکرد به هدف یکسانی دست می‌یابند اما با مصالحه‌های متفاوتی در پیچیدگی، اتصال و آزمایش.

## ۴. رویکردهای هماهنگی Saga

### Saga مبتنی بر کوریوگرافی

در کوریوگرافی، هیچ هماهنگ‌کننده مرکزی وجود ندارد. هر سرویس درگیر در saga به رویدادهای منتشر شده توسط سرویس‌های دیگر گوش می‌دهد و بر اساس آن رویدادها تصمیم می‌گیرد آیا اقدام کند یا نه.

**نحوه کار:**
1. سرویس A یک تراکنش محلی را تکمیل کرده و یک رویداد منتشر می‌کند
2. سرویس B به رویداد سرویس A گوش می‌دهد، تراکنش محلی خود را انجام داده و رویداد خود را منتشر می‌کند
3. سرویس C به رویداد سرویس B گوش می‌دهد و زنجیره را ادامه می‌دهد
4. اگر هر سرویسی شکست بخورد، یک رویداد شکست منتشر می‌کند که تراکنش‌های جبرانی را در سرویس‌های قبلی راه‌اندازی می‌کند

```
سرویس سفارش    سرویس مشتری    سرویس پرداخت    سرویس موجودی
     |                  |                   |                   |
     |-- سفارش ایجاد شد ->|                  |                   |
     |                  |-- اعتبار رزرو شد ->                   |
     |                  |                  |-- پرداخت شارژ شد -->
     |<--------------------- سفارش تأیید شد --------------------|
```

**ویژگی‌ها:**
- تصمیم‌گیری غیرمتمرکز
- سرویس‌ها از طریق رویدادها ارتباط برقرار می‌کنند
- هیچ نقطه شکست واحدی وجود ندارد
- درک و اشکال‌زدایی پیچیده‌تر است
- مناسب برای sagaهای ساده با مراحل کم

### Saga مبتنی بر ارکستراسیون

در ارکستراسیون، یک ارکستراتور saga (یک مؤلفه یا سرویس جداگانه) تمام تراکنش‌های saga را هماهنگ می‌کند. ارکستراتور به هر سرویس می‌گوید چه تراکنش محلی را اجرا کند و برای رویدادهای تکمیل گوش می‌دهد.

**نحوه کار:**
1. ارکستراتور یک فرمان به سرویس A برای اجرای تراکنش محلی ارسال می‌کند
2. سرویس A تراکنش خود را اجرا کرده و یک پاسخ به ارکستراتور ارسال می‌کند
3. ارکستراتور یک فرمان به سرویس B ارسال می‌کند
4. فرآیند تا تکمیل همه مراحل یا وقوع شکست ادامه می‌یابد
5. در صورت شکست، ارکستراتور فرمان‌های جبرانی به سرویس‌های قبلی ارسال می‌کند

```
                   ارکستراتور Saga
                         |
         +-------+-------+-------+-------+
         |       |       |       |       |
         v       v       v       v       v
      سرویس  سرویس   سرویس   سرویس   سرویس
      سفارش  مشتری   پرداخت  موجودی   تحویل
         |       |       |       |       |
         +-------+-------+-------+-------+
                         |
                   (فرمان‌ها و پاسخ‌ها)
```

**ویژگی‌ها:**
- منطق هماهنگی متمرکز
- ارکستراتور وضعیت saga را می‌داند
- درک، آزمایش و نظارت آسان‌تر است
- نقطه واحد هماهنگی (نه شکست اگر به‌درستی طراحی شود)
- بهتر برای sagaهای پیچیده با مراحل زیاد

## ۵. مثال عملی: پردازش سفارش تجارت الکترونیک

بیایید یک مثال کامل از ایجاد سفارش در یک سیستم تجارت الکترونیک با استفاده از الگوی Saga را بررسی کنیم.

### تراکنش کسب‌وکار: ایجاد سفارش

**سرویس‌های درگیر:**
1. **سرویس سفارش**: ایجاد سفارش
2. **سرویس مشتری**: تأیید و رزرو اعتبار مشتری
3. **سرویس پرداخت**: پردازش پرداخت
4. **سرویس آشپزخانه**: ایجاد تیکت برای آماده‌سازی غذا
5. **سرویس حسابداری**: ثبت تراکنش

### جریان موفقیت (مبتنی بر ارکستراسیون)

```
زمان    ارکستراتور    سفارش       مشتری      پرداخت     آشپزخانه    حسابداری
 |           |            |            |           |           |            |
 v      ایجاد سفارش       |            |           |           |            |
 |           |----------->|            |           |           |            |
 v           |         ایجاد شد        |           |           |            |
 |           |<-----------|            |           |           |            |
 v      رزرو اعتبار       |            |           |           |            |
 |           |------------------------>|           |           |            |
 v           |                      رزرو شد       |           |            |
 |           |<------------------------|           |           |            |
 v      شارژ پرداخت       |            |           |           |            |
 |           |--------------------------------->   |           |            |
 v           |                                  شارژ شد       |            |
 |           |<------------------------------------|           |            |
 v      ایجاد تیکت        |            |           |           |            |
 |           |------------------------------------------------>|            |
 v           |                                              ایجاد شد        |
 |           |<------------------------------------------------|            |
 v      ثبت تراکنش        |            |           |           |            |
 |           |------------------------------------------------------------>|
 v           |                                                           ثبت شد
 |           |<------------------------------------------------------------|
 v      تأیید سفارش        |            |           |           |            |
 |           |----------->|            |           |           |            |
 v           |         تأیید شد        |           |           |            |
```

### سناریوی شکست با تراکنش‌های جبرانی

چه اتفاقی می‌افتد اگر سرویس پرداخت پس از رزرو اعتبار توسط سرویس مشتری شکست بخورد؟

```
زمان    ارکستراتور    سفارش       مشتری      پرداخت
 |           |            |            |           |
 v      ایجاد سفارش       |            |           |
 |           |----------->|            |           |
 v           |         ایجاد شد        |           |
 |           |<-----------|            |           |
 v      رزرو اعتبار       |            |           |
 |           |------------------------>|           |
 v           |                      رزرو شد       |
 |           |<------------------------|           |
 v      شارژ پرداخت       |            |           |
 |           |--------------------------------->   |
 v           |                                  شکست خورد
 |           |<------------------------------------|
 v      لغو رزرو اعتبار   |            |           |
 |           |------------------------>|           |
 |           |                      لغو رزرو شد   |
 |           |<------------------------|           |
 v      رد سفارش          |            |           |
 |           |----------->|            |           |
 v           |         رد شد          |           |
```

**تراکنش‌های جبرانی:**
1. **سفارش ایجاد شد** ← لغو سفارش
2. **اعتبار رزرو شد** ← لغو رزرو اعتبار
3. **پرداخت شارژ شد** ← بازپرداخت
4. **تیکت ایجاد شد** ← لغو تیکت
5. **تراکنش ثبت شد** ← معکوس‌سازی تراکنش

## ۶. تراکنش‌های جبرانی

تراکنش‌های جبرانی مکانیزم کلیدی هستند که به sagaها اجازه می‌دهند بدون قفل‌های توزیع‌شده، اتمی بودن را فراهم کنند. آن‌ها یک **بازگشت معنایی** انجام می‌دهند نه یک بازگشت فنی.

### تعریف

تراکنش جبرانی یک تراکنش محلی است که اثر کسب‌وکاری یک تراکنش محلی قبلی در saga را خنثی می‌کند. این تراکنش پایگاه داده را به وضعیت قبلی دقیق آن بازنمی‌گرداند (مانند بازگشت پایگاه داده)، بلکه عملیات کسب‌وکار معکوس را اعمال می‌کند.

### مثال‌ها

| تراکنش اصلی | تراکنش جبرانی |
|---------------------|-------------------------|
| رزرو اعتبار | لغو رزرو اعتبار |
| شارژ پرداخت | بازپرداخت |
| رزرو موجودی | آزادسازی موجودی |
| ایجاد سفارش | لغو سفارش |
| ارسال ایمیل | ارسال ایمیل لغو |
| قفل حساب | باز کردن قفل حساب |

### الزامات کلیدی برای تراکنش‌های جبرانی

**۱. بی‌توانی (Idempotency)**

تراکنش‌های جبرانی باید بی‌توان باشند زیرا ممکن است به دلیل شکست‌ها یا تلاش‌های مجدد چندین بار اجرا شوند. به عنوان مثال، اگر "بازپرداخت" دو بار با همان شناسه بازپرداخت فراخوانی شود، باید فقط یک بار بازپرداخت کند.

```
// عملیات بازپرداخت بی‌توان
refundPayment(orderId, amount) {
    if (refundAlreadyProcessed(orderId)) {
        return SUCCESS; // قبلاً بازپرداخت شده، رد شو
    }
    processRefund(orderId, amount);
    recordRefund(orderId);
    return SUCCESS;
}
```

**۲. صحت معنایی**

تراکنش جبرانی باید به‌درستی اثر کسب‌وکاری را خنثی کند. به عنوان مثال، اگر اعتبار مشتری ۱۰۰ دلار رزرو شده بود، تراکنش جبرانی باید دقیقاً ۱۰۰ دلار را لغو رزرو کند، نه مبلغ متفاوتی.

**۳. موفقیت نهایی**

تراکنش‌های جبرانی باید به گونه‌ای طراحی شوند که حتی اگر در ابتدا شکست بخورند، در نهایت موفق شوند. این اغلب به مکانیزم‌های تلاش مجدد و مدیریت خطای مناسب نیاز دارد.

### مدیریت شکست تراکنش جبرانی

اگر خود تراکنش جبرانی شکست بخورد چه؟ این یک سناریوی بحرانی است که نیاز به طراحی دقیق دارد:

**استراتژی‌ها:**
1. **تلاش مجدد با عقب‌نشینی**: به‌طور خودکار تراکنش جبرانی را مجدداً تلاش کنید
2. **مداخله دستی**: تیم عملیات را برای جبران دستی هشدار دهید
3. **مهلت تا دستی**: پس از N تلاش مجدد، به فرآیند دستی ارجاع دهید
4. **جبران جایگزین**: یک اقدام جبرانی جایگزین را امتحان کنید

**نکته مهم**: همه تراکنش‌ها قابل جبران نیستند. برخی عملیات (مانند ارسال ایمیل یا انتشار پیام به سیستم‌های خارجی) واقعاً قابل بازگشت نیستند. در این موارد، باید:
- آن‌ها را آخرین مرحله در saga قرار دهید
- از جبران معنایی استفاده کنید (ارسال ایمیل لغو)
- سیستم را برای مدیریت عملیات تکراری طراحی کنید

## ۷. بررسی عمیق کوریوگرافی در مقابل ارکستراسیون

### مقایسه تفصیلی

| جنبه | کوریوگرافی | ارکستراسیون |
|--------|-------------|---------------|
| **هماهنگی** | غیرمتمرکز (سرویس‌ها از طریق رویدادها هماهنگ می‌شوند) | متمرکز (ارکستراتور همه سرویس‌ها را هماهنگ می‌کند) |
| **وابستگی سرویس‌ها** | سرویس‌ها به رویدادهای سرویس‌های دیگر وابسته‌اند | سرویس‌ها فقط به فرمان‌های ارکستراتور وابسته‌اند |
| **محل منطق Saga** | توزیع شده در تمام سرویس‌های شرکت‌کننده | متمرکز در ارکستراتور |
| **اتصال** | اتصال سست بین سرویس‌ها | سرویس‌ها به رابط ارکستراتور متصل‌اند |
| **پیچیدگی** | پیچیده برای sagaهای با مراحل زیاد | ساده‌تر برای sagaهای پیچیده |
| **آزمایش** | آزمایش سخت‌تر (نیاز به شبیه‌سازی چندین سرویس) | آزمایش آسان‌تر (آزمایش منطق ارکستراتور) |
| **اشکال‌زدایی** | ردیابی وضعیت saga دشوار | ردیابی وضعیت saga آسان (در ارکستراتور) |
| **نقطه شکست واحد** | بدون نقطه مرکزی | ارکستراتور نقطه هماهنگی است |
| **مقیاس‌پذیری** | هر سرویس مستقلاً مقیاس می‌شود | ارکستراتور باید تمام هماهنگی saga را مدیریت کند |
| **درک** | درک جریان کامل دشوار | درک جریان آسان (تعریف شده در ارکستراتور) |
| **تکامل** | تغییر دشوار (باید چندین سرویس را به‌روزرسانی کرد) | تغییر آسان‌تر (به‌روزرسانی ارکستراتور) |
| **نظارت** | باید رویدادها را در سرویس‌ها نظارت کرد | نظارت بر وضعیت ارکستراتور |

### چه زمانی از کوریوگرافی استفاده کنیم

✓ از کوریوگرافی زمانی استفاده کنید که:
- saga شامل سرویس‌های کمی است (۲-۴)
- منطق کسب‌وکار ساده و پایدار است
- سرویس‌ها از قبل از طریق رویدادها ارتباط برقرار می‌کنند
- حداکثر استقلال سرویس می‌خواهید
- سازمان فرهنگ رویداد‌محور قوی دارد

مثال: یک saga ساده با سرویس سفارش ← سرویس پرداخت ← سرویس اطلاع‌رسانی

### چه زمانی از ارکستراسیون استفاده کنیم

✓ از ارکستراسیون زمانی استفاده کنید که:
- saga شامل سرویس‌های زیادی است (بیش از ۵)
- منطق کسب‌وکار پیچیده با جریان‌های شرطی
- منطق saga به‌طور مکرر تغییر می‌کند
- نیاز به نظارت متمرکز دارید
- تیم تازه با الگوی saga آشنا شده

مثال: یک فرآیند تکمیل سفارش پیچیده شامل بیش از ۱۰ سرویس با منطق شرطی

### رویکرد ترکیبی

در عمل، بسیاری از سیستم‌ها از رویکرد ترکیبی استفاده می‌کنند:
- از کوریوگرافی برای sagaهای ساده و پایدار استفاده کنید
- از ارکستراسیون برای sagaهای پیچیده استفاده کنید
- sagaهای مختلف در همان سیستم می‌توانند از سبک‌های هماهنگی متفاوت استفاده کنند

## ۸. مصالحه‌های طراحی سیستم

### مزایا ✓

**۱. دسترس‌پذیری بالا**
- بدون قفل‌های توزیع‌شده به این معنی که سرویس‌ها در دسترس می‌مانند
- شکست یک سرویس دیگران را مسدود نمی‌کند
- تحمل خطای بهتر در سیستم‌های توزیع‌شده

**۲. اتصال سست**
- سرویس‌ها استقلال خود را حفظ می‌کنند
- نیازی نیست همه سرویس‌ها به‌طور همزمان در دسترس باشند
- سرویس‌ها می‌توانند مستقلاً توسعه و استقرار یابند

**۳. پشتیبانی از پایگاه داده NoSQL**
- با پایگاه‌های داده‌ای که از 2PC پشتیبانی نمی‌کنند کار می‌کند
- می‌تواند انواع مختلف پایگاه داده را ترکیب کند (SQL، NoSQL، ذخیره کلید-مقدار)
- انعطاف‌پذیری بیشتر در انتخاب‌های فناوری

**۴. مقیاس‌پذیری**
- هر سرویس می‌تواند مستقلاً مقیاس شود
- بدون مدیر قفل مرکزی که به گلوگاه تبدیل شود
- عملکرد بهتر تحت بار زیاد

**۵. فعال‌سازی معماری میکروسرویس**
- تراکنش‌های کسب‌وکار پیچیده را در بین سرویس‌ها ممکن می‌سازد
- مزایای الگوی پایگاه داده به ازای هر سرویس را حفظ می‌کند
- از استقلال سرویس پشتیبانی می‌کند

### معایب ✗

**۱. فقط سازگاری نهایی**
- بدون تضمین سازگاری فوری
- برنامه باید حالت‌های میانی را مدیریت کند
- برای موارد استفاده‌ای که سازگاری سخت لازم است مناسب نیست

**۲. افزایش پیچیدگی**
- نیاز به طراحی تراکنش‌های جبرانی
- مدیریت خطای پیچیده‌تر
- استدلال درباره وضعیت سیستم دشوارتر

**۳. فقدان ایزوله‌سازی**
- sagaهای همزمان می‌توانند با یکدیگر تداخل کنند
- خواندن‌های کثیف و به‌روزرسانی‌های از دست رفته ممکن است
- نیاز به اقدامات متقابل اضافی برای ایزوله‌سازی

**۴. پیچیدگی آزمایش**
- باید مسیرهای موفقیت، مسیرهای شکست و مسیرهای جبران آزمایش شوند
- بازتولید سناریوهای شکست دشوارتر
- آزمایش یکپارچگی نیاز به چندین سرویس دارد

**۵. چالش‌های اشکال‌زدایی**
- وضعیت saga توزیع شده (کوریوگرافی) یا متمرکز (ارکستراسیون) است
- باید رویدادها/پیام‌ها را در بین سرویس‌ها ردیابی کرد
- نیاز به مشاهده‌پذیری و ثبت وقایع خوب

**۶. پیچیدگی عملیاتی**
- نیاز به نظارت بر وضعیت saga
- نیاز به مکانیزم‌هایی برای مدیریت sagaهای گیر کرده
- ممکن است مداخله دستی برای شکست‌های جبران لازم باشد

## ۹. مقایسه Saga با Two-Phase Commit

درک اینکه چه زمانی از Saga در مقابل Two-Phase Commit (2PC) استفاده کنیم برای طراحی سیستم بسیار مهم است.

### مقایسه کنار هم

| جنبه | الگوی Saga | Two-Phase Commit (2PC) |
|--------|-------------|------------------------|
| **مدل سازگاری** | سازگاری نهایی (BASE) | سازگاری فوری (ACID) |
| **هماهنگی** | رویداد‌محور یا ارکستره‌شده | مراحل آماده‌سازی ← رأی ← تأیید |
| **مسدودسازی** | غیرمسدود (سرویس‌ها منتظر نمی‌مانند) | مسدود (سرویس‌ها قفل نگه می‌دارند) |
| **دسترس‌پذیری** | بالا (سرویس‌ها در دسترس می‌مانند) | پایین‌تر (شکست همه را مسدود می‌کند) |
| **ایزوله‌سازی** | بدون ایزوله‌سازی بین sagaها | ایزوله‌سازی کامل با قفل‌ها |
| **مکانیزم بازگشت** | تراکنش‌های جبرانی (معنایی) | بازگشت پایگاه داده (فنی) |
| **پشتیبانی پایگاه داده** | با هر پایگاه داده‌ای کار می‌کند | نیاز به پشتیبانی 2PC (تراکنش‌های XA) |
| **پیچیدگی** | پیچیدگی برنامه بالاتر | پیچیدگی برنامه پایین‌تر |
| **عملکرد** | بهتر (بدون سربار قفل) | بدتر (سربار قفل و هماهنگی) |
| **مورد استفاده** | میکروسرویس‌ها، سیستم‌های توزیع‌شده | مونولیت‌ها، سیستم‌های با اتصال محکم |
| **پشتیبانی NoSQL** | بله | خیر (بیشتر پایگاه‌های داده NoSQL از 2PC پشتیبانی نمی‌کنند) |
| **نقطه شکست واحد** | خیر (کوریوگرافی) یا ارکستراتور (ارکستراسیون) | هماهنگ‌کننده (اما قابل تکرار) |
| **مقیاس‌پذیری** | بالا | محدود توسط هماهنگ‌کننده و قفل‌ها |

### مقایسه بصری

```
Two-Phase Commit (2PC)              الگوی Saga
     هماهنگ‌کننده                    گذرگاه رویداد / ارکستراتور
          |                                  |
    +-----+-----+                      +-----+-----+
    |     |     |                      |     |     |
    v     v     v                      v     v     v
  سرویس۱ سرویس۲ سرویس۳              سرویس۱ سرویس۲ سرویس۳
          |                                  |
    [آماده‌سازی]                        [تراکنش محلی]
    [رأی بله/خیر]                      [انتشار رویداد]
    [قفل نگه‌داشته شده]                [بدون قفل]
    [تأیید/لغو]                        [جبران در صورت نیاز]
          |                                  |
    سازگاری قوی                       سازگاری نهایی
    دسترس‌پذیری پایین                  دسترس‌پذیری بالا
```

### ماتریس تصمیم: چه زمانی از چه چیزی استفاده کنیم

**از Two-Phase Commit زمانی استفاده کنید که:**
- ✓ نیاز به تضمین‌های قوی ACID دارید
- ✓ سازگاری فوری لازم است
- ✓ در یک برنامه مونولیتیک کار می‌کنید
- ✓ همه پایگاه‌های داده از تراکنش‌های XA پشتیبانی می‌کنند
- ✓ توان عملیاتی پایین‌تر قابل قبول است
- ✓ شکست‌ها نادر هستند

**از الگوی Saga زمانی استفاده کنید که:**
- ✓ معماری میکروسرویس می‌سازید
- ✓ نیاز به دسترس‌پذیری و مقیاس‌پذیری بالا دارید
- ✓ از پایگاه‌های داده NoSQL یا انواع مختلط استفاده می‌کنید
- ✓ سازگاری نهایی قابل قبول است
- ✓ سرویس‌ها باید مستقل باقی بمانند
- ✓ تراکنش‌های طولانی‌مدت

### تشبیه دنیای واقعی

**Two-Phase Commit** مانند یک رقص گروهی هماهنگ است که همه باید دقیقاً در یک زمان شروع، حرکت و توقف کنند. اگر یک رقصنده بیفتد، کل اجرا متوقف می‌شود.

**الگوی Saga** مانند یک مسابقه دو امدادی است که هر دونده مرحله خود را مستقلاً تکمیل می‌کند و چوب امدادی را پاس می‌دهد. اگر دونده‌ای چوب را بیندازد، آن را برمی‌دارد و مسابقه ادامه می‌یابد (یا دیگران برای جبران به عقب می‌دوند).

## ۱۰. سناریوهای شکست و استراتژی‌های بازیابی

مدیریت شکست‌ها در مرکز الگوی Saga قرار دارد. بیایید سناریوهای شکست رایج و استراتژی‌های بازیابی را بررسی کنیم.

### سناریو ۱: شکست سرویس در میانه Saga

**مشکل**: یک سرویس در حین اجرای تراکنش محلی خود شکست می‌خورد.

```
سرویس سفارش → سرویس مشتری → [سرویس پرداخت شکست می‌خورد] → سرویس آشپزخانه
```

**استراتژی بازیابی:**

1. **تشخیص شکست**: مهلت زمانی یا پاسخ خطای صریح
2. **راه‌اندازی جبران**: ارکستراتور (یا سرویس قبلی در کوریوگرافی) تراکنش‌های جبرانی را آغاز می‌کند
3. **جبران به ترتیب معکوس**:
   - لغو رزرو اعتبار (سرویس مشتری)
   - لغو سفارش (سرویس سفارش)

**ملاحظات پیاده‌سازی:**
- مهلت‌های زمانی مناسب برای هر مرحله تنظیم کنید
- بین شکست‌های موقت (تلاش مجدد) و دائمی (جبران) تمایز قائل شوید
- عقب‌نشینی نمایی برای تلاش‌های مجدد پیاده‌سازی کنید
- تمام شکست‌ها را برای اشکال‌زدایی ثبت کنید

### سناریو ۲: پارتیشن شبکه

**مشکل**: پارتیشن شبکه از ارتباط بین سرویس‌ها جلوگیری می‌کند.

```
سرویس سفارش → | پارتیشن شبکه | → سرویس مشتری
```

**استراتژی بازیابی:**

1. **تشخیص مهلت زمانی**: سرویس در مهلت زمانی پاسخی دریافت نمی‌کند
2. **تلاش مجدد با بی‌توانی**: عملیات را تکرار کنید (سرویس باید درخواست‌های تکراری را مدیریت کند)
3. **جبران نهایی**: اگر تلاش‌های مجدد تمام شد، تراکنش‌های جبرانی را راه‌اندازی کنید
4. **تطبیق**: پس از بهبود پارتیشن، وضعیت را تطبیق دهید

**ملاحظات پیاده‌سازی:**
- از کلیدهای بی‌توانی برای تمام عملیات استفاده کنید
- معنای تحویل حداقل-یک‌بار پیاده‌سازی کنید
- از صف‌های پیام برای تحویل قابل اعتماد استفاده کنید
- فرآیندهای تطبیق برای تأیید وضعیت بسازید

### سناریو ۳: شکست تراکنش جبرانی

**مشکل**: یک تراکنش جبرانی شکست می‌خورد.

```
Saga شکست می‌خورد → جبران مرحله ۳ → جبران مرحله ۲ → [جبران مرحله ۱ شکست می‌خورد]
```

**استراتژی بازیابی:**

1. **تلاش مجدد با عقب‌نشینی نمایی**: به‌طور خودکار تراکنش جبرانی را مجدداً تلاش کنید
2. **قطع‌کننده مدار**: پس از آستانه، تلاش مجدد را متوقف کرده و saga را برای مداخله دستی علامت‌گذاری کنید
3. **صف نامه‌های مرده**: جبران شکست‌خورده را به DLQ برای پردازش دستی منتقل کنید
4. **هشدار به تیم عملیات**: ممکن است مداخله انسانی لازم باشد
5. **حل نهایی**: به تلاش مجدد ادامه دهید تا به‌صورت دستی حل شود

**پیاده‌سازی:**
```
compensate(saga, step) {
    maxRetries = 5;
    retryCount = 0;

    while (retryCount < maxRetries) {
        try {
            executeCompensatingTransaction(step);
            return SUCCESS;
        } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
                moveToDLQ(saga, step);
                alertOperations(saga, step, error);
                return MANUAL_INTERVENTION_REQUIRED;
            }
            sleep(exponentialBackoff(retryCount));
        }
    }
}
```

### سناریو ۴: مدیریت مهلت زمانی

**مشکل**: سرویس در زمان مورد انتظار پاسخ نمی‌دهد.

**استراتژی بازیابی:**

1. **مهلت زمانی کوتاه**: مشکلات را سریع تشخیص دهید
2. **منطق تلاش مجدد**: عملیات را با بی‌توانی تکرار کنید
3. **بازگشت به جبران**: اگر تلاش‌های مجدد تمام شد، جبران کنید
4. **نظارت**: نرخ مهلت‌های زمانی را برای شناسایی مشکلات سیستمی ردیابی کنید

**پیکربندی مهلت زمانی:**
```
مهلت‌های زمانی عملیات سرویس:
- عملیات پایگاه داده: ۵ ثانیه
- فراخوانی‌های API خارجی: ۱۰ ثانیه
- مهلت زمانی کل مرحله saga: ۳۰ ثانیه
- مهلت زمانی کل saga: ۵ دقیقه
```

### سناریو ۵: شکست جزئی

**مشکل**: عملیات به‌طور جزئی تکمیل می‌شود (مثلاً پرداخت شارژ شده اما به‌روزرسانی پایگاه داده شکست می‌خورد).

**استراتژی بازیابی:**

1. **الگوی صندوق خروجی تراکنشی**: اطمینان از اتمی بودن تراکنش محلی و انتشار رویداد
2. **ناشر نظرسنجی**: به‌طور دوره‌ای رویدادهای منتشر نشده را بررسی کنید
3. **جبران بی‌توان**: جبران‌ها را برای مدیریت حالت‌های جزئی طراحی کنید

### اصول کلی بازیابی

**۱. بی‌توانی همه‌جا**
- تمام عملیات (پیشرو و جبرانی) باید بی‌توان باشند
- از شناسه‌های تراکنش منحصربه‌فرد برای تشخیص تکراری‌ها استفاده کنید

**۲. مشاهده‌پذیری**
- تمام مراحل saga را با شناسه‌های همبستگی ثبت کنید
- نرخ تکمیل saga را نظارت کنید
- درباره sagaهای گیر کرده یا شکست‌خورده هشدار دهید

**۳. مهلت‌های زمانی و تلاش‌های مجدد**
- مهلت‌های زمانی مناسب برای هر مرحله تنظیم کنید
- تلاش مجدد با عقب‌نشینی نمایی پیاده‌سازی کنید
- بین خطاهای قابل تلاش مجدد و غیرقابل تلاش مجدد تمایز قائل شوید

**۴. مداخله دستی**
- ابزارهایی برای تیم عملیات بسازید تا وضعیت saga را بررسی کنند
- مکانیزم‌هایی برای تکمیل یا جبران دستی sagaها فراهم کنید
- گزارش‌های حسابرسی برای انطباق نگه‌دارید

## ۱۱. چالش‌های ایزوله‌سازی

یکی از بزرگ‌ترین چالش‌های الگوی Saga فقدان ایزوله‌سازی ACID است. برخلاف تراکنش‌های پایگاه داده که ایزوله‌سازی کامل فراهم می‌کنند، sagaها یک سری تراکنش‌های محلی اجرا می‌کنند که به‌صورت فردی ایزوله شده‌اند اما به‌صورت جمعی ایزوله نیستند.

### مشکل: فقدان ایزوله‌سازی

دو saga همزمان را در نظر بگیرید که روی همان حساب مشتری عمل می‌کنند:

```
زمان    Saga A (ایجاد سفارش)          Saga B (به‌روزرسانی حد اعتبار)
 |      اعتبار مشتری: ۱۰۰۰ دلار       اعتبار مشتری: ۱۰۰۰ دلار
 v
 |      رزرو ۸۰۰ دلار
 |      (موجودی: ۲۰۰ دلار)
 v                                     خواندن موجودی: ۲۰۰ دلار
 |                                     افزایش حد: ۲۰۰ دلار → ۵۰۰ دلار
 |                                     (موجودی: ۵۰۰ دلار)
 v      پرداخت شکست می‌خورد
 |      لغو رزرو ۸۰۰ دلار
 |      (موجودی: ۱۰۰۰ دلار)
 v                                     نوشتن حد جدید: ۵۰۰ دلار
 |                                     (باید ۱۳۰۰ دلار باشد، نه ۵۰۰ دلار)
 |
نتیجه: به‌روزرسانی از دست رفته! به‌روزرسانی Saga B بر اساس داده‌های قدیمی بود.
```

### ناهنجاری‌های داده در Sagaها

**۱. به‌روزرسانی‌های از دست رفته**

دو saga همان داده را می‌خوانند، تغییرات ایجاد می‌کنند و هر دو می‌نویسند، با یکی که دیگری را بازنویسی می‌کند.

**۲. خواندن‌های کثیف**

Saga A داده‌ای را می‌خواند که Saga B تغییر داده اما ممکن است بعداً جبران کند (بازگشت)، که باعث می‌شود Saga A بر اساس داده‌هایی تصمیم بگیرد که خنثی خواهند شد.

```
زمان    Saga A                        Saga B
 |                                    رزرو آیتم موجودی X
 v      خواندن: آیتم X رزرو شده
 |      رد آیتم X (از قبل رزرو شده)
 v                                    پرداخت شکست می‌خورد
 |                                    لغو رزرو آیتم X
 v      (آیتم X واقعاً در دسترس بود)
```

**۳. خواندن‌های غیرقابل تکرار**

Saga A همان داده را دو بار در طول اجرای خود می‌خواند و مقادیر متفاوتی دریافت می‌کند زیرا Saga B آن را در بین تغییر داده است.

### اقدامات متقابل برای مشکلات ایزوله‌سازی

**۱. قفل معنایی**

تراکنش قابل جبران یک saga پرچمی (قفل معنایی) روی هر رکوردی که ایجاد یا به‌روزرسانی می‌کند قرار می‌دهد. پرچم نشان می‌دهد که رکورد ممکن است تغییر کند اگر saga جبران شود.

```
Order {
    id: "123",
    status: "PENDING",  // قفل معنایی
    amount: 100
}

// sagaهای دیگر قبل از عمل وضعیت را بررسی می‌کنند
if (order.status == "PENDING") {
    // سفارش ممکن است جبران شود، با دقت مدیریت کنید
}
```

**۲. به‌روزرسانی‌های جابه‌جایی‌پذیر**

به‌روزرسانی‌ها را جابه‌جایی‌پذیر (مستقل از ترتیب) طراحی کنید تا sagaهای همزمان تداخل نداشته باشند.

**غیرجابه‌جایی‌پذیر (مشکل‌ساز):**
```
balance = balance - 100  // ترتیب مهم است
```

**جابه‌جایی‌پذیر (امن):**
```
transactions.add(new Debit(100))  // می‌تواند به هر ترتیبی اعمال شود
```

**۳. دید بدبینانه**

مراحل saga را مجدداً مرتب کنید تا ریسک خواندن‌های کثیف را با اجرای مراحل بالقوه قابل جبران در آخر به حداقل برسانید.

**ترتیب مشکل‌ساز:**
```
1. رزرو موجودی (ممکن است جبران شود)
2. اعتبارسنجی مشتری (از وضعیت موجودی استفاده می‌کند)
3. پردازش پرداخت
```

**ترتیب بهتر:**
```
1. اعتبارسنجی مشتری (بدون ریسک جبران)
2. پردازش پرداخت (ریسک جبران کم)
3. رزرو موجودی (ممکن است جبران شود، اما هیچ چیز به آن وابسته نیست)
```

**۴. بازخوانی مقدار (قفل خوش‌بینانه)**

قبل از به‌روزرسانی، مقدار را مجدداً بخوانید و تأیید کنید که تغییر نکرده است. اگر تغییر کرده، لغو یا تلاش مجدد کنید.

```
updateCustomerCredit(customerId, delta) {
    initialCredit = readCredit(customerId);
    newCredit = initialCredit + delta;

    success = updateWithVersionCheck(
        customerId,
        newCredit,
        expectedVersion: initialCredit.version
    );

    if (!success) {
        // saga دیگری اعتبار را تغییر داده، تلاش مجدد یا لغو
        return CONFLICT;
    }
}
```

**۵. فایل نسخه**

از شماره نسخه‌ها یا برچسب‌های زمانی برای تشخیص تغییرات همزمان استفاده کنید.

```
Customer {
    id: "456",
    creditLimit: 1000,
    version: 5  // در هر به‌روزرسانی افزایش می‌یابد
}

// فقط در صورتی به‌روزرسانی کنید که نسخه مطابقت داشته باشد
UPDATE customers
SET creditLimit = 1500, version = 6
WHERE id = '456' AND version = 5
```

**۶. بر اساس مقدار**

از مقادیر خاص به جای تغییرات نسبی برای جلوگیری از به‌روزرسانی‌های از دست رفته استفاده کنید.

**پرریسک:**
```
incrementBalance(amount)  // فراخوانی‌های متعدد می‌توانند تداخل کنند
```

**امن‌تر:**
```
setBalance(newValue)  // مقدار صریح، ابهام کمتر
```

### انتخاب اقدامات متقابل

انتخاب به نیازمندی‌های شما بستگی دارد:

| نیازمندی | اقدام متقابل پیشنهادی |
|------------|---------------------------|
| جلوگیری از خواندن‌های کثیف | قفل معنایی |
| جلوگیری از به‌روزرسانی‌های از دست رفته | بازخوانی مقدار، فایل نسخه |
| همزمانی بالا | به‌روزرسانی‌های جابه‌جایی‌پذیر |
| پیاده‌سازی ساده | دید بدبینانه |
| نیاز به سازگاری قوی | به جای Saga از 2PC استفاده کنید |

## ۱۲. کاربردهای دنیای واقعی

درک اینکه الگوی Saga کجا استفاده می‌شود (و کجا نمی‌شود) به هدایت تصمیمات طراحی کمک می‌کند.

### جاهایی که الگوی Saga استفاده می‌شود ✓

**۱. پلتفرم‌های تجارت الکترونیک**

**مورد استفاده**: پردازش سفارش در چندین سرویس
- سرویس سفارش: ایجاد سفارش
- سرویس پرداخت: پردازش پرداخت
- سرویس موجودی: رزرو آیتم‌ها
- سرویس حمل‌ونقل: زمان‌بندی تحویل
- سرویس اطلاع‌رسانی: ارسال تأییدیه‌ها

**چرا Saga**: دسترس‌پذیری بالا حیاتی است، سازگاری نهایی برای پردازش سفارش قابل قبول است.

**مثال‌ها**: آمازون، eBay، Shopify

**۲. سیستم‌های پرداخت**

**مورد استفاده**: پردازش پرداخت چندطرفه
- بدهی حساب کاربر
- بستانکاری حساب فروشنده
- محاسبه کارمزد
- ثبت تراکنش
- اطلاع‌رسانی

**چرا Saga**: نیاز به مدیریت ملایم شکست‌ها، جبران با بازپرداخت، حفظ دنباله‌های حسابرسی.

**مثال‌ها**: PayPal، Stripe (پردازش داخلی)

**۳. سیستم‌های رزرو سفر**

**مورد استفاده**: رزرو سفر کامل (پرواز + هتل + اجاره خودرو)
- رزرو پرواز
- رزرو هتل
- رزرو خودرو
- پردازش پرداخت
- ارسال تأییدیه

**چرا Saga**: باید بتوان رزروها را در صورت شکست هر بخشی لغو کرد، تراکنش‌های طولانی‌مدت، نیاز به دسترس‌پذیری بالا.

**مثال‌ها**: Expedia، Booking.com

**۴. پلتفرم‌های تحویل غذا**

**مورد استفاده**: تکمیل سفارش
- اعتبارسنجی سفارش
- شارژ مشتری
- اطلاع‌رسانی به رستوران
- تخصیص راننده
- ردیابی تحویل

**چرا Saga**: هماهنگی بلادرنگ در چندین سرویس، نیاز به مدیریت لغوها، الزامات دسترس‌پذیری بالا.

**مثال‌ها**: Uber Eats، DoorDash

**۵. پلتفرم‌های معاملات مالی**

**مورد استفاده**: جریان‌های کاری معاملاتی غیربحرانی (نه اجرای اصلی معاملات)
- متعادل‌سازی پرتفوی
- بهینه‌سازی تخصیص مالیاتی
- جریان‌های کاری گزارش‌دهی

**چرا Saga**: جریان‌های کاری طولانی‌مدت با مراحل متعدد، سازگاری نهایی برای این موارد استفاده خاص قابل قبول است.

### جاهایی که الگوی Saga استفاده نمی‌شود ✗

**۱. تراکنش‌های بانکی اصلی**

**چرا نه**: نیاز به تضمین‌های قوی ACID، سازگاری فوری حیاتی، نمی‌توان سازگاری نهایی را پذیرفت.

**به جای آن استفاده کنید**: [Two-Phase Commit](two-phase-commit.fa.md)، پایگاه‌های داده توزیع‌شده با سازگاری قوی.

**۲. اجرای معاملات بلادرنگ**

**چرا نه**: الزامات تأخیر میلی‌ثانیه‌ای، نیاز به سازگاری فوری، نمی‌توان ریسک خواندن‌های کثیف را پذیرفت.

**به جای آن استفاده کنید**: پایگاه‌های داده درون حافظه، تراکنش‌های تک پایگاه داده، سیستم‌های تخصصی معاملات.

**۳. برنامه‌های مونولیتیک**

**چرا نه**: تمام داده‌ها در یک پایگاه داده واحد، می‌توان از تراکنش‌های ACID محلی استفاده کرد، saga پیچیدگی غیرضروری اضافه می‌کند.

**به جای آن استفاده کنید**: تراکنش‌های پایگاه داده (BEGIN/COMMIT/ROLLBACK).

**۴. مدیریت موجودی با الزامات سازگاری قوی**

**چرا نه**: نمی‌توان ریسک فروش بیش از حد را به دلیل سازگاری نهایی پذیرفت، نیاز به به‌روزرسانی فوری موجودی.

**به جای آن استفاده کنید**: منبع حقیقت واحد با تراکنش‌های ACID، قفل‌های توزیع‌شده در صورت نیاز در بین سرویس‌ها.

**۵. احراز هویت/مجوز کاربر**

**چرا نه**: عملیات حیاتی امنیتی که سازگاری فوری نیاز دارند، نمی‌توان سازگاری نهایی را برای کنترل دسترسی پذیرفت.

**به جای آن استفاده کنید**: سرویس احراز هویت متمرکز با سازگاری قوی.

### پذیرش صنعتی

**شرکت‌های فناوری که از Saga استفاده می‌کنند:**
- **مایکروسافت**: Azure Durable Functions برای ارکستراسیون saga
- **نتفلیکس**: موتور جریان کاری Conductor برای sagaهای مبتنی بر ارکستراسیون
- **اوبر**: موتور جریان کاری Cadence برای sagaهای طولانی‌مدت
- **AWS**: Step Functions برای ارکستراسیون saga
- **Airbnb**: فریمورک‌های ارکستراسیون داخلی

**فریمورک‌ها و ابزارها:**
- Axon Framework (جاوا)
- NServiceBus (سی‌شارپ)
- MassTransit (دات‌نت)
- Eventuate Tram Saga Framework (جاوا)
- Temporal (موتور جریان کاری با پشتیبانی از saga)

## ۱۳. الگوهای مرتبط

الگوی Saga به‌تنهایی وجود ندارد. بخشی از یک اکوسیستم گسترده‌تر از الگوهای سیستم توزیع‌شده است.

### پایگاه داده به ازای هر سرویس (پیش‌نیاز)

**رابطه**: الگوی Saga راه‌حلی برای مشکل تراکنش توزیع‌شده ایجاد شده توسط الگوی پایگاه داده به ازای هر سرویس است.

**توضیح**: هر میکروسرویس پایگاه داده خود را دارد که هیچ سرویس دیگری نمی‌تواند مستقیماً به آن دسترسی داشته باشد.

**چرا مرتبط**: بدون پایگاه داده به ازای هر سرویس، می‌توانید از تراکنش‌های محلی پایگاه داده استفاده کنید. Saga زمانی ضروری می‌شود که سرویس‌ها پایگاه‌های داده جداگانه دارند.

### منبع‌یابی رویداد (تکنیک پیاده‌سازی)

**رابطه**: منبع‌یابی رویداد می‌تواند برای پیاده‌سازی الگوی Saga استفاده شود.

**توضیح**: ذخیره تمام تغییرات وضعیت برنامه به عنوان دنباله‌ای از رویدادها به جای ذخیره فقط وضعیت فعلی.

**نحوه همکاری**:
- مراحل Saga رویدادهای دامنه منتشر می‌کنند
- ذخیره‌گاه رویداد دنباله حسابرسی اجرای saga را فراهم می‌کند
- رویدادها sagaهای مبتنی بر کوریوگرافی را فعال می‌کنند
- بازپخش رویداد به اشکال‌زدایی و بازیابی کمک می‌کند

**مثال**: وقتی سرویس سفارش یک سفارش ایجاد می‌کند، رویداد "OrderCreated" را منتشر می‌کند که مرحله بعدی saga را راه‌اندازی می‌کند.

### CQRS (اغلب ترکیب می‌شود)

**رابطه**: CQRS (جداسازی مسئولیت فرمان و پرس‌وجو) اغلب در کنار sagaها استفاده می‌شود.

**توضیح**: جداسازی مدل‌های خواندن و نوشتن برای مقیاس‌پذیری و عملکرد بهتر.

**نحوه همکاری**:
- فرمان‌های Saga مدل نوشتن را به‌روزرسانی می‌کنند
- رویدادهای Saga مدل خواندن را به‌روزرسانی می‌کنند
- مدل پرس‌وجو نمای سازگار نهایی فراهم می‌کند
- فرمان‌ها و رویدادها با مراحل saga هم‌راستا هستند

**مثال**: Saga سفارش مدل نوشتن سفارش را به‌روزرسانی می‌کند و رویدادها مدل‌های خواندن مختلف (تاریخچه سفارش، نمای مشتری، تحلیلات) را پر می‌کنند.

### صندوق خروجی تراکنشی (انتشار قابل اعتماد رویداد)

**رابطه**: مشکل انتشار قابل اعتماد رویدادها به عنوان بخشی از مراحل saga را حل می‌کند.

**توضیح**: ذخیره رویدادها در یک جدول صندوق خروجی در همان تراکنش پایگاه داده با موجودیت کسب‌وکار، سپس انتشار رویدادها به‌صورت ناهمزمان.

**چرا برای Sagaها حیاتی**: اطمینان از اتمی بودن تراکنش محلی و انتشار رویداد، جلوگیری از گیر کردن saga به دلیل رویدادهای منتشر نشده.

**مثال**:
```
BEGIN TRANSACTION
    UPDATE orders SET status = 'APPROVED'
    INSERT INTO outbox (event_type, payload) VALUES ('OrderApproved', {...})
COMMIT

// فرآیند جداگانه صندوق خروجی را بررسی کرده و رویدادها را منتشر می‌کند
```

### [Two-Phase Commit](two-phase-commit.fa.md) (الگوی جایگزین)

**رابطه**: Saga جایگزینی برای 2PC برای تراکنش‌های توزیع‌شده است.

**مصالحه**: 2PC سازگاری قوی اما مسدود فراهم می‌کند؛ Saga سازگاری نهایی بدون مسدودسازی فراهم می‌کند.

**عامل تصمیم**: از 2PC زمانی استفاده کنید که سازگاری قوی لازم است و مسدودسازی قابل تحمل است؛ از Saga زمانی استفاده کنید که دسترس‌پذیری بالا لازم است و سازگاری نهایی قابل تحمل است.

**مراجعه کنید**: بخش ۹ برای مقایسه تفصیلی.

### قطع‌کننده مدار (مدیریت شکست)

**رابطه**: در پیاده‌سازی‌های saga برای مدیریت ملایم شکست‌های سرویس استفاده می‌شود.

**توضیح**: جلوگیری از شکست‌های آبشاری با توقف درخواست‌ها به سرویس‌های خراب.

**نحوه همکاری**:
- مرحله Saga سرویس را از طریق قطع‌کننده مدار فراخوانی می‌کند
- قطع‌کننده مدار شکست‌های مکرر را تشخیص می‌دهد
- مدار باز می‌شود، saga به جای تلاش مجدد جبران را راه‌اندازی می‌کند
- از انتظار بی‌پایان saga جلوگیری می‌کند

### ترکیب API (الگوی پرس‌وجو)

**رابطه**: برای پرس‌وجوی داده‌ها در سرویس‌ها در سیستم‌های مبتنی بر saga استفاده می‌شود.

**توضیح**: پیاده‌سازی پرس‌وجوها با فراخوانی چندین سرویس و ترکیب نتایج.

**نحوه همکاری**:
- Saga سازگاری داده‌ها را در بین سرویس‌ها حفظ می‌کند
- ترکیب API آن داده‌ها را پرس‌وجو می‌کند
- با هم راه‌حل کامل خواندن/نوشتن برای داده‌های توزیع‌شده فراهم می‌کنند

## ۱۴. ملاحظات طراحی

### چه زمانی از الگوی Saga استفاده کنیم

✓ **از Saga استفاده کنید زمانی که:**

1. **معماری میکروسرویس**
   - چندین سرویس با پایگاه‌های داده جداگانه دارید
   - سرویس‌ها نیاز به حفظ استقلال دارند
   - تراکنش‌های بین‌سرویسی لازم است

2. **الزامات دسترس‌پذیری بالا**
   - سیستم باید حتی در طول شکست‌های جزئی در دسترس بماند
   - عملیات مسدودکننده غیرقابل قبول است
   - نیاز به مدیریت ملایم پارتیشن‌های شبکه

3. **پایگاه‌های داده ناهمگن**
   - استفاده از ترکیب پایگاه‌های داده SQL و NoSQL
   - پایگاه‌های داده از تراکنش‌های توزیع‌شده (2PC) پشتیبانی نمی‌کنند
   - سرویس‌های مختلف از فناوری‌های پایگاه داده متفاوت استفاده می‌کنند

4. **تراکنش‌های طولانی‌مدت**
   - فرآیندهای کسب‌وکار دقایق یا ساعت‌ها طول می‌کشند
   - نمی‌توان قفل‌های پایگاه داده را برای مدت طولانی نگه داشت
   - نیاز به حفظ پاسخگویی سیستم

5. **سازگاری نهایی قابل قبول**
   - منطق کسب‌وکار می‌تواند ناسازگاری‌های موقت را تحمل کند
   - سازگاری نهایی مهم است
   - حالت‌های میانی برای کاربران قابل قبول است

### چه زمانی از الگوی Saga استفاده نکنیم

✗ **از Saga اجتناب کنید زمانی که:**

1. **سازگاری قوی لازم است**
   - سازگاری فوری حیاتی است
   - کسب‌وکار نمی‌تواند هیچ پنجره ناسازگاری را تحمل کند
   - مثال‌ها: تراکنش‌های مالی، موجودی بدون تحمل فروش بیش از حد

2. **سیستم تک پایگاه داده**
   - تمام داده‌ها در یک پایگاه داده
   - می‌توان از تراکنش‌های ACID محلی استفاده کرد
   - Saga پیچیدگی غیرضروری اضافه می‌کند

3. **عملیات ساده فقط‌خواندنی**
   - بدون تغییر داده
   - نیازی به هماهنگی تراکنش نیست
   - پرس‌وجوهای ساده در بین سرویس‌ها

4. **الزامات تأخیر پایین بلادرنگ**
   - زمان پاسخ زیرمیلی‌ثانیه‌ای لازم است
   - نمی‌توان سربار هماهنگی saga را تحمل کرد
   - مثال‌ها: معاملات با فرکانس بالا

5. **تیم فاقد تجربه سیستم‌های توزیع‌شده**
   - تیم تازه با میکروسرویس‌ها آشنا شده
   - فقدان تجربه با سازگاری نهایی
   - با الگوهای ساده‌تر شروع کنید

### عوامل تصمیم ارکستراسیون در مقابل کوریوگرافی

**ارکستراسیون را انتخاب کنید زمانی که:**
- Saga شامل سرویس‌های زیاد (بیش از ۵) است
- منطق شرطی پیچیده (جریان‌های اگر-آنگاه-در غیر اینصورت)
- منطق saga به‌طور مکرر تغییر می‌کند
- نیاز به نظارت متمرکز
- تیم تعریف‌های جریان کاری صریح را ترجیح می‌دهد

**کوریوگرافی را انتخاب کنید زمانی که:**
- Saga ساده با سرویس‌های کم (۲-۴)
- منطق کسب‌وکار پایدار
- سازمان فرهنگ رویداد‌محور قوی دارد
- حداکثر استقلال سرویس می‌خواهید
- سرویس‌ها از قبل از طریق رویدادها ارتباط برقرار می‌کنند

**ترکیبی را استفاده کنید زمانی که:**
- سیستم بزرگ با sagaهای متعدد
- برخی sagaها ساده (کوریوگرافی)، برخی پیچیده (ارکستراسیون)
- انعطاف‌پذیری در انتخاب به ازای هر saga می‌خواهید

### استراتژی‌های آزمایش

**۱. آزمایش واحد**
- مراحل فردی saga را به‌صورت مجزا آزمایش کنید
- وابستگی‌ها را شبیه‌سازی کنید
- مسیرهای موفقیت و شکست را آزمایش کنید

**۲. آزمایش یکپارچگی**
- جریان کامل saga را آزمایش کنید
- از جانشین‌های آزمایشی برای سرویس‌های خارجی استفاده کنید
- تأیید کنید تراکنش‌های جبرانی به‌درستی اجرا می‌شوند

**۳. آزمایش آشوب**
- به‌طور تصادفی در طول اجرای saga شکست تزریق کنید
- تأیید کنید saga شکست‌ها را به‌خوبی مدیریت می‌کند
- سناریوهای شکست جزئی را آزمایش کنید

**۴. آزمایش انتها به انتها**
- Saga را در محیط شبیه تولید آزمایش کنید
- از سرویس‌های واقعی استفاده کنید (نه شبیه‌سازی)
- تأیید کنید سازگاری نهایی حاصل می‌شود

**چک‌لیست آزمایش:**
- [ ] تمام مسیرهای موفقیت آزمایش شده
- [ ] تمام نقاط شکست با جبران آزمایش شده
- [ ] اجرای همزمان saga آزمایش شده
- [ ] بی‌توانی برای تمام عملیات تأیید شده
- [ ] مدیریت مهلت زمانی آزمایش شده
- [ ] شکست‌های تراکنش جبرانی آزمایش شده

### نظارت و مشاهده‌پذیری

**معیارهای کلیدی برای ردیابی:**

1. **نرخ تکمیل Saga**: درصد sagaهایی که با موفقیت تکمیل می‌شوند
2. **مدت Saga**: زمان از شروع تا تکمیل
3. **نرخ شکست مرحله**: نرخ شکست به ازای هر مرحله saga
4. **نرخ جبران**: چقدر اغلب جبران‌ها راه‌اندازی می‌شوند
5. **Sagaهای گیر کرده**: sagaهایی که در زمان مورد انتظار پیشرفت نکرده‌اند

**الزامات ثبت وقایع:**
- از شناسه‌های همبستگی برای تمام عملیات saga استفاده کنید
- تمام انتقال‌های وضعیت saga را ثبت کنید
- تمام تراکنش‌های جبرانی را ثبت کنید
- برچسب‌های زمانی برای تشخیص مهلت زمانی درج کنید

**هشداردهی:**
- هشدار در نرخ جبران بالا
- هشدار در sagaهای گیر کرده
- هشدار در شکست‌های تراکنش جبرانی

## ۱۵. پیامدهای طراحی سیستم مدرن

### تناسب با معماری بومی ابری

الگوی Saga به‌خوبی با اصول بومی ابری هم‌راستا است:

**۱. طراحی شده برای شکست**
- سرویس‌های ابری می‌توانند به‌طور غیرقابل پیش‌بینی شکست بخورند
- تراکنش‌های جبرانی Saga شکست‌ها را به‌خوبی مدیریت می‌کنند
- ماهیت غیرمسدود تاب‌آوری را بهبود می‌بخشد

**۲. قابل استقرار مستقل**
- هر سرویس در saga می‌تواند مستقلاً مستقر شود
- هماهنگی Saga نیاز به استقرار هماهنگ ندارد
- از تحویل مداوم پشتیبانی می‌کند

**۳. مقیاس‌پذیری**
- سرویس‌ها بر اساس بار مستقلاً مقیاس می‌شوند
- بدون قفل‌های سراسری که به گلوگاه تبدیل شوند
- کوریوگرافی مقیاس‌پذیری افقی را فعال می‌کند

### یکپارچگی با Kubernetes و Service Mesh

**مزایای Kubernetes:**
- **بررسی سلامت**: بررسی‌های سلامت Kubernetes به تشخیص سریع شکست مراحل saga کمک می‌کنند
- **کشف سرویس**: کشف سرویس پویا سرویس‌های saga را قادر می‌سازد یکدیگر را پیدا کنند
- **مدیریت منابع**: هر سرویس saga می‌تواند محدودیت‌های منابع داشته باشد

**Service Mesh (ایستیو، لینکرد):**
- **تلاش‌های مجدد**: تلاش‌های مجدد خودکار برای شکست‌های موقت
- **مهلت‌های زمانی**: سیاست‌های مهلت زمانی یکپارچه در مراحل saga
- **قطع مدار**: جلوگیری از شکست‌های آبشاری
- **مشاهده‌پذیری**: ردیابی توزیع‌شده در مراحل saga

**مثال پیکربندی ایستیو:**
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: payment-service
spec:
  hosts:
  - payment-service
  http:
  - timeout: 10s
    retries:
      attempts: 3
      perTryTimeout: 3s
    route:
    - destination:
        host: payment-service
```

### پلتفرم‌های جریان رویداد

پیاده‌سازی‌های مدرن saga اغلب از پلتفرم‌های جریان رویداد استفاده می‌کنند:

**آپاچی کافکا:**
- گزارش رویداد بادوام برای sagaهای مبتنی بر کوریوگرافی
- بازپخش رویداد برای اشکال‌زدایی و بازیابی
- پارتیشن‌بندی برای مقیاس‌پذیری
- تاپیک‌های فشرده‌شده برای وضعیت saga

**AWS EventBridge:**
- گذرگاه رویداد مدیریت‌شده برای رویدادهای saga
- رجیستری طرحواره برای اعتبارسنجی رویداد
- تلاش مجدد و DLQ داخلی
- یکپارچگی با سرویس‌های AWS

**مزایا:**
- تحویل قابل اعتماد رویداد (حداقل-یک‌بار)
- بازپخش رویداد برای آزمایش و اشکال‌زدایی
- دنباله حسابرسی اجرای saga
- جداسازی سرویس‌های saga

### الزامات مشاهده‌پذیری

پیاده‌سازی‌های مدرن saga نیاز به مشاهده‌پذیری جامع دارند:

**ردیابی توزیع‌شده (Jaeger، Zipkin):**
```
ردیابی: Saga ایجاد سفارش
  بازه: ایجاد سفارش (سرویس سفارش) - ۵۰ میلی‌ثانیه
  بازه: رزرو اعتبار (سرویس مشتری) - ۳۰ میلی‌ثانیه
  بازه: شارژ پرداخت (سرویس پرداخت) - ۲۰۰ میلی‌ثانیه
  بازه: ایجاد تیکت (سرویس آشپزخانه) - ۴۰ میلی‌ثانیه
  بازه: تأیید سفارش (سرویس سفارش) - ۲۰ میلی‌ثانیه
مجموع: ۳۴۰ میلی‌ثانیه
```

**مزایا:**
- تجسم جریان کامل saga
- شناسایی گلوگاه‌های عملکرد
- اشکال‌زدایی شکست‌ها با زمینه کامل
- محاسبه مدت saga

**معیارها (Prometheus، CloudWatch):**
- saga_duration_seconds (هیستوگرام)
- saga_completion_rate (گیج)
- saga_step_failures_total (شمارنده)
- saga_compensations_total (شمارنده)

**ثبت وقایع (ELK، CloudWatch Logs):**
- ثبت وقایع ساختاریافته با شناسه‌های همبستگی
- تجمیع متمرکز گزارش‌ها
- جستجو و فیلتر بر اساس شناسه saga
- هشدار بر الگوهای خطا

### بدون‌سرور و الگوی Saga

پلتفرم‌های بدون‌سرور ارکستراسیون saga مدیریت‌شده ارائه می‌دهند:

**AWS Step Functions:**
- طراح جریان کاری بصری
- تلاش مجدد خودکار و مدیریت خطا
- منطق جبران داخلی
- یکپارچگی با Lambda، ECS، SNS، SQS

**Azure Durable Functions:**
- تعریف جریان کاری مبتنی بر کد
- مدیریت وضعیت خودکار
- مدیریت خطای داخلی
- پشتیبانی از C# و JavaScript

**مزایا:**
- بدون مدیریت زیرساخت
- قیمت‌گذاری به ازای استفاده
- مقیاس‌پذیری خودکار
- پایداری داخلی

**مثال Saga با AWS Step Functions:**
```json
{
  "StartAt": "CreateOrder",
  "States": {
    "CreateOrder": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:CreateOrder",
      "Catch": [{
        "ErrorEquals": ["States.ALL"],
        "Next": "CancelOrder"
      }],
      "Next": "ReserveCredit"
    },
    "ReserveCredit": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:ReserveCredit",
      "Catch": [{
        "ErrorEquals": ["States.ALL"],
        "Next": "CancelOrder"
      }],
      "Next": "ChargePayment"
    },
    "CancelOrder": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:CancelOrder",
      "End": true
    }
  }
}
```

## ۱۶. نکات کلیدی

1. **Saga تراکنش‌های توزیع‌شده را بدون قفل‌های توزیع‌شده فعال می‌کند**: با شکستن تراکنش‌ها به مراحل محلی با تراکنش‌های جبرانی، sagaها اتمی بودن را در بین سرویس‌ها بدون ماهیت مسدودکننده 2PC فراهم می‌کنند.

2. **ارکستراسیون را برای sagaهای پیچیده و کوریوگرافی را برای ساده‌ها انتخاب کنید**: ارکستراسیون دید و کنترل بهتری برای sagaهای پیچیده چندمرحله‌ای فراهم می‌کند، در حالی که کوریوگرافی جداسازی بهتری برای sagaهای ساده ارائه می‌دهد.

3. **سازگاری نهایی مصالحه است**: Sagaها دسترس‌پذیری و مقیاس‌پذیری بالا فراهم می‌کنند اما فقط سازگاری نهایی را تضمین می‌کنند، نه سازگاری فوری. این آن‌ها را برای موارد استفاده‌ای که سازگاری قوی لازم است نامناسب می‌کند.

4. **تراکنش‌های جبرانی را با دقت طراحی کنید**: تراکنش‌های جبرانی باید بی‌توان، از نظر معنایی صحیح و قادر به مدیریت شکست‌های خود باشند. همه عملیات قابل جبران نیستند.

5. **فقدان ایزوله‌سازی نیاز به اقدامات متقابل دارد**: از آنجایی که sagaها ایزوله‌سازی ACID فراهم نمی‌کنند، از تکنیک‌هایی مانند قفل‌های معنایی، قفل خوش‌بینانه و به‌روزرسانی‌های جابه‌جایی‌پذیر برای جلوگیری از ناهنجاری‌های داده از sagaهای همزمان استفاده کنید.

**خلاصه معیارهای تصمیم:**

| عامل | Saga | Two-Phase Commit |
|--------|------|------------------|
| سازگاری | نهایی | فوری |
| دسترس‌پذیری | بالا | پایین‌تر |
| مقیاس‌پذیری | بالا | محدود |
| انواع پایگاه داده | هر نوعی | فقط با قابلیت 2PC |
| پیچیدگی | بالاتر | پایین‌تر |
| مورد استفاده | میکروسرویس‌ها | مونولیت‌ها، نیازهای سازگاری قوی |

## ۱۷. موضوعات مرتبط برای مطالعه

برای عمیق‌تر کردن درک خود از تراکنش‌های توزیع‌شده و الگوهای میکروسرویس، این موضوعات مرتبط را بررسی کنید:

### در این مخزن

- **[Two-Phase Commit](two-phase-commit.fa.md)**: درک الگوی جایگزین تراکنش توزیع‌شده و چه زمانی از 2PC در مقابل Saga استفاده کنیم

### الگوهای خارجی برای مطالعه

- **پایگاه داده به ازای هر سرویس**: الگوی میکروسرویس که sagaها را ضروری می‌کند
- **منبع‌یابی رویداد**: ذخیره وضعیت برنامه به عنوان دنباله رویدادها؛ اغلب با sagaها استفاده می‌شود
- **CQRS (جداسازی مسئولیت فرمان و پرس‌وجو)**: جداسازی مدل‌های خواندن/نوشتن، معمولاً با sagaها ترکیب می‌شود
- **صندوق خروجی تراکنشی**: انتشار قابل اعتماد رویدادها به عنوان بخشی از تراکنش‌های پایگاه داده
- **معماری رویداد‌محور**: سبک معماری گسترده‌تری که sagaهای مبتنی بر کوریوگرافی را فعال می‌کند
- **قطع‌کننده مدار**: الگوی مدیریت شکست استفاده‌شده در پیاده‌سازی‌های saga
- **ردیابی توزیع‌شده**: ضروری برای مشاهده‌پذیری در سیستم‌های مبتنی بر saga

### موضوعات پیشرفته

- **تراکنش‌های طولانی‌مدت**: نظریه پشت sagaها و مدیریت فرآیند کسب‌وکار
- **الگوهای سازگاری نهایی**: تکنیک‌هایی برای کار با سازگاری نهایی
- **طراحی تراکنش جبرانی**: بررسی عمیق طراحی جبران‌های مؤثر
- **استراتژی‌های ایزوله‌سازی Saga**: تکنیک‌های پیشرفته برای مدیریت sagaهای همزمان
- **موتورهای جریان کاری**: ابزارهایی مانند Temporal، Cadence، Conductor برای پیاده‌سازی sagaها

### مطالعه بیشتر

- microservices.io کریس ریچاردسون (مستندات جامع saga)
- بلاگ مارتین فاولر درباره الگوهای سازمانی
- کتاب "طراحی برنامه‌های داده‌محور" اثر مارتین کلپمن (فصل تراکنش‌های توزیع‌شده)
- مقاله اصلی Saga: "Sagas" اثر هکتور گارسیا-مولینا و کنت سالم (۱۹۸۷)

---

*این مستند بخشی از دفترچه طراحی سیستم است. برای سوالات، پیشنهادات یا مشارکت‌ها، لطفاً به README اصلی مخزن مراجعه کنید.*
