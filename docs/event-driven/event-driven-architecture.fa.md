# معماری رویداد محور (Event-Driven Architecture)

## 1. مقدمه

معماری رویداد محور (Event-Driven Architecture - EDA) یک الگوی طراحی نرم‌افزار است که در آن اجزای سیستم از طریق تولید و مصرف رویدادها با یکدیگر ارتباط برقرار می‌کنند. یک رویداد نشان‌دهنده یک تغییر مهم در وضعیت یا یک رخداد است که ممکن است بخش‌های دیگر سیستم به آن علاقه‌مند باشند. برخلاف الگوهای سنتی درخواست-پاسخ، EDA جداسازی느슨 و ارتباطات ناهمگام بین سرویس‌ها را ترویج می‌دهد.

### مفاهیم پایه

**Event (رویداد)**: یک رکورد تغییرناپذیر از چیزی که در سیستم اتفاق افتاده است. رویدادها حقایقی درباره گذشته هستند و نمی‌توان آن‌ها را تغییر داد.

```
┌─────────────────────────────────────────┐
│           مثال رویداد                   │
├─────────────────────────────────────────┤
│ Event Type: OrderPlaced                 │
│ Timestamp:  2025-01-15T10:30:00Z       │
│ Payload:                                │
│   - orderId: 12345                      │
│   - customerId: 789                     │
│   - total: 150.00                       │
│   - items: [...]                        │
└─────────────────────────────────────────┘
```

**Event Producer (تولیدکننده رویداد)**: یک کامپوننت که تغییرات وضعیت را شناسایی کرده و رویدادها را منتشر می‌کند. تولیدکنندگان از مصرف‌کنندگان جدا هستند و نمی‌دانند چه کسی رویدادهایشان را پردازش خواهد کرد.

**Event Consumer (مصرف‌کننده رویداد)**: یک کامپوننت که رویدادها را subscribe کرده و پردازش می‌کند. مصرف‌کنندگان با اجرای منطق کسب‌وکار، به‌روزرسانی وضعیت خود یا trigger کردن رویدادهای اضافی، به رویدادها واکنش نشان می‌دهند.

**Event Channel/Broker (کانال/کارگزار رویداد)**: زیرساختی که رویدادها را از تولیدکنندگان به مصرف‌کنندگان مسیریابی می‌کند. این می‌تواند یک message queue، event stream یا service bus باشد.

### جریان پایه رویداد

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│   Producer   │         │    Event     │         │   Consumer   │
│   Service    │────────▶│    Broker    │────────▶│   Service    │
│              │ publish │              │subscribe│              │
└──────────────┘         └──────────────┘         └──────────────┘
                                │
                                │ publish
                                ▼
                         ┌──────────────┐
                         │   Another    │
                         │   Consumer   │
                         └──────────────┘
```

## 2. چهار الگوی رویداد محور

Martin Fowler چهار الگوی اساسی در سیستم‌های رویداد محور را شناسایی می‌کند. هر الگو موارد استفاده متفاوتی دارد و ویژگی‌های مشخصی دارد.

### 2.1 Event Notification (اطلاع‌رسانی رویداد)

ساده‌ترین شکل EDA. یک سرویس یک رویداد ارسال می‌کند تا دیگران را مطلع کند که چیزی اتفاق افتاده، با حداقل اطلاعات. مصرف‌کنندگانی که به جزئیات بیشتر نیاز دارند باید به سیستم منبع callback کنند.

**ویژگی‌ها**:
- رویدادها داده‌های حداقلی دارند (معمولاً فقط IDها)
- جداسازی را ترویج می‌دهد - تولیدکننده نمی‌داند مصرف‌کنندگان چه کار می‌کنند
- مصرف‌کنندگان برای جزئیات کامل queries اضافی انجام می‌دهند
- ترافیک شبکه کم برای توزیع رویداد
- پیاده‌سازی ساده

**جریان مثال**:

```
Customer Service              Event Broker              Email Service
      │                            │                          │
      │ 1. User registers          │                          │
      │────────────────────────────┤                          │
      │                            │                          │
      │ 2. Publish:                │                          │
      │    UserRegistered          │                          │
      │    { userId: 123 }         │                          │
      ├───────────────────────────▶│                          │
      │                            │                          │
      │                            │ 3. Notify subscriber     │
      │                            ├─────────────────────────▶│
      │                            │                          │
      │                            │   4. GET /users/123      │
      │◀──────────────────────────────────────────────────────┤
      │                            │                          │
      │ 5. Return full user data   │                          │
      ├──────────────────────────────────────────────────────▶│
      │                            │                          │
      │                            │   6. Send welcome email  │
```

**زمان استفاده**:
- اطلاع‌رسانی چندین سرویس از تغییرات وضعیت
- زمانی که مصرف‌کنندگان به زیرمجموعه‌های مختلف داده نیاز دارند
- کوچک نگه داشتن payload رویداد
- زمانی که داده‌های منبع به طور مکرر تغییر می‌کنند (جلوگیری از داده قدیمی)

### 2.2 Event-Carried State Transfer (انتقال وضعیت حامل رویداد)

رویدادها اطلاعات وضعیت کامل را حمل می‌کنند و نیاز به callback توسط مصرف‌کنندگان را از بین می‌برند. این امر استقلال بیشتری برای سرویس‌های مصرف‌کننده فراهم می‌کند اما تکرار داده را افزایش می‌دهد.

**ویژگی‌ها**:
- رویدادها داده‌های وضعیت کامل یا قابل توجه را شامل می‌شوند
- مصرف‌کنندگان می‌توانند بدون callback عمل کنند
- coupling و network callها را کاهش می‌دهد
- تکرار داده در سرویس‌ها را افزایش می‌دهد
- خطر داده قدیمی در cacheهای مصرف‌کننده

**جریان مثال**:

```
Order Service                 Event Broker              Analytics Service
     │                             │                           │
     │ 1. Order placed             │                           │
     │─────────────────────────────┤                           │
     │                             │                           │
     │ 2. Publish:                 │                           │
     │    OrderPlaced {            │                           │
     │      orderId: 456,          │                           │
     │      customerId: 789,       │                           │
     │      items: [...],          │                           │
     │      total: 150.00,         │                           │
     │      shippingAddress: {...},│                           │
     │      paymentMethod: "VISA"  │                           │
     │    }                        │                           │
     ├────────────────────────────▶│                           │
     │                             │                           │
     │                             │ 3. Deliver full event     │
     │                             ├──────────────────────────▶│
     │                             │                           │
     │                             │   4. Store & analyze      │
     │                             │      (no callback needed) │
```

**زمان استفاده**:
- مصرف‌کنندگان به اکثر داده‌ها نیاز دارند
- کاهش وابستگی‌ها بین سرویس‌ها
- ساخت microserviceهای مستقل
- زمانی که سازگاری نهایی قابل قبول است
- ایجاد materialized viewها یا read modelها (لینک به [CQRS](../data-patterns/cqrs.fa.md))

### 2.3 Event Sourcing (منبع‌یابی رویداد)

تغییرات وضعیت به‌عنوان یک دنباله از رویدادها ذخیره می‌شوند نه فقط وضعیت فعلی. وضعیت فعلی با replay کردن رویدادها از ابتدا به دست می‌آید. این پایه سیستم‌های event-sourced است.

**ویژگی‌ها**:
- رویدادها منبع حقیقت هستند
- وضعیت با replay کردن رویدادها بازسازی می‌شود
- audit trail کامل به صورت طراحی
- امکان queryهای زمانی
- پیاده‌سازی پیچیده‌تر
- نیاز به استراتژی versioning رویداد

**ساختار Event Store**:

```
Event Store (Append-Only Log)
┌──────────────────────────────────────────────────────────────────┐
│ Stream: Account-123                                              │
├──────────────────────────────────────────────────────────────────┤
│ [1] AccountCreated      { balance: 0 }                           │
│ [2] MoneyDeposited      { amount: 1000 }                         │
│ [3] MoneyWithdrawn      { amount: 200 }                          │
│ [4] MoneyDeposited      { amount: 500 }                          │
│ [5] MoneyWithdrawn      { amount: 300 }                          │
└──────────────────────────────────────────────────────────────────┘
                              │
                              │ Replay all events
                              ▼
                    Current State: balance = 1000
```

**بازسازی وضعیت**:

```
فرآیند Replay رویداد

Initial State:     balance = 0

Apply Event [1]:   AccountCreated      → balance = 0
Apply Event [2]:   MoneyDeposited      → balance = 0 + 1000 = 1000
Apply Event [3]:   MoneyWithdrawn      → balance = 1000 - 200 = 800
Apply Event [4]:   MoneyDeposited      → balance = 800 + 500 = 1300
Apply Event [5]:   MoneyWithdrawn      → balance = 1300 - 300 = 1000

Final State:       balance = 1000
```

**Snapshotها برای کارایی**:

```
Event Store با Snapshotها
┌──────────────────────────────────────────────────────────────────┐
│ Stream: Account-123                                              │
├──────────────────────────────────────────────────────────────────┤
│ [1] AccountCreated      { balance: 0 }                           │
│ [2] MoneyDeposited      { amount: 1000 }                         │
│ ...                                                              │
│ [100] Snapshot          { balance: 5000, version: 100 }         │
│ [101] MoneyDeposited    { amount: 200 }                          │
│ [102] MoneyWithdrawn    { amount: 300 }                          │
│ ...                                                              │
│ [200] Snapshot          { balance: 7500, version: 200 }         │
│ [201] MoneyDeposited    { amount: 100 }                          │
└──────────────────────────────────────────────────────────────────┘

برای بازسازی وضعیت فعلی:
1. بارگذاری آخرین snapshot (نسخه 200، موجودی = 7500)
2. Replay رویدادهای 201 تا انتها
3. بسیار سریع‌تر از replay کردن همه 200+ رویداد
```

**زمان استفاده**:
- audit trail کامل حیاتی است (مالی، بهداشت و درمان)
- نیاز به query کردن وضعیت‌های تاریخی
- نیازهای انطباق قانونی
- دامنه‌های پیچیده با انتقالات وضعیت غنی
- ساخت سیستم‌های گزارش‌دهی زمانی

### 2.4 CQRS (Command Query Responsibility Segregation)

CQRS عملیات خواندن و نوشتن را به مدل‌های مختلف تفکیک می‌کند. Commandها وضعیت را از طریق مدل نوشتن به‌روزرسانی می‌کنند، در حالی که queryها داده را از مدل‌های خواندن بهینه‌شده دریافت می‌کنند. این الگو اغلب با Event Sourcing ترکیب می‌شود.

**معماری پایه CQRS**:

```
                    Commands                     Events
┌──────────┐      (Updates)      ┌────────┐              ┌──────────┐
│          │─────────────────────▶│ Write  │─────────────▶│  Event   │
│  Client  │                      │ Model  │   Publish    │  Broker  │
│          │◀─────────────────────│        │              └──────────┘
└──────────┘      Ack             └────────┘                    │
     │                                                           │
     │                                                           │ Subscribe
     │            Queries                                        ▼
     │           (Reads)                                  ┌──────────┐
     └─────────────────────▶┌────────┐                   │  Event   │
                             │ Read   │◀──────────────────│ Handler  │
                             │ Model  │    Update Read    └──────────┘
                             └────────┘    Models
```

برای راهنمای جامع CQRS، به [الگوی CQRS](../data-patterns/cqrs.fa.md) مراجعه کنید.

**نکات کلیدی**:
- مدل نوشتن برای سازگاری و قوانین کسب‌وکار بهینه‌شده
- مدل‌های خواندن برای queryها بهینه‌شده (denormalized، cached)
- مدل‌های خواندن eventually consistent
- خواندن و نوشتن به صورت مستقل مقیاس‌پذیر

## 3. Event Notification در مقابل Event-Carried State Transfer

درک زمان استفاده از هر الگو برای طراحی موثر EDA حیاتی است.

| جنبه | Event Notification | Event-Carried State Transfer |
|------|-------------------|------------------------------|
| **اندازه رویداد** | کوچک (فقط IDها) | بزرگ (وضعیت کامل) |
| **Coupling** | متوسط (مصرف‌کنندگان callback می‌کنند) | کم (مصرف‌کنندگان مستقل) |
| **Network Calls** | بیشتر (callbackها لازم) | کمتر (خودکفا) |
| **تازگی داده** | همیشه تازه | احتمالاً قدیمی |
| **تکرار داده** | حداقلی | قابل توجه |
| **استقلال مصرف‌کننده** | کم | زیاد |
| **پیچیدگی پیاده‌سازی** | ساده | متوسط |
| **بهترین برای** | اطلاع‌رسانی‌ها، هشدارها | ساخت viewهای محلی، caching |
| **استفاده از پهنای باند** | کم برای رویدادها، زیاد برای callbackها | زیاد برای رویدادها، کم برای callbackها |
| **انعطاف‌پذیری** | بستگی به در دسترس بودن منبع | زیاد (آفلاین کار می‌کند) |

**ماتریس تصمیم‌گیری**:

```
استفاده از Event Notification زمانی که:
├─ رویدادها مکرر هستند
├─ داده منبع اغلب تغییر می‌کند
├─ مصرف‌کنندگان به زیرمجموعه‌های مختلف داده نیاز دارند
├─ تازگی داده حیاتی است
└─ به حداقل رساندن تکرار داده مهم است

استفاده از Event-Carried State Transfer زمانی که:
├─ مصرف‌کنندگان به اکثر داده‌ها نیاز دارند
├─ کاهش وابستگی‌های سرویس اولویت است
├─ ساخت microserviceهای با استقلال
├─ سازگاری نهایی قابل قبول است
└─ ایجاد replicaهای خواندن یا projectionها
```

## 4. بررسی عمیق Event Sourcing

Event Sourcing یک الگوی پیچیده است که اساساً نحوه تفکر ما درباره مدیریت وضعیت را تغییر می‌دهد.

### 4.1 طراحی Event Store

یک event store یک پایگاه داده append-only است که برای نوشتن رویدادها و خواندن event streamها بهینه‌شده است.

**ویژگی‌های کلیدی**:
- Append-only (بدون updateها یا deleteها)
- رویدادها به ترتیب ذخیره می‌شوند
- Index شده با aggregate ID و version
- پشتیبانی از خواندن stream و global
- کنترل همزمانی خوش‌بینانه

**شمای Event Store**:

```
جدول Events
┌────────────┬──────────────┬─────────┬───────────────┬───────────┬──────────────┐
│ Stream ID  │   Version    │  Type   │   Timestamp   │  Payload  │   Metadata   │
├────────────┼──────────────┼─────────┼───────────────┼───────────┼──────────────┤
│ Order-123  │      1       │ Created │ 2025-01-15... │  {...}    │   {...}      │
│ Order-123  │      2       │ Updated │ 2025-01-15... │  {...}    │   {...}      │
│ Order-123  │      3       │ Shipped │ 2025-01-16... │  {...}    │   {...}      │
│ Order-456  │      1       │ Created │ 2025-01-16... │  {...}    │   {...}      │
└────────────┴──────────────┴─────────┴───────────────┴───────────┴──────────────┘

Indexها:
- PRIMARY: (Stream ID, Version)
- INDEX: Timestamp (برای ترتیب global)
- INDEX: Type (برای queryهای نوع رویداد)
```

### 4.2 الگوهای Aggregate

```
┌─────────────────────────────────────────────────────────────┐
│                    Order Aggregate                          │
├─────────────────────────────────────────────────────────────┤
│  State:                                                     │
│    - orderId                                                │
│    - status: PENDING | PAID | SHIPPED | DELIVERED          │
│    - items: [...]                                           │
│    - totalAmount                                            │
│                                                             │
│  Commands:                                                  │
│    - createOrder()      → OrderCreated event                │
│    - payOrder()         → OrderPaid event                   │
│    - shipOrder()        → OrderShipped event                │
│    - deliverOrder()     → OrderDelivered event              │
│                                                             │
│  Business Rules:                                            │
│    - فقط می‌توان سفارش‌های pending را پرداخت کرد            │
│    - فقط می‌توان سفارش‌های پرداخت‌شده را ارسال کرد          │
│    - نمی‌توان سفارش‌های ارسال‌شده را لغو کرد                │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 مدیریت Commandها

```
جریان پردازش Command

Client                 Command Handler           Event Store
  │                           │                        │
  │  1. PayOrder(123)         │                        │
  ├──────────────────────────▶│                        │
  │                           │                        │
  │                           │ 2. Load events         │
  │                           │    for Order-123       │
  │                           ├───────────────────────▶│
  │                           │                        │
  │                           │ 3. Return events       │
  │                           │    [Created, ...]      │
  │                           │◀───────────────────────┤
  │                           │                        │
  │                           │ 4. Replay events       │
  │                           │    to rebuild state    │
  │                           │                        │
  │                           │ 5. Execute command     │
  │                           │    (business logic)    │
  │                           │                        │
  │                           │ 6. Generate new event  │
  │                           │    OrderPaid           │
  │                           │                        │
  │                           │ 7. Append event        │
  │                           │    (with version check)│
  │                           ├───────────────────────▶│
  │                           │                        │
  │                           │ 8. Success             │
  │                           │◀───────────────────────┤
  │                           │                        │
  │ 9. Acknowledge            │                        │
  │◀──────────────────────────┤                        │
```

### 4.4 Projectionها و Read Modelها

رویدادها replay می‌شوند تا مدل‌های خواندن مختلف بهینه‌شده برای queryها ساخته شوند.

```
Event Store                   Projection Handler           Read Database
    │                               │                            │
    │ OrderCreated                  │                            │
    ├──────────────────────────────▶│                            │
    │                               │ Create order record        │
    │                               ├───────────────────────────▶│
    │                               │                            │
    │ OrderPaid                     │                            │
    ├──────────────────────────────▶│                            │
    │                               │ Update status = PAID       │
    │                               ├───────────────────────────▶│
    │                               │                            │
    │ OrderShipped                  │                            │
    ├──────────────────────────────▶│                            │
    │                               │ Update status = SHIPPED    │
    │                               ├───────────────────────────▶│
```

**Projectionهای متعدد**:

```
                        Event Stream
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                ▼                ▼
    ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
    │   Current    │  │   Analytics  │  │    Audit     │
    │    Orders    │  │     View     │  │     Log      │
    │   (SQL DB)   │  │  (Elastic)   │  │  (Archive)   │
    └──────────────┘  └──────────────┘  └──────────────┘
```

### 4.5 Queryهای زمانی

یکی از قدرتمندترین ویژگی‌های event sourcing، query کردن وضعیت در هر نقطه از زمان است.

```
Query: "موجودی حساب در 2025-01-10 چقدر بود؟"

Event Store: Account-123
[1] 2025-01-01  AccountCreated    { balance: 0 }
[2] 2025-01-05  MoneyDeposited    { amount: 1000 }
[3] 2025-01-08  MoneyWithdrawn    { amount: 200 }
[4] 2025-01-10  MoneyDeposited    { amount: 500 }        ← اینجا متوقف شو
[5] 2025-01-12  MoneyWithdrawn    { amount: 300 }        ← آینده را نادیده بگیر
[6] 2025-01-15  MoneyDeposited    { amount: 100 }        ← آینده را نادیده بگیر

Replay رویدادهای 1-4:
0 → +1000 → -200 → +500 = 1300

پاسخ: موجودی در 2025-01-10 برابر 1300 بود
```

### 4.6 Versioning رویداد

با تکامل سیستم‌ها، schemaهای رویداد تغییر می‌کنند. این را با دقت مدیریت کنید.

**استراتژی‌های Versioning**:

```
استراتژی 1: فیلد Version
{
  "eventType": "OrderCreated",
  "version": 2,
  "data": {
    "orderId": "123",
    "items": [...],
    "shippingAddress": {...}  // اضافه شده در v2
  }
}

استراتژی 2: انواع رویداد جداگانه
OrderCreatedV1
OrderCreatedV2

استراتژی 3: Upcasting
خواندن رویداد قدیمی → تبدیل به schema فعلی → پردازش
```

## 5. تضمین‌های تحویل رویداد

درک semanticهای تحویل برای ساخت سیستم‌های رویداد محور قابل اعتماد حیاتی است.

### 5.1 تحویل At-Most-Once

رویدادها صفر یا یک بار تحویل داده می‌شوند. ممکن است گم شوند اما هرگز تکراری نمی‌شوند.

```
Producer              Broker              Consumer
   │                    │                    │
   │ 1. Send Event      │                    │
   ├───────────────────▶│                    │
   │                    │ 2. Deliver         │
   │                    ├───────────────────▶│
   │                    │                    │ 3. Process
   │                    │                    │    (Crash!)
   │                    │                    │
   │                    │ 4. Event lost      │
```

**ویژگی‌ها**:
- کمترین تأخیر و overhead
- خطر از دست رفتن داده
- بدون پردازش تکراری

**موارد استفاده**:
- Metricsها و نظارت
- اطلاع‌رسانی‌های غیرحیاتی
- سناریوهای throughput بالا که از دست رفتن گاه‌به‌گاه قابل قبول است

### 5.2 تحویل At-Least-Once

رویدادها یک یا چند بار تحویل داده می‌شوند. ممکن است تکراری شوند اما هرگز گم نمی‌شوند.

```
Producer              Broker              Consumer
   │                    │                    │
   │ 1. Send Event      │                    │
   ├───────────────────▶│                    │
   │                    │ 2. Deliver         │
   │                    ├───────────────────▶│
   │                    │                    │ 3. Process
   │                    │                    │    (Crash before ACK!)
   │                    │                    │
   │                    │ 4. Redeliver       │
   │                    │    (Broker timeout)│
   │                    ├───────────────────▶│
   │                    │                    │ 5. Process again
   │                    │                    │    (Duplicate!)
   │                    │ 6. ACK             │
   │                    │◀───────────────────┤
```

**ویژگی‌ها**:
- بدون از دست رفتن داده
- احتمال تکراری
- نیاز به مصرف‌کنندگان idempotent

**موارد استفاده**:
- اکثر رویدادهای کسب‌وکار
- تراکنش‌های مالی (با idempotency)
- پردازش سفارش

**پیاده‌سازی Idempotency**:

```
الگوی مصرف‌کننده Idempotent

┌─────────────────────────────────────────┐
│  Event: OrderCreated { orderId: 123 }   │
└─────────────────────────────────────────┘
                  │
                  ▼
          ┌──────────────┐
          │   Consumer   │
          └──────────────┘
                  │
                  │ 1. بررسی جدول پردازش‌شده
                  ▼
    ┌───────────────────────────┐
    │ آیا 123 پردازش شده؟      │
    └───────────────────────────┘
           │              │
           │ خیر          │ بله
           ▼              ▼
    ┌──────────┐    ┌──────────┐
    │ Process  │    │  Skip    │
    │  Event   │    │  (Safe)  │
    └──────────┘    └──────────┘
           │
           │ 2. ذخیره ID رویداد
           ▼
    ┌──────────────────┐
    │ Processed Events │
    │  - 123           │
    └──────────────────┘
```

### 5.3 تحویل Exactly-Once

رویدادها دقیقاً یک بار تحویل داده می‌شوند. بدون از دست رفتن، بدون تکرار.

**نکته**: exactly-once واقعی به طور تئوری در سیستم‌های توزیع‌شده به دلیل partitionهای شبکه غیرممکن است. آنچه واقعاً به دست می‌آوریم "effectively once" یا "exactly-once processing semantics" است.

**رویکردها**:

```
رویکرد 1: الگوی Transactional Outbox

Application DB              Message Broker
┌────────────────┐          ┌────────────┐
│ Business Data  │          │            │
│                │          │            │
│ Outbox Table   │          │            │
│  - event_id    │          │            │
│  - payload     │          │            │
│  - published   │          │            │
└────────────────┘          └────────────┘
        │                          ▲
        │ 1. درج هر دو             │
        │    در transaction        │ 3. انتشار و علامت‌گذاری
        │                          │
        │ 2. Committed؟            │
        └──────────────────────────┘

رویکرد 2: Idempotent Producer + Idempotent Consumer
- تولیدکننده ارسال‌ها را deduplicate می‌کند
- مصرف‌کننده پردازش را deduplicate می‌کند
- با هم semanticهای exactly-once را به دست می‌آورند
```

**مقایسه**:

| تضمین | تأخیر | پیچیدگی | از دست رفتن داده | تکرار | مورد استفاده |
|--------|-------|---------|------------------|-------|---------------|
| At-Most-Once | کم | ساده | ممکن | خیر | Metricsها، لاگ‌ها |
| At-Least-Once | متوسط | متوسط | خیر | ممکن | اکثر رویدادها |
| Exactly-Once | زیاد | پیچیده | خیر | خیر | تراکنش‌های حیاتی |

## 6. Message Brokerها در مقابل Event Streamها

دو انتخاب اصلی زیرساخت برای EDA. برای مقایسه دقیق، به [RabbitMQ در مقابل Kafka](../messaging/rabbitmq-vs-kafka.fa.md) مراجعه کنید.

### 6.1 Message Brokerها (مثلاً RabbitMQ، ActiveMQ)

**معماری**:

```
┌──────────┐         ┌─────────────┐         ┌──────────┐
│ Producer │────────▶│   Exchange  │────────▶│  Queue   │
└──────────┘         └─────────────┘         └──────────┘
                            │                      │
                            │                      │
                            ▼                      ▼
                     ┌─────────────┐         ┌──────────┐
                     │   Queue     │         │ Consumer │
                     └─────────────┘         └──────────┘
                            │
                            ▼
                     ┌──────────┐
                     │ Consumer │
                     └──────────┘
```

**ویژگی‌ها**:
- پیام‌ها بعد از مصرف حذف می‌شوند
- تحویل push-based
- مسیریابی پیچیده (topicها، exchangeها)
- Middleware متمرکز بر پیام
- semanticهای سنتی queue

### 6.2 Event Streamها (مثلاً Apache Kafka، AWS Kinesis)

**معماری**:

```
Topic: OrderEvents
┌─────────────────────────────────────────────────────┐
│ Partition 0: [e1][e2][e3][e4][e5][e6][e7]          │
│ Partition 1: [e8][e9][e10][e11][e12]               │
│ Partition 2: [e13][e14][e15][e16][e17][e18]        │
└─────────────────────────────────────────────────────┘
                    │           │
        ┌───────────┘           └───────────┐
        ▼                                    ▼
┌──────────────┐                     ┌──────────────┐
│  Consumer A  │                     │  Consumer B  │
│  Offset: 5   │                     │  Offset: 3   │
└──────────────┘                     └──────────────┘
```

**ویژگی‌ها**:
- رویدادها برای دوره پیکربندی‌شده حفظ می‌شوند
- مصرف pull-based
- ترتیب در partitionها
- مصرف‌کنندگان متعدد می‌توانند رویدادها را replay کنند
- ذخیره‌سازی مبتنی بر log

**تفاوت‌های کلیدی**:

| جنبه | Message Broker | Event Stream |
|------|----------------|--------------|
| **ذخیره‌سازی** | موقت (بعد از مصرف حذف می‌شود) | دائمی (retention قابل تنظیم) |
| **مصرف** | Push-based | Pull-based |
| **Replay** | پشتیبانی نمی‌شود | پشتیبانی می‌شود |
| **ترتیب** | سطح Queue | سطح Partition |
| **Throughput** | متوسط | بسیار زیاد |
| **مورد استفاده** | توزیع Task، RPC | Event sourcing، streaming |

## 7. Choreography در مقابل Orchestration

دو الگو برای هماهنگی فرآیندهای چند مرحله‌ای. ارتباط نزدیک با [الگوی Saga](../distributed-transactions/saga.fa.md).

### 7.1 Choreography

سرویس‌ها بدون هماهنگی مرکزی به رویدادها واکنش نشان می‌دهند. هر سرویس می‌داند زمانی که رویدادها رخ می‌دهند چه کاری انجام دهد.

```
Choreography رویداد محور (Saga)

Order Service         Payment Service      Inventory Service     Shipping Service
     │                      │                     │                    │
     │ 1. OrderCreated      │                     │                    │
     ├─────────────────────▶│                     │                    │
     │                      │                     │                    │
     │                      │ 2. PaymentProcessed │                    │
     │                      ├────────────────────▶│                    │
     │                      │                     │                    │
     │                      │                     │ 3. InventoryReserved
     │                      │                     ├────────────────────▶│
     │                      │                     │                    │
     │                      │                     │  4. ShippingScheduled
     │◀──────────────────────────────────────────────────────────────┤
     │ 5. OrderConfirmed    │                     │                    │
```

**مزایا**:
- جداسازی느슨
- بدون نقطه شکست واحد
- سرویس‌های قابل استقرار مستقل
- تناسب طبیعی با سیستم‌های رویداد محور

**معایب**:
- درک جریان end-to-end سخت‌تر
- ردیابی وضعیت saga دشوار
- بدون نقطه نظارت مرکزی
- مدیریت خطای پیچیده

### 7.2 Orchestration

یک orchestrator مرکزی فرآیند را هدایت می‌کند و سرویس‌ها را به ترتیب فراخوانی می‌کند.

```
Saga هماهنگ‌شده

                      Order Orchestrator
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
  ┌────────────┐      ┌────────────┐     ┌────────────┐
  │  Payment   │      │ Inventory  │     │  Shipping  │
  │  Service   │      │  Service   │     │  Service   │
  └────────────┘      └────────────┘     └────────────┘

جریان:
1. Orchestrator → Payment Service: پردازش پرداخت
2. Orchestrator → Inventory Service: رزرو اقلام
3. Orchestrator → Shipping Service: زمان‌بندی ارسال
4. Orchestrator → Order Service: علامت‌گذاری به عنوان کامل
```

**مزایا**:
- تعریف واضح فرآیند
- نظارت متمرکز
- درک آسان‌تر
- مدیریت خطای صریح

**معایب**:
- Orchestrator نقطه شکست واحد است
- coupling تنگ‌تر
- Orchestrator می‌تواند پیچیده شود

**زمان انتخاب**:

```
Choreography را انتخاب کنید زمانی که:
├─ سرویس‌ها بسیار مستقل
├─ فرآیند ساده و خطی است
├─ جداسازی느슨 اولویت است
└─ ساخت اکوسیستم microservices

Orchestration را انتخاب کنید زمانی که:
├─ فرآیند کسب‌وکار پیچیده
├─ نیاز به دید مرکزی
├─ مدیریت خطای صریح لازم است
└─ تضمین‌های transactional لازم است
```

برای الگوهای پیاده‌سازی دقیق، به [الگوی Saga](../distributed-transactions/saga.fa.md) مراجعه کنید.

## 8. معاوضه‌ها (Trade-offs)

### 8.1 مزایای معماری رویداد محور

**1. جداسازی느슨 (Loose Coupling)**

سرویس‌ها نیازی به دانستن یکدیگر ندارند. تولیدکنندگان و مصرف‌کنندگان مستقل هستند.

```
Coupling سنتی:
Order Service ──calls──▶ Inventory Service
             ──calls──▶ Email Service
             ──calls──▶ Analytics Service

جداسازی رویداد محور:
Order Service ──publishes──▶ Event Broker
                                  │
                    ┌─────────────┼─────────────┐
                    ▼             ▼             ▼
              Inventory       Email       Analytics
               Service       Service       Service
```

**2. مقیاس‌پذیری (Scalability)**

کامپوننت‌ها به صورت مستقل مقیاس می‌شوند. Event brokerها buffering بار را مدیریت می‌کنند.

**3. قابلیت گسترش (Extensibility)**

اضافه کردن مصرف‌کنندگان جدید بدون تغییر تولیدکنندگان.

```
سیستم اصلی:
Producer ──▶ Broker ──▶ Consumer A
                   └───▶ Consumer B

اضافه کردن ویژگی جدید (بدون تغییر در producer):
Producer ──▶ Broker ──▶ Consumer A
                   ├───▶ Consumer B
                   └───▶ Consumer C (جدید!)
```

**4. انعطاف‌پذیری (Resilience)**

شکست‌های موقت cascade نمی‌شوند. پردازش ناهمگام شکست‌ها را جدا می‌کند.

**5. Audit Trail**

لاگ‌های رویداد تاریخچه کامل تغییرات سیستم را فراهم می‌کنند (به ویژه با Event Sourcing).

**6. پردازش Real-time**

رویدادها بلافاصله به مصرف‌کنندگان علاقه‌مند جریان می‌یابند و واکنش‌های real-time را ممکن می‌سازند.

**7. انعطاف (Flexibility)**

رویدادهای یکسان می‌توانند موارد استفاده متعدد را پشتیبانی کنند: analytics، اطلاع‌رسانی‌ها، caching و غیره.

### 8.2 معایب و چالش‌ها

**1. پیچیدگی (Complexity)**

بخش‌های متحرک بیشتر: event brokerها، schemaها، مصرف‌کنندگان، مدیریت خطا.

```
سنتی:
Client → Service → Database
(3 کامپوننت)

رویداد محور:
Client → Service → Event Broker → Consumer → Database
       → Event Store → Projection Builder → Read DB
(8+ کامپوننت)
```

**2. سازگاری نهایی (Eventual Consistency)**

مرتبط با [قضیه CAP](../fundamentals/cap-theorem.fa.md). رویدادها در طول زمان propagate می‌شوند و ناسازگاری‌های موقت ایجاد می‌کنند.

```
زمان: T0
Order Service: وضعیت سفارش = PAID
Email Service: هنوز رکوردی نیست (رویداد در حال انتقال)

زمان: T1 (50ms بعد)
Order Service: وضعیت سفارش = PAID
Email Service: وضعیت سفارش = PAID (رویداد پردازش شده)
```

**3. دشواری دیباگ (Debugging Difficulty)**

ردیابی درخواست‌ها در مرزهای ناهمگام چالش‌برانگیز است.

**4. تکامل Schema رویداد**

تغییر ساختارهای رویداد نیاز به versioning و سازگاری به عقب دارد.

**5. ترتیب رویداد (Event Ordering)**

تضمین ترتیب global گران است. معمولاً فقط ترتیب سطح partition.

**6. رویدادهای تکراری**

تحویل at-least-once نیاز به مصرف‌کنندگان idempotent دارد.

**7. سربار عملیاتی**

مدیریت event brokerها، نظارت بر مصرف‌کنندگان، مدیریت dead-letter queueها.

**8. پیچیدگی تست**

تست ناهمگام سخت‌تر از تست همگام است.

### 8.3 خلاصه معاوضه‌ها

| جنبه | سنتی | رویداد محور |
|------|------|-------------|
| **Coupling** | تنگ |느슨 |
| **Consistency** | قوی | نهایی |
| **Scalability** | محدود | زیاد |
| **Complexity** | کم | زیاد |
| **Debugging** | آسان‌تر | سخت‌تر |
| **Latency** | قابل پیش‌بینی | متغیر |
| **Audit Trail** | دستی | Built-in |
| **Failure Isolation** | ضعیف | خوب |
| **Testing** | مستقیم | پیچیده |

## 9. زمان استفاده / زمان اجتناب

### 9.1 از معماری رویداد محور زمانی استفاده کنید که

**1. ساخت Microservices**

EDA به طور طبیعی از استقلال و جداسازی느슨 [Microservices](../architecture/microservices.fa.md) پشتیبانی می‌کند.

**2. پردازش Real-time**

ردیابی فعالیت کاربر، تشخیص fraud، موتورهای توصیه.

**3. یکپارچه‌سازی سیستم**

اتصال چندین سیستم بدون coupling تنگ.

**4. نیازهای Audit**

سیستم‌های مالی، بهداشت و درمان، حوزه‌های پر از compliance.

**5. گردش‌کارهای ناهمگام**

پردازش سفارش، jobهای batch، فرآیندهای طولانی.

**6. مزایای Event Sourcing**

queryهای زمانی، تاریخچه کامل، وضعیت قابل بازتولید.

**7. نیازهای مقیاس**

throughput بالا، مقیاس‌پذیری مستقل کامپوننت‌ها.

**8. مصرف‌کنندگان Downstream متعدد**

داده‌های یکسان مورد نیاز analytics، اطلاع‌رسانی‌ها، caching و غیره.

### 9.2 از معماری رویداد محور زمانی اجتناب کنید که

**1. برنامه‌های CRUD ساده**

درخواست-پاسخ سنتی ساده‌تر و کافی است.

**2. سازگاری قوی لازم است**

اگر نمی‌توانید سازگاری نهایی را تحمل کنید، EDA پیچیدگی اضافه می‌کند. برای تراکنش‌های توزیع‌شده [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) را در نظر بگیرید.

**3. تأخیر کم حیاتی است**

callهای همگام تأخیر قابل پیش‌بینی دارند؛ رویدادها overhead اضافه می‌کنند.

**4. تیم‌های کوچک**

سربار عملیاتی ممکن است تیم‌های کوچک را تحت‌الشعاع قرار دهد.

**5. اولویت دیباگ/تست**

اگر قابلیت دیباگ بسیار مهم است، جریان‌های همگام آسان‌تر هستند.

**6. زیرساخت محدود**

اجرا و مدیریت event brokerها نیاز به منابع دارد.

**7. مصرف‌کننده واحد**

اگر فقط یک سرویس به داده نیاز دارد، callهای مستقیم ممکن است ساده‌تر باشند.

**8. فاز Prototype**

ساده شروع کنید؛ زمانی EDA را معرفی کنید که پیچیدگی آن را توجیه کند.

### 9.3 رویکرد ترکیبی

بسیاری از سیستم‌ها از هر دو استفاده می‌کنند:

```
معماری ترکیبی

┌────────────────────────────────────────────────────┐
│                     سیستم                          │
├────────────────────────────────────────────────────┤
│                                                    │
│  همگام:                                            │
│    ├─ احراز هویت کاربر (پاسخ فوری)                │
│    ├─ پردازش پرداخت (سازگاری قوی)                 │
│    └─ مسیریابی API Gateway                        │
│                                                    │
│  ناهمگام (رویداد محور):                            │
│    ├─ گردش‌کار پردازش سفارش                       │
│    ├─ Analytics و گزارش‌دهی                       │
│    ├─ اطلاع‌رسانی‌های ایمیل                       │
│    └─ ابطال Cache                                 │
│                                                    │
└────────────────────────────────────────────────────┘
```

## 10. مثال‌های دنیای واقعی

### 10.1 Event Sourcing در بانکداری

**مورد استفاده**: مدیریت حساب با audit trail کامل.

```
سیستم حساب بانکی با Event Sourcing

Event Store: Account-987654
┌─────────────────────────────────────────────────────────────┐
│ [1] 2025-01-01 10:00  AccountOpened                         │
│     { customerId: "C123", initialDeposit: 10000 }           │
│                                                             │
│ [2] 2025-01-05 14:30  InterestCredited                      │
│     { amount: 150, rate: 0.015 }                            │
│                                                             │
│ [3] 2025-01-10 09:15  WithdrawalMade                        │
│     { amount: 2000, atmId: "ATM-456", location: "NYC" }     │
│                                                             │
│ [4] 2025-01-15 16:45  DepositMade                           │
│     { amount: 5000, branch: "Downtown" }                    │
│                                                             │
│ [5] 2025-01-20 11:00  FraudAlertRaised                      │
│     { reason: "Unusual pattern", suspended: true }          │
│                                                             │
│ [6] 2025-01-21 10:30  FraudAlertCleared                     │
│     { verifiedBy: "Agent-789", suspended: false }           │
└─────────────────────────────────────────────────────────────┘

مزایا:
✓ Audit trail کامل برای compliance قانونی
✓ بازسازی وضعیت حساب در هر نقطه از تاریخ
✓ Replay رویدادها برای تست قوانین کسب‌وکار جدید
✓ تولید گزارش‌های compliance از تاریخچه رویداد
✓ بررسی fraud با بررسی توالی رویدادها
```

**مثال Query قانونی**:

```
Query: "همه تراکنش‌های بالای $10,000 در Q1 2025 را نشان بده"

فیلتر رویدادها:
- نوع: DepositMade یا WithdrawalMade
- تاریخ: 2025-01-01 تا 2025-03-31
- مبلغ > 10000

نتایج:
[1] 2025-01-01  AccountOpened     $10,000 (اولیه)
[4] 2025-01-15  DepositMade       $5,000  ← زیر آستانه
[7] 2025-02-10  DepositMade       $15,000 ← مطابقت!
[9] 2025-03-05  WithdrawalMade    $12,000 ← مطابقت!
```

### 10.2 پردازش سفارش تجارت الکترونیک

**مورد استفاده**: گردش‌کار سفارش با چندین سرویس هماهنگ‌شده از طریق رویدادها.

```
جریان پردازش سفارش رویداد محور

مرحله 1: سفارش ایجاد شد
Customer → Order Service
              │
              │ OrderCreated {
              │   orderId: "O-123",
              │   items: [...],
              │   total: $150
              │ }
              ▼
        Event Broker
              │
              ├────────────────────┬────────────────────┬───────────────┐
              ▼                    ▼                    ▼               ▼
        Payment         Inventory          Email           Analytics
        Service         Service            Service         Service

مرحله 2: پرداخت انجام شد
Payment Service → Event Broker
                      │
                      │ PaymentProcessed {
                      │   orderId: "O-123",
                      │   amount: $150,
                      │   method: "VISA"
                      │ }
                      ▼
              ┌───────┴────────┐
              ▼                ▼
        Inventory          Email
        (رزرو)            (رسید)

مرحله 3: موجودی رزرو شد
Inventory Service → Event Broker
                      │
                      │ InventoryReserved {
                      │   orderId: "O-123",
                      │   warehouse: "NYC"
                      │ }
                      ▼
              ┌───────┴────────┐
              ▼                ▼
        Shipping           Email
        (زمان‌بندی)       (تأیید)

مرحله 4: ارسال شد
Shipping Service → Event Broker
                      │
                      │ OrderShipped {
                      │   orderId: "O-123",
                      │   trackingNumber: "TRACK-456",
                      │   estimatedDelivery: "2025-01-20"
                      │ }
                      ▼
              ┌───────┴────────┐
              ▼                ▼
         Order              Email
         (به‌روزرسانی)      (ردیابی)
```

**جریان جبران (پرداخت ناموفق)**:

```
جبران از طریق رویدادها (الگوی Saga)

Order Service → PaymentService → Event Broker
                                      │
                                      │ PaymentFailed {
                                      │   orderId: "O-123",
                                      │   reason: "Insufficient funds"
                                      │ }
                                      ▼
                              ┌───────┴────────┐
                              ▼                ▼
                        Order Service      Email Service
                              │                │
                              │ OrderCancelled │ ایمیل
                              │                │ لغو
```

برای پیاده‌سازی دقیق saga، به [الگوی Saga](../distributed-transactions/saga.fa.md) مراجعه کنید.

### 10.3 Netflix - موتور توصیه رویداد محور

**مورد استفاده**: توصیه‌های real-time بر اساس رفتار کاربر.

```
رویدادهای تماشای Netflix

کاربر ویدیو تماشا می‌کند → Event Stream
                          │
                          │ VideoWatched {
                          │   userId: "U-789",
                          │   videoId: "V-456",
                          │   duration: 3600,
                          │   completionRate: 0.95,
                          │   timestamp: "..."
                          │ }
                          ▼
        ┌─────────────────┼─────────────────┐
        ▼                 ▼                 ▼
  Recommendation     Analytics       Content
     Engine           Service        Service
        │                              │
        │ به‌روزرسانی                  │ ردیابی
        │ ترجیحات کاربر                │ محبوبیت
        │                              │
        ▼                              ▼
  صفحه اصلی                         محتوای
  شخصی‌سازی‌شده                      پرطرفدار
```

**مزایا**:
- به‌روزرسانی‌های real-time توصیه‌ها
- تیم‌های متعدد رویدادهای یکسان را مصرف می‌کنند
- مقیاس‌پذیری رویدادهای تماشا (میلیاردها در روز)
- تست A/B الگوریتم‌های مختلف توصیه به صورت مستقل

### 10.4 Uber - سیستم Dispatch رویداد محور

**مورد استفاده**: تطبیق real-time سواران و رانندگان.

```
Dispatch رویداد محور

به‌روزرسانی‌های موقعیت راننده (هر 4 ثانیه)
Driver App → Event Stream
                  │
                  │ DriverLocationUpdated {
                  │   driverId: "D-123",
                  │   lat: 40.7589,
                  │   lng: -73.9851,
                  │   status: "AVAILABLE",
                  │   timestamp: "..."
                  │ }
                  ▼
          ┌───────┴────────┐
          ▼                ▼
     Dispatch          Analytics
     Service           Service
          │
          │ نگهداری موقعیت‌های
          │ real-time رانندگان
          │
          ▼
     الگوریتم تطبیق

درخواست سوار:
Rider App → Dispatch Service
                  │
                  │ یافتن رانندگان موجود نزدیک
                  │ (از موقعیت‌های cache شده)
                  │
                  ▼
            تطبیق پیدا شد!
                  │
                  │ RideMatched {
                  │   riderId: "R-456",
                  │   driverId: "D-123",
                  │   estimatedArrival: 3
                  │ }
                  ▼
          Event Broker
                  │
          ┌───────┼────────┐
          ▼       ▼        ▼
      Driver  Rider   Notification
       App     App     Service
```

## 11. الگوهای مرتبط

معماری رویداد محور با بسیاری از الگوهای دیگر ارتباط دارد:

**1. CQRS (Command Query Responsibility Segregation)**

برای تفکیک مدل‌های خواندن و نوشتن با استفاده از رویدادها، [الگوی CQRS](../data-patterns/cqrs.fa.md) را ببینید.

**2. الگوی Saga**

برای مدیریت تراکنش‌های توزیع‌شده با رویدادها، [الگوی Saga](../distributed-transactions/saga.fa.md) را ببینید.

**3. Two-Phase Commit**

برای جایگزینی تراکنش‌های توزیع‌شده مبتنی بر رویداد، [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) را ببینید.

**4. انتخاب Message Broker**

برای انتخاب زیرساخت رویداد مناسب، [RabbitMQ در مقابل Kafka](../messaging/rabbitmq-vs-kafka.fa.md) را ببینید.

**5. معماری Microservices**

EDA تناسب طبیعی برای ارتباطات [Microservices](../architecture/microservices.fa.md) است.

**6. API Gateway**

[API Gateway](../architecture/api-gateway.fa.md) اغلب رویدادها را برای پردازش داخلی trigger می‌کند.

**7. Circuit Breaker**

[Circuit Breaker](../resilience/circuit-breaker.fa.md) به جلوگیری از شکست‌های cascade در مصرف‌کنندگان رویداد کمک می‌کند.

**8. قضیه CAP**

EDA معمولاً در دسترس بودن و تحمل partition را اولویت می‌دهد. [قضیه CAP](../fundamentals/cap-theorem.fa.md) را ببینید.

**روابط الگو**:

```
                    Event-Driven Architecture
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
         Microservices      CQRS          Saga
              │               │               │
              │               │               │
        ┌─────┴─────┐   ┌─────┴─────┐   ┌─────┴─────┐
        ▼           ▼   ▼           ▼   ▼           ▼
    API Gateway  Circuit  Event    Read  Choreography Orchestration
                 Breaker  Sourcing Models
```

## 12. چارچوب مصاحبه / نکات کلیدی

هنگام بحث در مورد معماری رویداد محور در مصاحبه‌ها، از این چارچوب استفاده کنید:

### 12.1 مفاهیم اصلی برای پوشش

**1. تعریف الگو**

"معماری رویداد محور الگویی است که در آن کامپوننت‌ها از طریق رویدادهایی که نشان‌دهنده تغییرات مهم وضعیت هستند ارتباط برقرار می‌کنند. جداسازی느슨 و پردازش ناهمگام را ترویج می‌دهد."

**2. چهار الگوی رویداد**

- **Event Notification**: داده حداقلی، callback لازم
- **Event-Carried State Transfer**: داده کامل، مصرف‌کنندگان مستقل
- **Event Sourcing**: رویدادها به عنوان منبع حقیقت
- **CQRS**: مدل‌های خواندن/نوشتن جداگانه

**3. معاوضه‌های کلیدی**

| مزیت | چالش |
|------|------|
| جداسازی느슨 | سازگاری نهایی |
| مقیاس‌پذیری | پیچیدگی |
| انعطاف‌پذیری | دشواری دیباگ |
| Audit trail | تکامل schema رویداد |
| قابلیت گسترش | سربار عملیاتی |

### 12.2 هنگام طراحی سیستم رویداد محور

**مرحله 1: شناسایی رویدادها**

```
دامنه: سیستم سفارش تجارت الکترونیک

رویدادها:
- OrderCreated
- PaymentProcessed
- PaymentFailed
- InventoryReserved
- InventoryUnavailable
- OrderShipped
- OrderDelivered
- OrderCancelled
```

**مرحله 2: انتخاب الگوی رویداد**

- Event Notification: برای هشدارهای ساده
- Event-Carried State Transfer: برای ساخت viewهای محلی
- Event Sourcing: برای audit trail و queryهای زمانی
- CQRS: برای تفکیک خواندن/نوشتن

**مرحله 3: انتخاب زیرساخت**

- Message Broker (RabbitMQ): برای توزیع task، RPC
- Event Stream (Kafka): برای event sourcing، throughput بالا، replay

**مرحله 4: تعریف تضمین‌های تحویل**

- At-most-once: Metricsها، غیرحیاتی
- At-least-once: اکثر رویدادهای کسب‌وکار (با idempotency)
- Exactly-once: تراکنش‌های مالی حیاتی

**مرحله 5: طراحی برای شکست**

- پیاده‌سازی مصرف‌کنندگان idempotent
- استفاده از dead-letter queueها
- اضافه کردن circuit breakerها
- برنامه‌ریزی منطق جبران (sagaها)

### 12.3 سوالات رایج مصاحبه

**س1: "چگونه پردازش exactly-once را تضمین می‌کنید؟"**

پ: "exactly-once واقعی در سیستم‌های توزیع‌شده به دلیل partitionهای شبکه غیرممکن است. ما 'effectively once' یا 'exactly-once processing semantics' را از طریق این روش‌ها به دست می‌آوریم:
1. مصرف‌کنندگان idempotent (بررسی IDهای رویداد پردازش‌شده)
2. الگوی transactional outbox
3. نوشتن‌های اتمی پایگاه داده با انتشار رویداد
4. Deduplication در هم تولیدکننده و هم مصرف‌کننده"

**س2: "چگونه ترتیب رویداد را مدیریت می‌کنید؟"**

پ: "ترتیب global گران است و معمولاً غیرضروری. در عوض:
1. Partition کردن رویدادها با aggregate ID (مثلاً رویدادهای یک کاربر در partition یکسان)
2. استفاده از شماره‌های sequence در partitionها
3. Version کردن رویدادها برای همزمانی خوش‌بینانه
4. پذیرش اینکه رویدادهای cross-partition ممکن است خارج از ترتیب برسند"

**س3: "Event Sourcing در مقابل پایگاه داده سنتی؟"**

پ: "Event Sourcing رویدادها را ذخیره می‌کند، نه وضعیت:
- مزایا: Audit trail کامل، queryهای زمانی، قابلیت replay
- معایب: پیچیدگی، سازگاری نهایی برای خواندن‌ها، versioning رویداد
- استفاده زمانی که: Audit حیاتی، queryهای زمانی لازم، نیازهای compliance
- اجتناب زمانی که: CRUD ساده، سازگاری قوی لازم، تیم کوچک"

**س4: "چگونه سیستم‌های رویداد محور را دیباگ می‌کنید؟"**

پ: "دیباگ چالش‌برانگیز است. تکنیک‌های کلیدی:
1. Correlation IDها در همه رویدادها
2. Distributed tracing (Zipkin، Jaeger)
3. Logging متمرکز با IDهای رویداد
4. Replay رویداد در محیط‌های تست
5. داشبوردهای نظارت برای تأخیر مصرف‌کننده
6. تحلیل dead-letter queue"

**س5: "Choreography در مقابل Orchestration؟"**

پ: "هر دو گردش‌کارهای چند مرحله‌ای را هماهنگ می‌کنند:
- Choreography: سرویس‌ها به رویدادها واکنش نشان می‌دهند (coupling느슨، نظارت سخت‌تر)
- Orchestration: کنترل‌کننده مرکزی (درک آسان‌تر، نقطه شکست واحد)
- انتخاب بستگی دارد به: پیچیدگی فرآیند، ساختار تیم، نیازهای نظارت
- اغلب از هر دو استفاده می‌شود: choreography برای جریان‌های ساده، orchestration برای sagaهای پیچیده"

### 12.4 چک‌لیست تصمیم طراحی

هنگام پیشنهاد EDA، به این موارد بپردازید:

- [ ] آیا همه رویدادهای دامنه را شناسایی کرده‌اید؟
- [ ] کدام الگوی رویداد (notification، state transfer، sourcing)؟
- [ ] چه تضمین تحویلی لازم است؟
- [ ] چگونه تکرارها را مدیریت خواهید کرد؟
- [ ] استراتژی تکامل schema رویداد شما چیست؟
- [ ] چگونه تأخیر مصرف‌کننده را نظارت خواهید کرد؟
- [ ] برنامه بازیابی از شکست شما چیست؟
- [ ] آیا سازگاری نهایی قابل قبول است؟
- [ ] آیا سربار عملیاتی را در نظر گرفته‌اید؟
- [ ] استراتژی تست شما چیست؟

### 12.5 نکات کلیدی

1. **EDA جداسازی느슨 را ترویج می‌دهد** از طریق ارتباط رویداد ناهمگام
2. **چهار الگو** نیازهای مختلف را برآورده می‌کنند: notification، state transfer، sourcing، CQRS
3. **معاوضه سازگاری برای در دسترس بودن** - پذیرش سازگاری نهایی
4. **Idempotency حیاتی است** برای تحویل at-least-once
5. **انتخاب دقیق زیرساخت** - message brokerها در مقابل event streamها
6. **Choreography در مقابل orchestration** - رویکردهای هماهنگی مختلف
7. **نظارت ضروری است** - distributed tracing، correlation IDها، تأخیر مصرف‌کننده
8. **ساده شروع کنید** - زمانی EDA را معرفی کنید که پیچیدگی آن را توجیه کند
9. **موفقیت دنیای واقعی** - Netflix، Uber، بانک‌ها از EDA در مقیاس عظیم استفاده می‌کنند
10. **ترکیب با الگوهای دیگر** - CQRS، Saga، Microservices، Circuit Breaker

### 12.6 مطالعه بیشتر

**کتاب‌ها**:
- "Designing Data-Intensive Applications" توسط Martin Kleppmann (فصل 11: Stream Processing)
- "Enterprise Integration Patterns" توسط Gregor Hohpe
- "Building Event-Driven Microservices" توسط Adam Bellemare
- "Implementing Domain-Driven Design" توسط Vaughn Vernon (فصل Event Sourcing)

**منابع**:
- Martin Fowler: "What do you mean by Event-Driven?"
- Greg Young: صحبت‌های "Event Sourcing"
- مستندات Kafka: مفاهیم Event streaming
- مستندات AWS EventBridge / Azure Event Grid

**وبلاگ‌های مهندسی شرکت‌ها**:
- Netflix Tech Blog: معماری رویداد محور در مقیاس
- Uber Engineering: سیستم dispatch real-time
- LinkedIn: الگوهای استفاده از Kafka
- Amazon: Microserviceهای رویداد محور

---

**ناوبری**:
- قبلی: [الگوی CQRS](../data-patterns/cqrs.fa.md)
- بعدی: [الگوی Saga](../distributed-transactions/saga.fa.md)
- مرتبط: [Microservices](../architecture/microservices.fa.md)، [قضیه CAP](../fundamentals/cap-theorem.fa.md)
