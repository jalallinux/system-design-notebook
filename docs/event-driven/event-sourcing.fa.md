# Event Sourcing (منبع‌یابی رویداد)

## ۱. مقدمه

**Event Sourcing** یک الگوی معماری است که وضعیت یک Aggregate را به صورت دنباله‌ای از رویدادهای تغییردهنده وضعیت ذخیره می‌کند، به جای اینکه فقط وضعیت فعلی را نگهداری کند. به جای به‌روزرسانی یک رکورد در پایگاه داده، هر تغییر به عنوان یک رویداد تغییرناپذیر (immutable) به یک ذخیره‌ساز رویداد (Event Store) اضافه می‌شود. وضعیت فعلی هر موجودیت با بازپخش رویدادها از ابتدا (یا از یک اسنپ‌شات) به دست می‌آید.

### منشاء و تکامل

الگوی Event Sourcing توسط **Greg Young** در اواخر دهه ۲۰۰۰ میلادی محبوب شد و از مفاهیمی الهام گرفت که قرن‌هاست در دفاتر حسابداری و لاگ‌های تراکنش وجود دارند. در حسابداری دوطرفه، هر تراکنش مالی به عنوان یک ثبت تغییرناپذیر ضبط می‌شود -- مانده حساب همیشه نتیجه جمع همه ثبت‌هاست. به همین ترتیب، لاگ‌های تراکنش پایگاه داده (Write-Ahead Logs) مدت‌هاست که از رکوردهای فقط-الحاقی برای تضمین ماندگاری و بازیابی استفاده می‌کنند.

Greg Young این ایده‌ها را در قالب یک الگوی معماری نرم‌افزار رسمی کرد و نشان داد که Event Sourcing به طور طبیعی با [CQRS](../data-patterns/cqrs.fa.md) ترکیب می‌شود تا سیستم‌های مقیاس‌پذیر، قابل‌حسابرسی و بسیار انعطاف‌پذیر بسازد.

### ذخیره‌سازی سنتی وضعیت در مقابل Event Sourcing

```
Traditional State Storage:
┌──────────────────────────────────────────────────┐
│  Account Table                                    │
│──────────────────────────────────────────────────│
│  account_id  │  owner     │  balance  │  status  │
│──────────────┼────────────┼───────────┼──────────│
│  ACC-001     │  Alice     │  1300     │  ACTIVE  │
│  ACC-002     │  Bob       │  750      │  ACTIVE  │
└──────────────────────────────────────────────────┘
  فقط وضعیت فعلی ذخیره شده. تاریخچه از دست رفته.


Event Sourcing:
┌──────────────────────────────────────────────────────────────┐
│  Event Store (لاگ فقط-الحاقی) — Stream: ACC-001             │
│──────────────────────────────────────────────────────────────│
│  [1] AccountOpened       { owner: "Alice", balance: 0 }      │
│  [2] MoneyDeposited      { amount: 1000 }                    │
│  [3] MoneyWithdrawn      { amount: 200 }                     │
│  [4] MoneyDeposited      { amount: 500 }                     │
│──────────────────────────────────────────────────────────────│
│  وضعیت فعلی = بازپخش همه رویدادها                            │
│  → balance: 0 + 1000 - 200 + 500 = 1300                     │
└──────────────────────────────────────────────────────────────┘
  هر تغییر ثبت شده. تاریخچه کامل حفظ شده.
```

### اصول اساسی

| اصل | توضیح |
|-----|-------|
| **رویدادها تغییرناپذیرند** | پس از نوشتن، رویدادها هرگز اصلاح یا حذف نمی‌شوند |
| **ذخیره‌سازی فقط-الحاقی** | رویدادهای جدید فقط اضافه می‌شوند؛ بدون به‌روزرسانی یا حذف |
| **رویدادها منبع حقیقت هستند** | وضعیت فعلی مشتق می‌شود، نه اینکه مستقیماً ذخیره شود |
| **رویدادها بیانگر وقایع هستند** | هر رویداد چیزی را ثبت می‌کند که در گذشته اتفاق افتاده |
| **بازپخش برای بازسازی** | وضعیت در هر نقطه از زمان با بازپخش رویدادها قابل بازسازی است |

---

## ۲. زمینه و مسئله

### زمینه

در سیستم‌های توزیع‌شده مدرن، به‌ویژه آن‌هایی که بر پایه [میکروسرویس‌ها](../architecture/microservices.fa.md) و [معماری‌های رویداد-محور](./event-driven-architecture.fa.md) ساخته شده‌اند، چندین چالش مکرراً بروز می‌کند:

1. **نیازمندی‌های ردیابی حسابرسی** -- الزامات قانونی و تجاری خواستار تاریخچه کامل و غیرقابل دستکاری از همه تغییرات وضعیت هستند (مالی، بهداشت، حقوقی).
2. **پرس‌وجوهای زمانی** -- نیاز به پاسخ سوالاتی مانند «مانده حساب در ۱۰ ژانویه چقدر بود؟» یا «وضعیت سفارش قبل از آخرین تغییر چه بود؟»
3. **انتشار قابل اطمینان رویداد** -- وقتی وضعیت تغییر می‌کند، سرویس‌های دیگر باید به طور قابل اطمینان مطلع شوند. رویکردهای سنتی خطر از دست دادن رویدادها یا ایجاد ناسازگاری بین وضعیت و رویدادهای منتشرشده را دارند.
4. **اشکال‌زدایی و تحلیل جرم‌شناسی** -- درک اینکه سیستم چگونه به یک وضعیت خاص رسیده، به‌ویژه هنگام بررسی باگ‌ها یا حوادث.

### مسئله

چگونه می‌توان تغییرات وضعیت را به طور قابل اطمینان ذخیره کرد و همزمان رویدادها را به سرویس‌های دیگر منتشر کرد، در حالی که تاریخچه کامل و قابل اعتمادی از همه تغییرات حفظ شود؟

در رویکرد سنتی CRUD:

```
مشکل CRUD سنتی:

1. به‌روزرسانی پایگاه داده   ← وضعیت اینجا تغییر می‌کند
2. انتشار رویداد              ← اطلاع‌رسانی اینجا انجام می‌شود

اگر مرحله ۲ شکست بخورد چه؟
 → وضعیت تغییر کرده اما رویدادی منتشر نشده
 → سرویس‌های دیگر ناهماهنگ هستند
 → تاریخچه قابل اطمینانی از تغییرات وجود ندارد

اگر ابتدا منتشر کنید چه؟
1. انتشار رویداد
2. به‌روزرسانی پایگاه داده   ← اگر این شکست بخورد چه؟
 → رویداد منتشر شده اما وضعیت ذخیره نشده
 → ناسازگاری!
```

این اساساً یک **مشکل نوشتن دوگانه (dual-write)** است: شما باید به صورت اتمی وضعیت را به‌روزرسانی کنید و یک رویداد منتشر کنید، اما این‌ها دو عملیات جداگانه هستند که به راحتی نمی‌توان آن‌ها را در یک تراکنش واحد قرار داد.

---

## ۳. نیروها

چندین نیروی رقیب نیاز به Event Sourcing را ایجاد می‌کنند:

| نیرو | توضیح |
|------|-------|
| **اتمی بودن** | تغییر وضعیت و انتشار رویداد باید به صورت اتمی انجام شود -- یا هر دو موفق شوند یا هیچ‌کدام |
| **ردیابی حسابرسی کامل** | هر تغییر وضعیت باید برای انطباق، اشکال‌زدایی یا هوش تجاری به طور دائمی ثبت شود |
| **پرس‌وجوهای زمانی** | سیستم باید از پرس‌وجوی وضعیت یک موجودیت در هر نقطه از گذشته پشتیبانی کند |
| **انتشار قابل اطمینان رویداد** | رویدادها باید هر زمان که وضعیت تغییر می‌کند به طور قابل اطمینان منتشر شوند، بدون رویداد گمشده یا فانتوم |
| **عملکرد** | خواندن و نوشتن ویژگی‌های عملکردی و نیازهای مقیاس‌پذیری متفاوتی دارند |
| **تکامل اسکیما** | سیستم باید بدون از دست دادن داده‌های تاریخی، تغییرات ساختار رویداد را در طول زمان مدیریت کند |
| **بودجه پیچیدگی** | راه‌حل باید با توجه به پیچیدگی اضافه‌شده قابل توجیه باشد |

### تعامل نیروها

```
                    ┌──────────────────────┐
                    │   Event Sourcing     │
                    │   این نیروهای رقیب   │
                    │   را حل می‌کند       │
                    └──────────┬───────────┘
                               │
         ┌─────────────────────┼─────────────────────┐
         │                     │                     │
         ▼                     ▼                     ▼
  ┌──────────────┐   ┌──────────────────┐   ┌──────────────┐
  │  اتمی بودن  │   │  ردیابی حسابرسی │   │   انتشار     │
  │  وضعیت +    │   │  + پرس‌وجوهای   │   │   قابل اطمینان│
  │  رویداد     │   │  زمانی          │   │   رویداد     │
  └──────────────┘   └──────────────────┘   └──────────────┘
         │                     │                     │
         │                     │                     │
         ▼                     ▼                     ▼
  رویدادها خود تغییر     تاریخچه محصول          رویدادها ابتدا
  وضعیت هستند           طبیعی لاگ رویداد       ذخیره و سپس
  (یک نوشتن واحد)       است                    پروجکت/منتشر
                                                می‌شوند
```

---

## ۴. راه‌حل

### ایده اصلی

به جای ذخیره وضعیت فعلی یک موجودیت، **هر تغییر وضعیت را به عنوان یک رویداد تغییرناپذیر** در یک ذخیره‌ساز رویداد فقط-الحاقی ذخیره کنید. وضعیت فعلی هر موجودیت با بارگذاری و بازپخش جریان رویدادهایش به دست می‌آید.

### ذخیره‌ساز رویداد (Event Store)

ذخیره‌ساز رویداد یک پایگاه داده تخصصی فقط-الحاقی است که به عنوان تنها منبع حقیقت سیستم عمل می‌کند.

```
معماری Event Store
┌──────────────────────────────────────────────────────────────────┐
│                         EVENT STORE                              │
│                  (پایگاه داده فقط-الحاقی)                        │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Stream: ShoppingCart-42                                          │
│  ┌───────┬──────────────────┬───────────────┬──────────────────┐ │
│  │ نسخه  │   نوع رویداد     │   زمان        │    داده          │ │
│  ├───────┼──────────────────┼───────────────┼──────────────────┤ │
│  │  1    │ CartCreated      │ 2025-01-15T09 │ { userId: 42 }   │ │
│  │  2    │ ItemAdded        │ 2025-01-15T09 │ { sku: "A1" }    │ │
│  │  3    │ ItemAdded        │ 2025-01-15T09 │ { sku: "B2" }    │ │
│  │  4    │ ItemRemoved      │ 2025-01-15T10 │ { sku: "A1" }    │ │
│  │  5    │ CartCheckedOut   │ 2025-01-15T10 │ { total: 29.99 } │ │
│  └───────┴──────────────────┴───────────────┴──────────────────┘ │
│                                                                  │
│  Stream: ShoppingCart-43                                          │
│  ┌───────┬──────────────────┬───────────────┬──────────────────┐ │
│  │  1    │ CartCreated      │ 2025-01-15T11 │ { userId: 77 }   │ │
│  │  2    │ ItemAdded        │ 2025-01-15T11 │ { sku: "C3" }    │ │
│  └───────┴──────────────────┴───────────────┴──────────────────┘ │
│                                                                  │
│  ویژگی‌ها:                                                       │
│  ✓ فقط-الحاقی (بدون به‌روزرسانی، بدون حذف)                      │
│  ✓ رویدادها تغییرناپذیرند                                        │
│  ✓ مرتب‌شده در هر جریان                                          │
│  ✓ ترتیب سراسری از طریق موقعیت/شماره ترتیب                      │
│  ✓ کنترل همزمانی خوش‌بینانه از طریق نسخه مورد انتظار             │
└──────────────────────────────────────────────────────────────────┘
```

**اسکیمای Event Store**:

```
┌────────────┬──────────┬──────────────────┬───────────────┬───────────┬──────────────┬──────────┐
│ Stream ID  │ Version  │   Event Type     │   Timestamp   │  Payload  │   Metadata   │ Position │
├────────────┼──────────┼──────────────────┼───────────────┼───────────┼──────────────┼──────────┤
│ Cart-42    │    1     │ CartCreated      │ 2025-01-15... │  {...}    │  {...}       │  1001    │
│ Cart-42    │    2     │ ItemAdded        │ 2025-01-15... │  {...}    │  {...}       │  1002    │
│ Cart-42    │    3     │ ItemAdded        │ 2025-01-15... │  {...}    │  {...}       │  1003    │
│ Acct-99    │    1     │ AccountOpened    │ 2025-01-15... │  {...}    │  {...}       │  1004    │
│ Cart-42    │    4     │ ItemRemoved      │ 2025-01-15... │  {...}    │  {...}       │  1005    │
└────────────┴──────────┴──────────────────┴───────────────┴───────────┴──────────────┴──────────┘

ایندکس‌ها:
- PRIMARY:   (Stream ID, Version)         → خواندن یک جریان واحد
- INDEX:     Position                      → ترتیب سراسری / اشتراک‌ها
- INDEX:     Event Type                    → فیلتر بر اساس نوع رویداد
- INDEX:     Timestamp                     → پرس‌وجوهای مبتنی بر زمان
```

### بازسازی وضعیت

برای دریافت وضعیت فعلی یک Aggregate، همه رویدادهای آن Aggregate را بارگذاری و به ترتیب اعمال کنید:

```
بازسازی وضعیت: ShoppingCart-42

مرحله ۱: بارگذاری رویدادها از Event Store
┌──────────────────────────────────────┐
│  SELECT * FROM events                │
│  WHERE stream_id = 'Cart-42'        │
│  ORDER BY version ASC               │
└──────────────────────────────────────┘

مرحله ۲: اعمال رویدادها بر Aggregate خالی

  وضعیت اولیه:  { items: [], total: 0, status: "empty" }

  اعمال [1] CartCreated:
    → { items: [], total: 0, status: "active", userId: 42 }

  اعمال [2] ItemAdded { sku: "A1", price: 19.99 }:
    → { items: ["A1"], total: 19.99, status: "active" }

  اعمال [3] ItemAdded { sku: "B2", price: 29.99 }:
    → { items: ["A1", "B2"], total: 49.98, status: "active" }

  اعمال [4] ItemRemoved { sku: "A1", price: 19.99 }:
    → { items: ["B2"], total: 29.99, status: "active" }

  اعمال [5] CartCheckedOut:
    → { items: ["B2"], total: 29.99, status: "checked_out" }

مرحله ۳: وضعیت فعلی نتیجه بازپخش همه رویدادهاست
```

### جریان پردازش دستور (Command)

```
Client                  Command Handler            Aggregate              Event Store
  │                           │                        │                       │
  │  1. AddItem(Cart-42,     │                        │                       │
  │     sku="C3")            │                        │                       │
  ├──────────────────────────▶│                        │                       │
  │                           │                        │                       │
  │                           │ 2. بارگذاری رویدادها   │                       │
  │                           │    برای Cart-42        │                       │
  │                           ├────────────────────────────────────────────────▶│
  │                           │                        │                       │
  │                           │ 3. بازگشت رویدادها     │                       │
  │                           │    [1..5]              │                       │
  │                           │◀───────────────────────────────────────────────┤
  │                           │                        │                       │
  │                           │ 4. بازپخش رویدادها     │                       │
  │                           │    برای ساخت وضعیت    │                       │
  │                           ├───────────────────────▶│                       │
  │                           │                        │                       │
  │                           │ 5. اجرای دستور        │                       │
  │                           │    (اعتبارسنجی: آیا   │                       │
  │                           │     سبد هنوز فعال؟)   │                       │
  │                           │                        │                       │
  │                           │ 6. رد شد: سبد قبلاً   │                       │
  │                           │    تسویه شده           │                       │
  │                           │◀──────────────────────┤│                       │
  │                           │                        │                       │
  │  7. خطا: سبد قبلاً       │                        │                       │
  │     تسویه شده             │                        │                       │
  │◀──────────────────────────┤                        │                       │
```

### اسنپ‌شات‌ها (Snapshots)

برای Aggregate‌هایی با تعداد زیاد رویداد، بازپخش کل جریان رویداد در هر دستور کند می‌شود. **اسنپ‌شات‌ها** بهینه‌سازی‌ای هستند که یک نقطه بازرسی دوره‌ای از وضعیت Aggregate را ذخیره می‌کنند.

```
Event Store با اسنپ‌شات‌ها
┌──────────────────────────────────────────────────────────────────┐
│  Stream: Account-001                                             │
├──────────────────────────────────────────────────────────────────┤
│  [1]   AccountOpened        { balance: 0 }                       │
│  [2]   MoneyDeposited       { amount: 1000 }                     │
│  [3]   MoneyWithdrawn       { amount: 200 }                      │
│  ...                                                             │
│  [99]  MoneyDeposited       { amount: 50 }                       │
│  [100] *** اسنپ‌شات ***     { balance: 5000, version: 100 }     │
│  [101] MoneyDeposited       { amount: 200 }                      │
│  [102] MoneyWithdrawn       { amount: 300 }                      │
│  ...                                                             │
│  [199] MoneyDeposited       { amount: 75 }                       │
│  [200] *** اسنپ‌شات ***     { balance: 7500, version: 200 }     │
│  [201] MoneyDeposited       { amount: 100 }                      │
│  [202] MoneyWithdrawn       { amount: 50 }                       │
└──────────────────────────────────────────────────────────────────┘

بدون اسنپ‌شات:                     با اسنپ‌شات:
─────────────────                   ─────────────────
بارگذاری رویدادها [1..202]          بارگذاری اسنپ‌شات در [200]
بازپخش ۲۰۲ رویداد                  بارگذاری رویدادها [201..202]
                                    بازپخش ۲ رویداد

عملکرد:                            عملکرد:
O(n) که n = همه رویدادها             O(1) اسنپ‌شات + O(m) رویدادهای اخیر
کند برای Aggregateهای طولانی‌عمر    سریع بدون توجه به طول تاریخچه
```

**تصمیم استراتژی اسنپ‌شات**:

```
زمان ایجاد اسنپ‌شات:
├─ هر N رویداد (مثلاً هر ۱۰۰ رویداد)
├─ بر اساس زمان‌بندی (مثلاً روزانه)
├─ وقتی زمان بارگذاری از آستانه‌ای فراتر رود
└─ با دستور صریح (مدیر/نگهداری)

زمانی که اسنپ‌شات لازم نیست:
├─ Aggregateها رویدادهای کمی دارند (< ۵۰)
├─ Aggregateها عمر کوتاهی دارند
└─ بازپخش در حال حاضر به اندازه کافی سریع است
```

### تکامل اسکیمای رویداد

همانطور که سیستم‌ها تکامل می‌یابند، اسکیماهای رویداد باید تغییر کنند. این یکی از چالش‌برانگیزترین جنبه‌های Event Sourcing است زیرا رویدادها تغییرناپذیرند -- نمی‌توانید برگردید و رویدادهای تاریخی را اصلاح کنید.

**استراتژی ۱: Upcasting (ارتقا)**

تبدیل رویدادهای قدیمی به اسکیمای فعلی در زمان خواندن:

```
رویداد ذخیره‌شده (v1):                بعد از Upcasting (v2):
{                                     {
  "type": "CustomerRegistered",         "type": "CustomerRegistered",
  "version": 1,                         "version": 2,
  "data": {                             "data": {
    "name": "Alice Smith"                 "firstName": "Alice",
  }                                       "lastName": "Smith",
}                                         "email": null
                                        }
                                      }

منطق Upcaster:
  if (event.version == 1) {
    تقسیم name به firstName + lastName
    اضافه کردن email = null (فیلد جدید)
    بازگشت رویداد با version = 2
  }
```

**استراتژی ۲: نسخه‌بندی رویداد**

```
رویدادهای نسخه ۱ همان‌طور باقی می‌مانند
رویدادهای نسخه ۲ از اسکیمای جدید استفاده می‌کنند

هندلرهای رویداد هر دو نسخه را می‌فهمند:

  handle(CustomerRegistered_v1 event) {
    // منطق قدیمی
  }

  handle(CustomerRegistered_v2 event) {
    // منطق جدید با فیلدهای جدید
  }
```

**استراتژی ۳: اسکیمای ضعیف با فیلدهای اختیاری**

```
{
  "type": "OrderPlaced",
  "data": {
    "orderId": "123",
    "items": [...],
    "total": 99.99,
    "couponCode": null,          // بعداً اضافه شده، nullable
    "shippingMethod": "standard" // بعداً اضافه شده، با مقدار پیش‌فرض
  }
}

فیلدهای جدید همیشه اختیاری هستند یا مقادیر پیش‌فرض دارند.
رویدادهای قدیمی بدون این فیلدها به درستی مدیریت می‌شوند.
```

| استراتژی | مزایا | معایب |
|----------|-------|-------|
| **Upcasting** | اسکیمای فعلی تمیز، یک نسخه هندلر | منطق Upcasting با گذشت زمان رشد می‌کند |
| **نسخه‌بندی رویداد** | صریح، تاریخچه واضح | نگهداری چندین هندلر |
| **اسکیمای ضعیف** | ساده‌ترین رویکرد | ایمنی نوع کمتر، قراردادهای ضمنی |

---

## ۵. مثال

### مثال ۱: حساب بانکی

هر تراکنش مالی به عنوان یک رویداد ذخیره می‌شود. مانده حساب همیشه نتیجه بازپخش همه رویدادهاست.

```
Event Store: Account-5678

[1] 2025-01-01  AccountOpened
    { customerId: "C-100", initialDeposit: 0, accountType: "checking" }

[2] 2025-01-02  MoneyDeposited
    { amount: 5000, source: "wire_transfer", reference: "REF-001" }

[3] 2025-01-05  MoneyWithdrawn
    { amount: 1500, channel: "ATM", location: "NYC-42nd-St" }

[4] 2025-01-10  MoneyDeposited
    { amount: 3000, source: "direct_deposit", employer: "Acme Corp" }

[5] 2025-01-15  TransferSent
    { amount: 500, toAccount: "ACC-9999", memo: "rent" }

[6] 2025-01-20  InterestApplied
    { amount: 12.50, rate: 0.025, period: "monthly" }
```

**بازپخش برای محاسبه مانده فعلی**:

```
رویداد [1] AccountOpened:     مانده = 0
رویداد [2] MoneyDeposited:    مانده = 0 + 5000      = 5000
رویداد [3] MoneyWithdrawn:    مانده = 5000 - 1500    = 3500
رویداد [4] MoneyDeposited:    مانده = 3500 + 3000    = 6500
رویداد [5] TransferSent:      مانده = 6500 - 500     = 6000
رویداد [6] InterestApplied:   مانده = 6000 + 12.50   = 6012.50

مانده فعلی: $6,012.50
```

**پرس‌وجوی زمانی: «مانده حساب در ۸ ژانویه چقدر بود؟»**

```
بازپخش رویدادها تا 2025-01-08:
  [1] AccountOpened:       مانده = 0
  [2] MoneyDeposited:      مانده = 5000
  [3] MoneyWithdrawn:      مانده = 3500
  (توقف - رویداد بعدی ۱۰ ژانویه است)

پاسخ: مانده در ۸ ژانویه $3,500.00 بود
```

### مثال ۲: سبد خرید

```
Event Store: Cart-2024

[1] CartCreated
    { userId: "U-55", sessionId: "sess-abc" }

[2] ItemAdded
    { productId: "PROD-101", name: "Wireless Mouse", price: 29.99, qty: 1 }

[3] ItemAdded
    { productId: "PROD-205", name: "USB-C Cable", price: 12.99, qty: 2 }

[4] ItemQuantityChanged
    { productId: "PROD-205", oldQty: 2, newQty: 3 }

[5] ItemRemoved
    { productId: "PROD-101", reason: "customer_removed" }

[6] CouponApplied
    { code: "SAVE10", discountPercent: 10 }

[7] CartCheckedOut
    { subtotal: 38.97, discount: 3.90, total: 35.07, paymentMethod: "credit_card" }
```

**بازپخش رویدادها برای ساخت وضعیت سبد**:

```
بعد از [1]:  { items: [], status: "active" }
بعد از [2]:  { items: [{PROD-101, qty:1, $29.99}], status: "active" }
بعد از [3]:  { items: [{PROD-101, qty:1, $29.99}, {PROD-205, qty:2, $12.99}] }
بعد از [4]:  { items: [{PROD-101, qty:1, $29.99}, {PROD-205, qty:3, $12.99}] }
بعد از [5]:  { items: [{PROD-205, qty:3, $12.99}] }
بعد از [6]:  { items: [{PROD-205, qty:3, $12.99}], coupon: "SAVE10" }
بعد از [7]:  { items: [{PROD-205, qty:3}], total: $35.07, status: "checked_out" }
```

**تحلیل مشتق‌شده از رویدادها**: بدون Event Sourcing، شما فقط وضعیت نهایی سبد را می‌دانید. با Event Sourcing، می‌توانید تحلیل کنید:

- آیتم‌هایی که اضافه و سپس حذف شدند (علاقه رها شده)
- زمان بین اضافه کردن آیتم‌ها و تسویه
- الگوهای استفاده از کوپن
- نرخ رها کردن سبد (CartCreated بدون CartCheckedOut)

---

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیح |
|------|-------|
| **ردیابی حسابرسی کامل** | هر تغییر وضعیت به طور دائمی ثبت می‌شود. عالی برای انطباق در سیستم‌های مالی، بهداشت و حقوقی |
| **پرس‌وجوهای زمانی** | بازسازی وضعیت هر موجودیت در هر نقطه از گذشته با بازپخش رویدادها تا آن زمان |
| **انتشار قابل اطمینان رویداد** | رویدادها خود وضعیت هستند -- مرحله جداگانه‌ای برای «انتشار» وجود ندارد. مشترکین از Event Store می‌خوانند |
| **اشکال‌زدایی و تحلیل جرم‌شناسی** | بازپخش رویدادها برای بازتولید باگ‌ها. درک دقیق اینکه سیستم چگونه به یک وضعیت خاص رسیده |
| **تناسب طبیعی با CQRS** | رویدادهای Event Store پروجکشن‌های مدل خواندن را هدایت می‌کنند و پیاده‌سازی [CQRS](../data-patterns/cqrs.fa.md) را ساده می‌کنند |
| **ویژگی‌های جدید با اثر قهقرایی** | یک پروجکشن یا مدل خواندن جدید اضافه کنید و آن را با بازپخش رویدادهای تاریخی پر کنید |
| **عملکرد (نوشتن)** | الحاق به یک لاگ فقط-الحاقی بسیار سریع است -- بدون خواندن-قبل-از-نوشتن، بدون قفل ردیف‌ها |
| **طراحی دامنه-محور** | شما را مجبور می‌کند صریحاً درباره رویدادهای دامنه فکر کنید، که منجر به درک غنی‌تر از دامنه می‌شود |

### معایب

| عیب | توضیح |
|-----|-------|
| **پیچیدگی** | به طور قابل توجهی پیچیده‌تر از CRUD سنتی. نیاز به درک Event Store، پروجکشن‌ها، اسنپ‌شات‌ها و سازگاری نهایی دارد |
| **تکامل اسکیمای رویداد** | تغییر اسکیمای رویداد دشوار است زیرا رویدادهای تاریخی تغییرناپذیرند. نیاز به استراتژی‌های Upcasting یا نسخه‌بندی دارد |
| **سازگاری نهایی** | مدل‌های خواندن در نهایت با Event Store سازگار می‌شوند. کاربران ممکن است نوشته‌های خود را فوراً نبینند |
| **منحنی یادگیری** | برای اکثر توسعه‌دهندگان ناآشناست. مدل ذهنی «فقط-الحاقی، بازپخش رویدادها» اساساً متفاوت از CRUD است |
| **دشواری پرس‌وجو** | نمی‌توان وضعیت فعلی را مستقیماً از Event Store پرس‌وجو کرد -- باید از پروجکشن‌ها استفاده شود. پرس‌وجوهای پیچیده نیاز به ساخت مدل‌های خواندن تخصصی دارند |
| **رشد فضای ذخیره‌سازی** | Event Store به طور نامحدود رشد می‌کند. نیاز به استراتژی‌های بایگانی و نگهداری برای سیستم‌های طولانی‌عمر دارد |
| **زمان بازپخش** | بدون اسنپ‌شات، بازسازی وضعیت برای Aggregate‌هایی با رویدادهای زیاد کند است |
| **بلوغ ابزارها** | ابزارها و فریم‌ورک‌های بالغ کمتری نسبت به رویکردهای سنتی ORM/CRUD وجود دارد |

### چه زمانی Event Sourcing ارزشمند است و چه زمانی نیست

```
Event Sourcing زمانی معنا دارد که:
├─ ردیابی حسابرسی کامل الزامی باشد (قانونی، انطباق)
├─ پرس‌وجوهای زمانی یک نیاز اصلی کسب‌وکار باشد
├─ به یکپارچه‌سازی قابل اطمینان مبتنی بر رویداد بین سرویس‌ها نیاز داشته باشید
├─ دامنه پیچیده با انتقال‌های وضعیت غنی باشد
├─ در حال پذیرش CQRS هستید
└─ اشکال‌زدایی رفتار گذشته حیاتی باشد

Event Sourcing بیش از حد لازم است وقتی:
├─ CRUD ساده بدون نیازمندی حسابرسی
├─ تیم تجربه‌ای با این الگو ندارد
├─ دامنه ساده است (وبلاگ، صفحه تنظیمات، مدیریت ساده)
├─ سازگاری قوی برای خواندن الزامی باشد
├─ نمونه‌سازی سریع / استارتاپ در مراحل اولیه
└─ نیازی به پرس‌وجوهای تاریخی نباشد
```

---

## ۷. الگوهای مرتبط

Event Sourcing عمیقاً با چندین الگوی دیگر در این مخزن مرتبط است:

### CQRS (جداسازی مسئولیت Command و Query)

[CQRS](../data-patterns/cqrs.fa.md) طبیعی‌ترین همراه Event Sourcing است. از آنجا که Event Store فقط-الحاقی است و برای پرس‌وجوها بهینه نشده، CQRS سمت خواندن را با پروجکت کردن رویدادها به مدل‌های خواندن غیرنرمال و بهینه‌شده برای پرس‌وجو فراهم می‌کند.

```
Event Sourcing + CQRS
┌───────────────────────────────────────────────────────────┐
│                       سمت نوشتن                           │
│  Command ──▶ Handler ──▶ Aggregate ──▶ Event Store       │
└──────────────────────────────────┬────────────────────────┘
                                   │
                                   │ رویدادها منتشر می‌شوند
                                   │
         ┌─────────────────────────┼─────────────────────┐
         │                         │                     │
         ▼                         ▼                     ▼
   ┌───────────┐            ┌───────────┐         ┌───────────┐
   │  SQL DB   │            │  Search   │         │  Cache    │
   │ (گزارشات) │            │  Index    │         │ (Redis)   │
   └───────────┘            └───────────┘         └───────────┘
         ▲                         ▲                     ▲
         └─────────────────────────┴─────────────────────┘
                          سمت خواندن
```

### معماری رویداد-محور

[معماری رویداد-محور](./event-driven-architecture.fa.md) زمینه گسترده‌تری را فراهم می‌کند که Event Sourcing در آن عمل می‌کند. Event Sourcing یکی از چهار الگوی رویداد-محور توصیف‌شده توسط Martin Fowler است، در کنار Event Notification، Event-Carried State Transfer و CQRS.

### رویداد دامنه (Domain Event)

رویدادهای دامنه نمایانگر وقایع مهم در یک زمینه محدود (Bounded Context) هستند. در Event Sourcing، هر تغییر وضعیت یک رویداد دامنه است. Event Store اساساً یک مکانیزم ذخیره‌سازی برای رویدادهای دامنه است.

### الگوی Saga

[الگوی Saga](../distributed-transactions/saga.fa.md) تراکنش‌های توزیع‌شده را در چندین سرویس هماهنگ می‌کند. هنگام استفاده از Event Sourcing، انتقال‌های وضعیت saga به طور طبیعی به عنوان رویداد مدل می‌شوند و اقدامات جبرانی رویدادهای جبرانی تولید می‌کنند.

### دو مرحله‌ای تایید (Two-Phase Commit)

[دو مرحله‌ای تایید](../distributed-transactions/two-phase-commit.fa.md) یک رویکرد جایگزین برای دستیابی به اتمی بودن در سیستم‌های توزیع‌شده است. Event Sourcing مشکل نوشتن دوگانه را با تبدیل رویدادها به تنها منبع حقیقت حذف می‌کند و در بسیاری از موارد نیاز به 2PC را از بین می‌برد.

### نقشه روابط الگوها

```
                        Event Sourcing
                              │
            ┌─────────────────┼─────────────────┐
            │                 │                 │
            ▼                 ▼                 ▼
         CQRS            معماری             الگوی Saga
     (مدل‌های خواندن    رویداد-محور       (تراکنش‌های
      از رویدادها)      (زمینه گسترده‌تر)  توزیع‌شده
            │                 │              از طریق رویدادها)
            │                 │                 │
            ▼                 ▼                 ▼
      پروجکشن‌ها         رویدادهای دامنه   رویدادهای
      اسنپ‌شات‌ها        واسط رویداد       جبرانی
      پایگاه‌های خواندن  Pub/Sub
```

---

## ۸. استفاده در دنیای واقعی

### سیستم‌های مالی

Event Sourcing از اصول حسابداری نشأت گرفته و همچنان به شدت در سیستم‌های مالی استفاده می‌شود.

**دفاتر بانکی**: هر تراکنش (واریز، برداشت، انتقال، کارمزد) یک رویداد است. مانده حساب‌ها از جریان رویداد محاسبه می‌شود. نهادهای نظارتی می‌توانند هر تغییر را حسابرسی کنند. بانک‌ها می‌توانند وضعیت حساب را در هر تاریخ تاریخی بازسازی کنند.

**پلتفرم‌های معاملاتی**: صرافی **LMAX** یکی از مشهورترین پیاده‌سازی‌های Event Sourcing است. این صرافی ۶ میلیون تراکنش در ثانیه را با استفاده از یک معماری Event Sourced تک‌ریسمانی پردازش می‌کند. رویدادها رکورد اصلی همه معاملات هستند و وضعیت دفتر سفارش با بازپخش رویدادها بازسازی می‌شود.

```
معماری LMAX (ساده‌شده)
┌──────────┐    ┌──────────────────────┐    ┌──────────────┐
│ سفارشات  │───▶│  پردازشگر منطق     │───▶│  ژورنال      │
│  (ورودی) │    │  کسب‌وکار           │    │  رویداد      │
└──────────┘    │  (تک ریسمان)        │    │  (الحاقی     │
                │  - تطبیق سفارشات    │    │   فقط-دیسک)  │
                │  - به‌روزرسانی موقعیت│    └──────────────┘
                │  - بررسی ریسک       │           │
                └──────────────────────┘           │
                                                   ▼
                                            ┌──────────────┐
                                            │ تکرار به     │
                                            │ گره‌های دیگر │
                                            └──────────────┘
```

### بهداشت و درمان

پرونده‌های پزشکی بیماران به شدت از Event Sourcing بهره می‌برند:

- هر تشخیص، نسخه، نتیجه آزمایشگاه و روش درمانی یک رویداد است
- تاریخچه پزشکی کامل و تغییرناپذیر برای هر بیمار
- پرس‌وجوهای زمانی: «بیمار در ماه مارس چه داروهایی مصرف می‌کرد؟»
- انطباق قانونی (HIPAA) با ردیابی حسابرسی غیرقابل دستکاری
- توانایی تولید گزارشات با اثر قهقرایی از داده‌های تاریخی

### پلتفرم‌های شرط‌بندی

پلتفرم‌های شرط‌بندی ورزشی مانند **Betfair** و **William Hill** از Event Sourcing استفاده می‌کنند برای:

- ثبت هر شرط‌بندی، تسویه و برداشت زودهنگام به عنوان رویداد
- ردیابی حسابرسی برای انطباق قانونی (مقررات قمار)
- محاسبه شانس بلادرنگ با پروجکت کردن رویدادهای شرط‌بندی
- تحلیل تاریخی الگوهای شرط‌بندی

### تجارت الکترونیک و موجودی

پلتفرم‌های بزرگ تجارت الکترونیک از Event Sourcing استفاده می‌کنند برای:

- مدیریت موجودی (هر تغییر موجودی یک رویداد است)
- ردیابی چرخه عمر سفارش (ایجاد، پرداخت، ارسال، تحویل، بازگشت)
- تحلیل رفتار سبد خرید
- تاریخچه قیمت و ردیابی تغییرات

### پیاده‌سازی‌های Event Store

| فناوری | نوع | زبان / پلتفرم | ویژگی‌های کلیدی |
|--------|-----|---------------|-----------------|
| **EventStoreDB** | Event Store اختصاصی | چند-پلتفرمی | ساخته شده توسط Greg Young؛ پروجکشن‌ها، اشتراک‌ها و خوشه‌بندی بومی |
| **Axon Framework** | فریم‌ورک + سرور | Java / JVM | فریم‌ورک کامل CQRS+ES؛ Axon Server برای ذخیره‌سازی و مسیریابی رویداد |
| **Marten** | کتابخانه بر PostgreSQL | .NET / C# | از PostgreSQL به عنوان Event Store استفاده می‌کند؛ یکپارچه با اکوسیستم .NET |
| **Apache Kafka** | پلتفرم جریان رویداد | چند-پلتفرمی | Event Store واقعی نیست اما به طور گسترده استفاده می‌شود؛ نیاز به طراحی دقیق جریان دارد |
| **AWS EventBridge** | گذرگاه رویداد مدیریت‌شده | AWS | مسیریابی رویداد بدون‌سرور؛ یکپارچه با سرویس‌های AWS |
| **Eventuous** | کتابخانه | .NET / C# | کتابخانه سبک ES با پشتیبانی از چندین بک‌اند ذخیره‌سازی |

### چه زمانی از کدام Event Store استفاده کنیم

```
EventStoreDB را انتخاب کنید وقتی:
├─ Event Sourcing الگوی اصلی است
├─ به پروجکشن‌ها و اشتراک‌های داخلی نیاز دارید
└─ یک راه‌حل اختصاصی می‌خواهید

Axon Framework را انتخاب کنید وقتی:
├─ اکوسیستم Java / Spring Boot
├─ به فریم‌ورک کامل CQRS + Event Sourcing نیاز دارید
└─ پشتیبانی داخلی saga می‌خواهید

Marten را انتخاب کنید وقتی:
├─ اکوسیستم .NET
├─ می‌خواهید از PostgreSQL به عنوان Event Store استفاده کنید
└─ کتابخانه را به سرور جداگانه ترجیح می‌دهید

Kafka را انتخاب کنید وقتی:
├─ از قبل زیرساخت Kafka دارید
├─ جریان رویداد با توان عملیاتی بالا نیاز اصلی است
├─ Event Sourcing ثانویه نسبت به پیام‌رسانی رویداد-محور است
└─ آماده‌اید معناشناسی Event Sourcing را روی آن بسازید
```

---

## ۹. خلاصه

Event Sourcing یک الگوی معماری قدرتمند است که اساساً نحوه تفکر شما درباره مدیریت وضعیت را تغییر می‌دهد. به جای ذخیره وضعیت فعلی، تاریخچه کامل تغییرات وضعیت را به عنوان رویدادهای تغییرناپذیر ذخیره می‌کنید. وضعیت فعلی همیشه با بازپخش رویدادها قابل استخراج است.

### نکات کلیدی

1. **رویدادها منبع حقیقت هستند** -- Event Store رکورد اصلی است؛ همه نمایش‌های دیگر مشتق‌شده هستند.

2. **فقط-الحاقی و تغییرناپذیر** -- رویدادها هرگز به‌روزرسانی یا حذف نمی‌شوند و یک ردیابی حسابرسی طبیعی فراهم می‌کنند و پرس‌وجوهای زمانی را ممکن می‌سازند.

3. **بازسازی وضعیت با بازپخش** -- جریان رویداد یک Aggregate را بارگذاری و رویدادها را به ترتیب اعمال کنید تا وضعیت فعلی ساخته شود. از اسنپ‌شات‌ها برای بهینه‌سازی Aggregate‌های طولانی‌عمر استفاده کنید.

4. **حل مشکل نوشتن دوگانه** -- از آنجا که رویدادها خود تغییر وضعیت هستند، مشکل جداگانه «به‌روزرسانی وضعیت سپس انتشار رویداد» وجود ندارد. این به طور طبیعی با [CQRS](../data-patterns/cqrs.fa.md) برای پروجکشن‌های مدل خواندن جفت می‌شود.

5. **تکامل اسکیمای رویداد دشوار است** -- از ابتدا با استفاده از استراتژی‌های Upcasting، نسخه‌بندی یا اسکیمای ضعیف برای آن برنامه‌ریزی کنید.

6. **برای هر سیستمی مناسب نیست** -- پیچیدگی اضافه‌شده فقط زمانی توجیه‌پذیر است که واقعاً به ردیابی‌های حسابرسی، پرس‌وجوهای زمانی یا یکپارچه‌سازی قابل اطمینان مبتنی بر رویداد نیاز داشته باشید. سیستم‌های CRUD ساده باید ساده بمانند.

7. **اثبات‌شده در دنیای واقعی** -- سیستم‌های مالی (صرافی LMAX)، بهداشت و درمان، پلتفرم‌های شرط‌بندی و سیستم‌های تجارت الکترونیک در مقیاس بزرگ به دلیل قابلیت حسابرسی و قابلیت اطمینان به Event Sourcing تکیه می‌کنند.

### چک‌لیست تصمیم‌گیری

قبل از پذیرش Event Sourcing، تأیید کنید که:

- [ ] نیاز واقعی به ردیابی حسابرسی کامل دارید
- [ ] پرس‌وجوهای زمانی یک نیاز کسب‌وکار است
- [ ] سازگاری نهایی برای خواندن قابل قبول است
- [ ] تیم شما الگو و پیامدهای آن را درک می‌کند
- [ ] برنامه‌ای برای تکامل اسکیمای رویداد دارید
- [ ] استراتژی اسنپ‌شات برای Aggregate‌های طولانی‌عمر را در نظر گرفته‌اید
- [ ] درک می‌کنید که این چگونه با معماری گسترده‌تر شما (CQRS، رویداد-محور) سازگار است
- [ ] پیچیدگی با نیازمندی‌های کسب‌وکار توجیه می‌شود

### مطالعه بیشتر

**کتاب‌ها**:
- "Implementing Domain-Driven Design" نوشته Vaughn Vernon (فصل Event Sourcing)
- "Designing Data-Intensive Applications" نوشته Martin Kleppmann (فصل ۱۱: پردازش جریان)
- "Building Event-Driven Microservices" نوشته Adam Bellemare
- "Versioning in an Event Sourced System" نوشته Greg Young

**منابع**:
- سخنرانی‌های Greg Young درباره Event Sourcing و CQRS
- مستندات و آموزش‌های EventStoreDB
- Martin Fowler: توضیح الگوی «Event Sourcing»
- microservices.io: الگوی Event Sourcing

---

**ناوبری**:
- قبلی: [معماری رویداد-محور](./event-driven-architecture.fa.md)
- بعدی: [الگوی CQRS](../data-patterns/cqrs.fa.md)
- مرتبط: [الگوی Saga](../distributed-transactions/saga.fa.md)، [دو مرحله‌ای تایید](../distributed-transactions/two-phase-commit.fa.md)، [قضیه CAP](../fundamentals/cap-theorem.fa.md)
