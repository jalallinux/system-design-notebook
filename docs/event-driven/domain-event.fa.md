# رویداد دامنه (Domain Event)

## ۱. مقدمه

**رویداد دامنه** یک رکورد از چیز مهمی است که در دامنه اتفاق افتاده است. این رویداد واقعیت تغییر وضعیت معنادار در یک بافت محدود (Bounded Context) را ثبت می‌کند. مثال‌هایی شامل `OrderPlaced` (سفارش ثبت شد)، `CustomerRegistered` (مشتری ثبت‌نام کرد)، `PaymentReceived` (پرداخت دریافت شد) و `InventoryReserved` (موجودی رزرو شد) هستند.

این مفهوم از **طراحی دامنه-محور (DDD)** نشأت می‌گیرد که توسط Eric Evans در کتاب بنیادین‌اش معرفی شد و بعداً توسط Vaughn Vernon در کتاب "Implementing Domain-Driven Design" گسترش یافت. رویدادهای دامنه پلی بین مدل دامنه و سایر بخش‌های سیستم ایجاد می‌کنند و روشی ساختاریافته برای انتقال تغییرات وضعیت در مرزهای سرویس فراهم می‌کنند.

### ایده اصلی

```
چیز مهمی در دامنه ما اتفاق افتاد.
ما آن را به عنوان یک واقعیت تغییرناپذیر ثبت می‌کنیم.
سایر بخش‌های سیستم می‌توانند به آن واکنش نشان دهند.
```

### ویژگی‌های رویداد دامنه

| ویژگی | توضیح |
|--------|-------|
| **تغییرناپذیر** | پس از ایجاد، یک رویداد دامنه قابل تغییر نیست |
| **زمان گذشته** | با زمان گذشته نام‌گذاری می‌شود (OrderPlaced، نه PlaceOrder) |
| **معنادار** | نشان‌دهنده یک رخداد تجاری مهم است |
| **خودکفا** | داده کافی برای واکنش مصرف‌کنندگان را حمل می‌کند |
| **دارای برچسب زمانی** | زمان وقوع رویداد را ثبت می‌کند |

### رویداد دامنه در مقابل دستور (Command)

```
┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│  Command (دستوری):    PlaceOrder, RegisterCustomer               │
│  ──────────────────────────────────────────────────────────────  │
│  قصد انجام کاری. ممکن است رد شود.                               │
│                                                                  │
│  Domain Event (گذشته):  OrderPlaced, CustomerRegistered          │
│  ──────────────────────────────────────────────────────────────  │
│  واقعیتی که قبلاً رخ داده. قابل بازگشت نیست.                    │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

## ۲. زمینه و مسئله

در یک [معماری میکروسرویس](../architecture/microservices.md)، هر سرویس مالک داده‌های خود است و منطق کسب‌وکار خود را در یک بافت محدود کپسوله می‌کند. این استقلال یک نقطه قوت است، اما چالشی بنیادی ایجاد می‌کند: **سایر سرویس‌ها چگونه از تغییراتی که در دامنه یک سرویس دیگر رخ داده مطلع می‌شوند؟**

### چالش

```
┌───────────────┐          ┌───────────────┐          ┌───────────────┐
│  Order        │          │  Inventory    │          │  Notification  │
│  Service      │          │  Service      │          │  Service       │
│               │          │               │          │                │
│  سفارش ثبت   │   ???    │  نیاز به      │   ???    │  نیاز به       │
│  شد           │─────────▶│  رزرو         │─────────▶│  ارسال ایمیل   │
│               │          │  موجودی       │          │  به مشتری      │
└───────────────┘          └───────────────┘          └───────────────┘

مسئله: سرویس موجودی چگونه می‌فهمد سفارشی ثبت شده؟
       سرویس اعلان چگونه می‌فهمد باید ایمیل بفرستد؟
```

**اتصال مستقیم** (فراخوانی‌های همزمان) سرویس‌ها را شکننده و به شدت وابسته می‌کند. اگر سرویس اعلان از کار بیفتد، آیا سرویس سفارش باید شکست بخورد؟ مسلماً نه. عمل ثبت سفارش یک واقعیت دامنه‌ای است که سایر سرویس‌ها باید بتوانند به طور مستقل به آن واکنش نشان دهند.

## ۳. نیروها (Forces)

چندین نیرو نیاز به رویدادهای دامنه را شکل می‌دهند:

- **اتصال سست**: سرویس‌ها باید مستقل بمانند. تغییر در یک سرویس نباید نیاز به تغییر در سایرین داشته باشد.
- **اطلاع‌رسانی قابل اعتماد**: وقتی اتفاق مهمی می‌افتد، طرف‌های ذینفع باید به طور قابل اعتماد مطلع شوند، حتی اگر موقتاً در دسترس نباشند.
- **مصرف‌کنندگان متعدد**: یک رویداد ممکن است برای مصرف‌کنندگان زیادی مرتبط باشد. موجودی باید کالا رزرو کند، پرداخت باید مشتری را شارژ کند و تحلیل‌ها باید فروش را ثبت کنند.
- **جداسازی زمانی**: تولیدکننده و مصرف‌کنندگان نیازی به آنلاین بودن همزمان ندارند.
- **مسیر حسابرسی**: تغییرات حیاتی کسب‌وکار باید برای انطباق، اشکال‌زدایی و تحلیل‌ها قابل ردیابی باشند.
- **قابلیت گسترش**: اضافه کردن واکنش‌های جدید به تغییرات دامنه نباید نیاز به تغییر سرویس مبدأ داشته باشد.
- **شفافیت دامنه**: مدل دامنه باید بیان کند چه چیزی در کسب‌وکار مهم است، از جمله رویدادهایی که اهمیت دارند.

## ۴. راه‌حل

راه‌حل این است که **هر زمان تغییرات وضعیت معنادار در مدل دامنه رخ می‌دهد، رویدادهای دامنه منتشر شوند**. هر رویداد نشان‌دهنده واقعیتی درباره اتفاقی است که افتاده، و مصرف‌کنندگان علاقه‌مند در این رویدادها مشترک می‌شوند و بر اساس آن‌ها واکنش نشان می‌دهند.

### ساختار رویداد

یک رویداد دامنه خوب طراحی شده، تمام اطلاعاتی که یک مصرف‌کننده برای درک اتفاق نیاز دارد را شامل می‌شود.

```
┌──────────────────────────────────────────────────┐
│                Domain Event                       │
├──────────────────────────────────────────────────┤
│  eventId:       "evt-a1b2c3d4"                   │
│  eventType:     "OrderPlaced"                    │
│  timestamp:     "2026-02-06T14:30:00Z"           │
│  aggregateId:   "order-98765"                    │
│  aggregateType: "Order"                          │
│  version:       1                                │
│  payload: {                                      │
│      orderId:    "order-98765",                  │
│      customerId: "cust-111",                     │
│      items: [                                    │
│          { productId: "P-1", qty: 2 },           │
│          { productId: "P-5", qty: 1 }            │
│      ],                                          │
│      totalAmount: 249.99,                        │
│      currency:    "USD"                          │
│  }                                               │
│  metadata: {                                     │
│      correlationId: "req-xyz789",                │
│      causationId:   "cmd-place-order-123",       │
│      userId:        "user-42"                    │
│  }                                               │
└──────────────────────────────────────────────────┘
```

### مرجع فیلدهای رویداد

| فیلد | هدف | مثال |
|------|-----|------|
| `eventId` | شناسه یکتا برای حذف تکراری‌ها | `"evt-a1b2c3d4"` |
| `eventType` | چه اتفاقی افتاد (زمان گذشته) | `"OrderPlaced"` |
| `timestamp` | زمان وقوع رویداد | `"2026-02-06T14:30:00Z"` |
| `aggregateId` | رویداد متعلق به کدام موجودیت است | `"order-98765"` |
| `aggregateType` | نوع ریشه تجمیع (Aggregate Root) | `"Order"` |
| `version` | نسخه اسکیما برای تکامل | `1` |
| `payload` | داده‌های تجاری درباره رویداد | `{ orderId, items, ... }` |
| `metadata` | داده‌های ردیابی و عملیاتی | `{ correlationId, userId }` |

### قراردادهای نام‌گذاری رویداد

رویدادهای دامنه باید همیشه با **زمان گذشته** نام‌گذاری شوند، که نشان‌دهنده توصیف واقعیت‌ها هستند.

| صحیح (زمان گذشته) | نادرست (دستوری) |
|-------------------|----------------|
| `OrderPlaced` | `PlaceOrder` |
| `PaymentReceived` | `ReceivePayment` |
| `CustomerRegistered` | `RegisterCustomer` |
| `InventoryReserved` | `ReserveInventory` |
| `ShipmentDispatched` | `DispatchShipment` |

### دانه‌بندی رویداد

انتخاب سطح مناسب جزئیات در رویدادها یک تصمیم طراحی مهم است.

```
رویداد درشت‌دانه (Coarse-Grained):
┌───────────────────────────────────────────┐
│  OrderUpdated                             │
│  payload: { کل شیء سفارش }               │
│                                           │
│  + انتشار ساده                            │
│  + تعداد کمتر انواع رویداد                │
│  - مصرف‌کنندگان باید تفاوت‌ها را پیدا کنند│
│  - حجم بارگذاری بزرگ‌تر                   │
└───────────────────────────────────────────┘

رویدادهای ریزدانه (Fine-Grained):
┌───────────────────────────────────────────┐
│  OrderItemAdded                           │
│  OrderItemRemoved                         │
│  OrderShippingAddressChanged              │
│  OrderDiscountApplied                     │
│                                           │
│  + مصرف‌کنندگان دقیقاً می‌دانند چه تغییر کرد│
│  + حجم بارگذاری کمتر به ازای هر رویداد    │
│  - انواع رویداد بیشتر برای مدیریت          │
│  - منطق انتشار پیچیده‌تر                   │
└───────────────────────────────────────────┘

توصیه: رویدادهای ریزدانه که به اقدامات تجاری
معنادار نگاشت می‌شوند ترجیح داده می‌شوند.
```

### انتشار رویدادهای دامنه

رویدادهای دامنه می‌توانند از دو مکان در معماری برنامه منتشر شوند:

**گزینه الف: از درون Aggregateها (رویکرد خالص DDD)**

```
┌──────────────────────────────────────────────────────────┐
│  Order Aggregate                                          │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  place(customerId, items):                               │
│      اعتبارسنجی قوانین کسب‌وکار                          │
│      به‌روزرسانی وضعیت داخلی                              │
│      ثبت رویداد: OrderPlaced { ... }                     │
│                                                          │
│  cancel(reason):                                         │
│      اعتبارسنجی: فقط اگر ارسال نشده قابل لغو است        │
│      به‌روزرسانی وضعیت به CANCELLED                       │
│      ثبت رویداد: OrderCancelled { reason }               │
│                                                          │
│  uncommittedEvents: [ ... ]                              │
│      (در طول عملیات جمع‌آوری می‌شوند، پس از                │
│       ذخیره aggregate منتشر می‌شوند)                      │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

**گزینه ب: از سرویس‌های کاربردی (Application Services)**

```
┌──────────────────────────────────────────────────────────┐
│  OrderApplicationService                                  │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  placeOrder(command):                                    │
│      order = Order.place(command.customerId, ...)        │
│      orderRepository.save(order)                         │
│      eventPublisher.publish(OrderPlaced { ... })         │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### جریان رویداد دامنه

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   Aggregate  │    │  Application │    │   Event      │
│   (Domain    │───▶│  Service     │───▶│   Publisher  │
│    Model)    │    │              │    │              │
└──────────────┘    └──────────────┘    └──────┬───────┘
                                               │
                                               │ انتشار
                                               ▼
                                        ┌──────────────┐
                                        │   Message    │
                                        │   Broker     │
                                        └──────┬───────┘
                                               │
                              ┌────────────────┼────────────────┐
                              │                │                │
                              ▼                ▼                ▼
                       ┌────────────┐   ┌────────────┐   ┌────────────┐
                       │ Inventory  │   │  Payment   │   │ Notification│
                       │ Service    │   │  Service   │   │  Service    │
                       └────────────┘   └────────────┘   └────────────┘
```

### انتشار تضمین‌شده با Transactional Outbox

یک چالش حیاتی اطمینان از این است که رویداد دامنه **فقط و فقط در صورتی** منتشر شود که تغییر وضعیت در پایگاه داده commit شده باشد. اگر برنامه سفارش را ذخیره کند اما قبل از انتشار رویداد از کار بیفتد، سیستم ناسازگار می‌شود.

راه‌حل الگوی [Transactional Outbox](../messaging/transactional-outbox.md) است: نوشتن رویداد در یک جدول outbox در **همان تراکنش پایگاه داده** به همراه تغییر وضعیت، سپس یک فرآیند جداگانه outbox را می‌خواند و رویدادها را به واسطه پیام منتشر می‌کند.

```
┌────────────────────────────────────────────────────────────┐
│                   تراکنش واحد پایگاه داده                   │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  1. INSERT INTO orders (id, status, ...) VALUES (...)      │
│  2. INSERT INTO outbox (event_id, event_type, payload)     │
│     VALUES ('evt-123', 'OrderPlaced', '{...}')             │
│                                                            │
│  COMMIT;   (هر دو موفق می‌شوند یا هر دو شکست می‌خورند)   │
│                                                            │
└────────────────────────────────────────────────────────────┘
         │
         │  Outbox Relay (نظرسنجی یا CDC)
         ▼
┌──────────────┐         ┌──────────────┐
│   Outbox     │────────▶│   Message    │
│   Table      │ انتشار  │   Broker     │
└──────────────┘         └──────────────┘
```

### رویدادهای دامنه در مقابل رویدادهای یکپارچه‌سازی

یک تمایز مهم در میکروسرویس‌ها بین رویدادهای دامنه (داخلی) و رویدادهای یکپارچه‌سازی (خارجی) است.

| جنبه | رویداد دامنه | رویداد یکپارچه‌سازی |
|------|-------------|---------------------|
| **محدوده** | درون یک بافت محدود | بین بافت‌های محدود / سرویس‌ها |
| **مخاطب** | هندلرهای داخلی در همان سرویس | میکروسرویس‌های خارجی |
| **اتصال** | اتصال تنگاتنگ با مدل داخلی | انتزاعی، قرارداد پایدار |
| **اسکیما** | می‌تواند آزادانه تغییر کند | باید با دقت نسخه‌بندی شود |
| **انتقال** | گذرگاه رویداد درون-فرآیندی یا outbox | واسطه پیام (Kafka، RabbitMQ) |
| **مثال** | `OrderItemAdded` (جزئیات داخلی) | `OrderPlaced` (قرارداد عمومی) |

```
┌─────────────────────────────────────────────────────────────┐
│  Order Service (بافت محدود)                                  │
│                                                             │
│  رویدادهای دامنه (داخلی):                                   │
│    OrderItemAdded                                           │
│    OrderItemRemoved                                         │
│    OrderTotalRecalculated                                   │
│    OrderValidated                                           │
│         │                                                   │
│         ▼                                                   │
│  لایه ضد خرابکاری / نگاشتگر                                │
│         │                                                   │
│         ▼                                                   │
│  رویداد یکپارچه‌سازی (عمومی):                               │
│    OrderPlaced { orderId, customerId, total, items }        │
│                                                             │
└─────────────────────────────────┬───────────────────────────┘
                                  │
                                  ▼
                           Message Broker
                                  │
                    ┌─────────────┼─────────────┐
                    ▼             ▼             ▼
              Inventory      Payment      Notification
              Service        Service        Service
```

## ۵. مثال

### تجارت الکترونیک: رویداد OrderPlaced

یک پلتفرم تجارت الکترونیک را در نظر بگیرید که ثبت سفارش واکنش‌های متعدد پایین‌دستی را فعال می‌کند.

**مرحله ۱: مشتری سفارش می‌دهد**

```
Customer ───▶ Order Service
                   │
                   │  1. اعتبارسنجی سفارش
                   │  2. ذخیره در پایگاه داده
                   │  3. انتشار رویداد OrderPlaced
                   │
                   ▼
            ┌──────────────┐
            │ OrderPlaced  │
            │ {            │
            │   orderId:   │
            │     "O-500", │
            │   customer:  │
            │     "C-42",  │
            │   items: [   │
            │     {P-1, 2},│
            │     {P-3, 1} │
            │   ],         │
            │   total:     │
            │     $185.00  │
            │ }            │
            └──────┬───────┘
                   │
                   ▼
            Message Broker
```

**مرحله ۲: مصرف‌کنندگان متعدد به طور مستقل واکنش نشان می‌دهند**

```
                        Message Broker
                             │
              ┌──────────────┼──────────────┬──────────────┐
              ▼              ▼              ▼              ▼
       ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐
       │ Inventory  │ │  Payment   │ │   Email    │ │ Analytics  │
       │ Service    │ │  Service   │ │  Service   │ │  Service   │
       ├────────────┤ ├────────────┤ ├────────────┤ ├────────────┤
       │ رزرو       │ │ شارژ روش  │ │ ارسال      │ │ ثبت فروش  │
       │ موجودی     │ │ پرداخت    │ │ ایمیل      │ │ در         │
       │ اقلام P-1  │ │ مشتری     │ │ تأیید      │ │ داشبورد    │
       │ و P-3      │ │            │ │ سفارش      │ │            │
       │            │ │            │ │ به C-42    │ │            │
       └────────────┘ └────────────┘ └────────────┘ └────────────┘
              │              │
              ▼              ▼
       InventoryReserved  PaymentProcessed
       (رویدادهای جدید)   (رویدادهای جدید)
```

**مرحله ۳: رویدادهای پایین‌دستی واکنش‌های بیشتری را فعال می‌کنند**

```
PaymentProcessed ───▶ Order Service ───▶ به‌روزرسانی وضعیت سفارش به PAID
                 ───▶ Accounting Service ───▶ ثبت درآمد

InventoryReserved ───▶ Warehouse Service ───▶ آماده‌سازی لیست برداشت
                  ───▶ Order Service ───▶ به‌روزرسانی وضعیت تحویل
```

این زنجیره رویدادها یک [Saga](../distributed-transactions/saga.md) تشکیل می‌دهد که تراکنش توزیع‌شده را بدون اتصال تنگاتنگ هماهنگ می‌کند.

### جبران در صورت شکست

اگر سرویس پرداخت نتواند مشتری را شارژ کند:

```
PaymentFailed { orderId: "O-500", reason: "موجودی ناکافی" }
       │
       ├───▶ Inventory Service ───▶ آزادسازی موجودی رزرو شده
       │                           (رویداد InventoryReleased)
       │
       ├───▶ Order Service ───▶ علامت‌گذاری سفارش به عنوان CANCELLED
       │                        (رویداد OrderCancelled)
       │
       └───▶ Email Service ───▶ ارسال اعلان لغو به مشتری
```

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیح |
|------|-------|
| **اتصال سست** | تولیدکننده مصرف‌کنندگان را نمی‌شناسد و به آن‌ها وابسته نیست. مصرف‌کنندگان جدید بدون تغییر تولیدکننده اضافه می‌شوند. |
| **قابلیت گسترش** | با اضافه کردن مشترکین جدید به تغییرات دامنه واکنش نشان دهید، نه با تغییر کد منبع. |
| **مسیر حسابرسی** | هر تغییر وضعیت مهم به عنوان رویداد ثبت می‌شود و قابلیت ردیابی و انطباق را فراهم می‌کند. |
| **فعال‌سازی EDA** | رویدادهای دامنه پایه و اساس [معماری رویداد-محور](./event-driven-architecture.md) هستند. |
| **پشتیبانی از CQRS** | رویدادها می‌توانند پروجکشن‌های مدل خواندن را در یک سیستم [CQRS](../data-patterns/cqrs.md) تغذیه کنند. |
| **پشتیبانی از Event Sourcing** | رویدادهای دامنه می‌توانند به عنوان منبع حقیقت در سیستم [Event Sourcing](./event-sourcing.md) عمل کنند. |
| **جداسازی زمانی** | تولیدکننده و مصرف‌کنندگان نیازی به آنلاین بودن همزمان ندارند. |
| **شفافیت دامنه** | نام‌گذاری و مدل‌سازی رویدادها زبان دامنه را صریح می‌کند. |

### معایب

| عیب | توضیح |
|-----|-------|
| **سازگاری نهایی** | مصرف‌کنندگان رویدادها را به صورت ناهمزمان پردازش می‌کنند، بنابراین سیستم موقتاً ناسازگار است. مرتبط با [قضیه CAP](../fundamentals/cap-theorem.md). |
| **تکامل اسکیمای رویداد** | تغییر ساختار رویداد نیاز به نسخه‌بندی دقیق و سازگاری عقب‌گرد دارد. |
| **پیچیدگی اشکال‌زدایی** | ردیابی یک درخواست در جریان‌های رویداد ناهمزمان سخت‌تر از ردیابی فراخوانی‌های همزمان است. |
| **چالش‌های ترتیب** | تضمین ترتیب سراسری رویدادها گران است؛ معمولاً فقط ترتیب سطح پارتیشن امکان‌پذیر است. |
| **تحویل تکراری** | تحویل حداقل-یک‌بار به این معناست که مصرف‌کنندگان باید ایدمپوتنت (بی‌اثر) باشند. |
| **سربار زیرساخت** | نیاز به واسطه پیام، نظارت، صف‌های نامه مرده و ابزارهای عملیاتی دارد. |
| **خطر مهندسی بیش از حد** | برای برنامه‌های ساده، رویدادهای دامنه پیچیدگی غیرضروری اضافه می‌کنند. |

## ۷. الگوهای مرتبط

رویدادهای دامنه به بسیاری از الگوها در اکوسیستم طراحی سیستم متصل هستند:

**۱. معماری رویداد-محور**

رویدادهای دامنه بلوک‌های ساختمانی [معماری رویداد-محور](./event-driven-architecture.md) هستند. EDA زیرساخت و الگوهایی برای تولید، مسیریابی و مصرف رویدادها در مقیاس فراهم می‌کند.

**۲. Event Sourcing**

در [Event Sourcing](./event-sourcing.md)، رویدادهای دامنه منبع حقیقت می‌شوند. به جای ذخیره فقط وضعیت فعلی، هر تغییر وضعیت به عنوان رویداد ذخیره می‌شود و وضعیت فعلی با بازپخش رویدادها بازسازی می‌شود.

**۳. CQRS**

[CQRS](../data-patterns/cqrs.md) مدل‌های خواندن و نوشتن را جدا می‌کند. رویدادهای دامنه اغلب برای همگام‌سازی مدل نوشتن با یک یا چند پروجکشن بهینه‌شده برای خواندن استفاده می‌شوند.

**۴. الگوی Saga**

[الگوی Saga](../distributed-transactions/saga.md) تراکنش‌های توزیع‌شده را از طریق دنباله‌ای از رویدادهای دامنه و اقدامات جبرانی در چندین سرویس هماهنگ می‌کند.

**۵. Transactional Outbox**

الگوی [Transactional Outbox](../messaging/transactional-outbox.md) تضمین می‌کند که رویدادهای دامنه به طور قابل اعتماد با نوشتن آن‌ها در یک جدول outbox در همان تراکنش پایگاه داده به همراه تغییر وضعیت منتشر شوند.

**روابط الگوها**:

```
                        Domain Event
                             │
           ┌─────────────────┼─────────────────┐
           │                 │                 │
           ▼                 ▼                 ▼
    Event-Driven        Event Sourcing       CQRS
    Architecture              │                │
           │                  │                │
           │            ┌─────┴─────┐    ┌─────┴─────┐
           ▼            ▼           ▼    ▼           ▼
    Saga Pattern    Snapshots   Temporal  Read      Write
                                Queries  Models    Models
           │
           ▼
    Transactional
    Outbox
```

## ۸. استفاده در دنیای واقعی

### پذیرش صنعتی

رویدادهای دامنه به طور گسترده در میکروسرویس‌های تولیدی استفاده می‌شوند:

| شرکت | کاربرد |
|-------|--------|
| **Amazon** | رویدادهای چرخه عمر سفارش، خدمات انبار، پرداخت، حمل‌ونقل و اعلان را به طور مستقل هدایت می‌کنند. |
| **Netflix** | رویدادهای فعالیت کاربر (مشاهده، توقف، امتیازدهی) سیستم‌های پیشنهاد، تحلیل و صورتحساب را تغذیه می‌کنند. |
| **Uber** | رویدادهای چرخه عمر سفر (درخواست، تطبیق، شروع، تکمیل) سرویس‌های راننده، مسافر، پرداخت و نقشه را هماهنگ می‌کنند. |
| **Shopify** | رویدادهای سفارش، محصول و موجودی اکوسیستم فروشنده و ادغام‌های شخص ثالث را از طریق webhookها قدرت می‌بخشند. |
| **Stripe** | رویدادهای چرخه عمر پرداخت (charge.succeeded، invoice.paid) ستون فقرات سیستم webhook آن‌ها هستند. |

### انتخاب‌های رایج فناوری

| فناوری | نقش |
|--------|-----|
| **Apache Kafka** | جریان رویداد توزیع‌شده با ماندگاری و بازپخش. ایده‌آل برای رویدادهای دامنه با توان عملیاتی بالا. |
| **RabbitMQ** | واسطه پیام عمومی با مسیریابی انعطاف‌پذیر. مناسب برای رویدادهای وظیفه‌محور و اعلان. |
| **AWS EventBridge** | گذرگاه رویداد بدون‌سرور برای مسیریابی رویداد در سرویس‌های AWS و ادغام‌های SaaS. |
| **Azure Event Grid** | سرویس مسیریابی رویداد در اکوسیستم Azure. |
| **Axon Framework** | فریم‌ورک Java ساخته‌شده برای DDD، CQRS و Event Sourcing با پشتیبانی درجه یک از رویداد دامنه. |

برای مقایسه دقیق فناوری‌های پیام‌رسانی، به [مقایسه RabbitMQ و Kafka](../messaging/rabbitmq-vs-kafka.md) مراجعه کنید.

### ملاحظات طراحی در عمل

**۱. اسکیماهای رویداد و رجیستری‌ها**

در سیستم‌های بزرگ، یک رجیستری اسکیما (مانند Confluent Schema Registry برای Kafka) ساختار رویداد و قوانین سازگاری را اعمال می‌کند. این کار از انتشار تغییرات شکننده توسط تولیدکنندگان جلوگیری می‌کند.

**۲. شناسه‌های همبستگی و علیت**

هر رویداد دامنه باید یک `correlationId` (پیوند دادن آن به درخواست اصلی کاربر) و یک `causationId` (پیوند دادن آن به دستور یا رویدادی که آن را ایجاد کرده) حمل کند. این امر ردیابی توزیع‌شده را ممکن می‌سازد.

```
Request from User
  correlationId: "req-001"
       │
       ▼
  OrderPlaced
    correlationId: "req-001"
    causationId:   "cmd-place-order"
       │
       ├──▶ PaymentProcessed
       │      correlationId: "req-001"
       │      causationId:   "evt-order-placed"
       │
       └──▶ InventoryReserved
              correlationId: "req-001"
              causationId:   "evt-order-placed"
```

**۳. صف‌های نامه مرده (Dead-Letter Queues)**

وقتی مصرف‌کننده پس از چندین تلاش مجدد نتواند رویدادی را پردازش کند، رویداد به صف نامه مرده منتقل می‌شود تا به صورت دستی بررسی و مجدداً پردازش شود.

**۴. مصرف‌کنندگان ایدمپوتنت**

از آنجا که تحویل حداقل-یک‌بار هنجار است، مصرف‌کنندگان باید رویدادهای تکراری را با بررسی `eventId` قبل از پردازش به شکل مناسب مدیریت کنند.

## ۹. خلاصه

| جنبه | جزئیات |
|------|--------|
| **چیست** | یک رکورد تغییرناپذیر از تغییر وضعیت معنادار در دامنه |
| **منشأ** | طراحی دامنه-محور (Eric Evans، Vaughn Vernon) |
| **نام‌گذاری** | زمان گذشته: `OrderPlaced`، `PaymentReceived` |
| **ساختار** | eventId، eventType، timestamp، aggregateId، payload، metadata |
| **انتشار** | از aggregateها یا سرویس‌های کاربردی، با تحویل تضمین‌شده از طریق Transactional Outbox |
| **مصرف‌کنندگان** | سایر میکروسرویس‌ها، پروجکشن‌های مدل خواندن، سیستم‌های اعلان، تحلیل‌ها |
| **مزیت کلیدی** | اتصال سست و قابلیت گسترش در مرزهای سرویس |
| **چالش کلیدی** | سازگاری نهایی، تکامل اسکیما و اشکال‌زدایی جریان‌های توزیع‌شده |
| **الگوهای مرتبط** | [معماری رویداد-محور](./event-driven-architecture.md)، [Event Sourcing](./event-sourcing.md)، [CQRS](../data-patterns/cqrs.md)، [Saga](../distributed-transactions/saga.md)، [Transactional Outbox](../messaging/transactional-outbox.md) |
| **کی استفاده شود** | میکروسرویس‌هایی که نیاز به واکنش به تغییرات در سرویس‌های دیگر دارند؛ وقتی مسیر حسابرسی، قابلیت گسترش و اتصال سست اولویت هستند |
| **کی استفاده نشود** | برنامه‌های CRUD یکپارچه ساده که فراخوانی‌های همزمان کافی هستند |

### نکات کلیدی

1. **رویدادهای دامنه واقعیت‌های کسب‌وکار را ثبت می‌کنند** به عنوان رکوردهای تغییرناپذیر از آنچه رخ داده
2. **نام‌گذاری با زمان گذشته** رویدادها را خودمستند می‌کند و با زبان فراگیر هم‌راستا می‌شود
3. **انتشار تضمین‌شده** از طریق الگوی Transactional Outbox از ناسازگاری داده جلوگیری می‌کند
4. **رویدادهای دامنه در مقابل رویدادهای یکپارچه‌سازی**: جزئیات مدل داخلی را خصوصی نگه دارید؛ قراردادهای عمومی پایدار منتشر کنید
5. **مصرف‌کنندگان ایدمپوتنت** ضروری هستند زیرا تحویل حداقل-یک‌بار پیش‌فرض عملی است
6. **رویدادهای ریزدانه** که به اقدامات تجاری نگاشت می‌شوند نسبت به رویدادهای درشت‌دانه فراگیر ترجیح داده می‌شوند
7. **پیوند متقابل با سایر الگوها**: رویدادهای دامنه پایه و اساس Event Sourcing، CQRS، Saga و معماری رویداد-محور هستند

### مطالعه بیشتر

**کتاب‌ها**:
- "Domain-Driven Design" نوشته Eric Evans (فصل ۸: رویدادهای دامنه)
- "Implementing Domain-Driven Design" نوشته Vaughn Vernon
- "Building Event-Driven Microservices" نوشته Adam Bellemare
- "Designing Data-Intensive Applications" نوشته Martin Kleppmann

**منابع**:
- Martin Fowler: توصیف الگوی "Domain Event"
- Vaughn Vernon: سلسله مقالات "Modeling Domain Events"
- Microsoft: راهنمای طراحی و پیاده‌سازی رویدادهای دامنه
- مستندات Axon Framework: مدیریت رویداد دامنه

---

**ناوبری**:
- قبلی: [معماری رویداد-محور](./event-driven-architecture.md)
- مرتبط: [CQRS](../data-patterns/cqrs.md)، [الگوی Saga](../distributed-transactions/saga.md)، [Transactional Outbox](../messaging/transactional-outbox.md)، [Event Sourcing](./event-sourcing.md)
