# قضیه CAP

## ۱. مقدمه

**قضیه CAP** (که به نام قضیه بروئر نیز شناخته می‌شود) یکی از بنیادی‌ترین قضایا در سیستم‌های توزیع‌شده است. این قضیه بیان می‌کند که یک ذخیره‌ساز داده توزیع‌شده نمی‌تواند همزمان بیش از دو مورد از سه تضمین زیر را ارائه دهد: **سازگاری (Consistency)**، **دسترس‌پذیری (Availability)** و **تحمل پارتیشن (Partition Tolerance)**. این قضیه ابتدا توسط اریک بروئر در سال ۲۰۰۰ به عنوان حدس مطرح شد و سپس در سال ۲۰۰۲ توسط ست گیلبرت و نانسی لینچ به طور رسمی اثبات شد. قضیه CAP به سنگ بنایی برای درک مصالحه‌های ذاتی در طراحی سیستم‌های توزیع‌شده تبدیل شده است.

درک قضیه CAP برای هر کسی که پایگاه‌داده‌های توزیع‌شده، معماری‌های میکروسرویس یا هر سیستمی که بر روی چندین گره شبکه‌ای کار می‌کند را طراحی یا ارزیابی می‌کند، ضروری است. این قضیه چارچوبی برای استدلال درباره تضمین‌هایی که یک سیستم می‌تواند و نمی‌تواند ارائه دهد، به‌ویژه در سناریوهای خرابی، فراهم می‌کند.

## ۲. سه ویژگی

### سازگاری (Consistency - C)

**تعریف:** یک خواندن تمام نوشتن‌های قبلی تکمیل‌شده را مشاهده می‌کند. هر درخواست خواندن آخرین نوشتن یا یک خطا دریافت می‌کند.

در یک سیستم سازگار، همه گره‌ها داده یکسانی را در یک زمان مشاهده می‌کنند. وقتی یک نوشتن تأیید می‌شود، هر خواندن بعدی از هر گره‌ای در سیستم آن مقدار به‌روزشده را برمی‌گرداند. این گاهی **خطی‌سازی (linearizability)** یا **سازگاری قوی** نامیده می‌شود.

```
کلاینت X=5 را روی گره A می‌نویسد
        |
        v
    [گره A: X=5] ---همانندسازی---> [گره B: X=5] ---همانندسازی---> [گره C: X=5]
        |
کلاینت X را از گره B می‌خواند => مقدار 5 برمی‌گرداند ✓
کلاینت X را از گره C می‌خواند => مقدار 5 برمی‌گرداند ✓
```

**نکات کلیدی:**
- همه گره‌ها بر وضعیت فعلی داده‌ها توافق دارند
- خواندن داده‌های قدیمی امکان‌پذیر نیست
- نوشتن‌ها ممکن است نیاز به هماهنگی بین گره‌ها قبل از تأیید داشته باشند
- قوی‌تر از سازگاری نهایی اما ممکن است تأخیر ایجاد کند

### دسترس‌پذیری (Availability - A)

**تعریف:** هر درخواست (خواندن یا نوشتن) یک پاسخ بدون خطا دریافت می‌کند، بدون تضمین اینکه شامل آخرین نوشتن باشد.

یک سیستم دسترس‌پذیر تضمین می‌کند که هر درخواستی که به یک گره غیرمعیوب ارسال شود، پاسخ دریافت خواهد کرد. سیستم در شرایط نامساعد نیز عملیاتی و پاسخگو باقی می‌ماند. در مفهوم دقیق CAP، دسترس‌پذیری به این معناست که **تمام** گره‌ها می‌توانند در هر زمانی خواندن و نوشتن را سرویس دهند.

```
کلاینت ---درخواست---> [گره A] ---> پاسخ ✓  (همیشه پاسخ می‌دهد)
کلاینت ---درخواست---> [گره B] ---> پاسخ ✓  (همیشه پاسخ می‌دهد)
کلاینت ---درخواست---> [گره C] ---> پاسخ ✓  (همیشه پاسخ می‌دهد)
```

**نکات کلیدی:**
- هر گره غیرمعیوب باید برای هر درخواستی پاسخ برگرداند
- پاسخ‌های timeout یا خطا مجاز نیستند
- پاسخ لازم نیست آخرین داده باشد
- سیستم هرگز از پاسخ دادن به یک پرس‌وجو امتناع نمی‌کند

### تحمل پارتیشن (Partition Tolerance - P)

**تعریف:** سیستم علی‌رغم از دست رفتن دلخواه پیام‌ها یا خرابی بخشی از شبکه به کار خود ادامه می‌دهد.

پارتیشن شبکه زمانی رخ می‌دهد که ارتباط بین برخی گره‌ها مختل شود. تحمل پارتیشن به این معناست که سیستم حتی زمانی که شبکه غیرقابل اعتماد است به کار خود ادامه می‌دهد - پیام‌ها بین گره‌ها می‌توانند حذف، تأخیر یا بازآرایی شوند. در سیستم‌های توزیع‌شده دنیای واقعی، پارتیشن‌های شبکه اجتناب‌ناپذیرند و تحمل پارتیشن را به یک ضرورت عملی تبدیل می‌کنند نه یک ویژگی اختیاری.

```
قبل از پارتیشن:
[گره A] <---> [گره B] <---> [گره C]

در طول پارتیشن:
[گره A] <--X---> [گره B] <---> [گره C]
    |                    |
 ایزوله شده        هنوز می‌توانند ارتباط برقرار کنند
```

**نکات کلیدی:**
- پارتیشن‌های شبکه واقعیت زندگی در سیستم‌های توزیع‌شده هستند
- پیام‌ها بین گره‌ها می‌توانند به طور دلخواه تأخیر یابند یا از بین بروند
- سیستم باید سناریوهای split-brain را مدیریت کند
- تحمل پارتیشن در هیچ سیستم توزیع‌شده واقعی اختیاری نیست

## ۳. توضیح قضیه

### فرمول‌بندی اصلی: «دو تا از سه تا انتخاب کنید»

بروئر در ابتدا قضیه CAP را به صورت انتخاب اجباری «دو مورد از سه» ویژگی فرمول‌بندی کرد و سه گزینه طراحی ممکن پیشنهاد داد:

| ترکیب | توضیح |
|-------|-------|
| **CP** (سازگاری + تحمل پارتیشن) | سازگار و تحمل‌کننده پارتیشن، اما ممکن است دسترس‌پذیری را در طول پارتیشن‌ها فدا کند |
| **AP** (دسترس‌پذیری + تحمل پارتیشن) | دسترس‌پذیر و تحمل‌کننده پارتیشن، اما ممکن است داده‌های قدیمی برگرداند |
| **CA** (سازگاری + دسترس‌پذیری) | سازگار و دسترس‌پذیر، اما نمی‌تواند پارتیشن‌ها را تحمل کند |

### تفسیر مدرن

فرمول‌بندی «دو تا انتخاب کنید» اگرچه برای شهود مفید است، تا حدی گمراه‌کننده است. تفسیر مدرن دقیق‌تر تشخیص می‌دهد که:

۱. **تحمل پارتیشن اختیاری نیست.** در هر سیستم توزیع‌شده واقعی، پارتیشن‌های شبکه می‌توانند و خواهند رخ داد. سیستمی که تحمل پارتیشن نداشته باشد، بنا به تعریف، مجبور خواهد بود هنگام وقوع پارتیشن یکی از سازگاری یا دسترس‌پذیری را از دست بدهد.

۲. **CA یک گزینه منسجم نیست** برای سیستم‌های توزیع‌شده. سیستمی که نمی‌تواند پارتیشن‌های شبکه را مدیریت کند، اساساً یک سیستم تک‌گره‌ای است یا سیستمی که شبکه کاملاً قابل اعتماد را فرض می‌کند - فرضی غیرواقع‌بینانه.

۳. **انتخاب واقعی بین C و A در طول یک پارتیشن است.** وقتی شبکه به درستی کار می‌کند، یک سیستم می‌تواند هم سازگاری و هم دسترس‌پذیری را ارائه دهد. قضیه CAP فقط زمانی انتخاب را اجباری می‌کند که واقعاً یک پارتیشن رخ دهد.

> *«در طول یک پارتیشن شبکه، یک سیستم توزیع‌شده باید یا سازگاری یا دسترس‌پذیری را انتخاب کند.»*

این فرمول‌بندی مدرن بسیار عملی‌تر است و توسط خود بروئر در مقاله بازنگری ۲۰۱۲ تأیید شده است.

### نمایش بصری

```
                    سازگاری (C)
                         /\
                        /  \
                       /    \
                      / سیستم‌ \
                     /  های CP  \
                    /  (مثلاً    \
                   / HBase،      \
                  / MongoDB،      \
                 / FoundationDB)   \
                /------------------\
               / CA        AP       \
              / (تک‌گره   سیستم‌های   \
             /  یا بدون  (مثلاً        \
            /  تحمل     Cassandra،     \
           /  پارتیشن  DynamoDB،       \
          /   واقعی)   CouchDB)        \
         /______________________________\
   دسترس‌پذیری (A) ---------- تحمل پارتیشن (P)
```

## ۴. سیستم‌های CP: انتخاب سازگاری

یک **سیستم CP** سازگاری و تحمل پارتیشن را تضمین می‌کند اما ممکن است دسترس‌پذیری را در طول پارتیشن‌های شبکه فدا کند. وقتی پارتیشن رخ می‌دهد، سیستم ترجیح می‌دهد خطا یا timeout برگرداند تا اینکه داده‌های ناسازگار احتمالی را برگرداند.

### نحوه کار سیستم‌های CP

وقتی یک پارتیشن شبکه در یک سیستم CP رخ می‌دهد:

۱. سیستم پارتیشن را تشخیص می‌دهد
۲. گره‌هایی که نمی‌توانند تأیید کنند آخرین داده‌ها را دارند، پذیرش نوشتن (و احتمالاً خواندن) را متوقف می‌کنند
۳. فقط پارتیشنی که می‌تواند سازگاری را حفظ کند به کار ادامه می‌دهد
۴. وقتی پارتیشن برطرف می‌شود، گره‌های ایزوله مجدداً همگام‌سازی می‌شوند

```
عملکرد عادی:
[گره A] <--همگام--> [گره B] <--همگام--> [گره C]
نوشتن ✓              نوشتن ✓              نوشتن ✓

در طول پارتیشن:
[گره A]   X    [گره B] <--همگام--> [گره C]
نوشتن ✗          نوشتن ✓              نوشتن ✓
(غیردسترس)       (سازگار)             (سازگار)
```

### ویژگی‌ها

- **تضمین‌های سازگاری قوی**: تمام خواندن‌ها آخرین نوشتن را منعکس می‌کنند
- **کاهش دسترس‌پذیری در طول پارتیشن‌ها**: برخی گره‌ها ممکن است درخواست‌ها را رد کنند
- **اجماع مبتنی بر اکثریت**: اغلب از پروتکل‌های حد نصاب یا مبتنی بر رهبر استفاده می‌کنند
- **تأخیر بالاتر**: نوشتن‌ها ممکن است نیاز به هماهنگی بین گره‌ها داشته باشند

### نمونه‌های دنیای واقعی

| سیستم | مکانیزم سازگاری |
|-------|-----------------|
| **FoundationDB** | استفاده از سرورهای هماهنگی مبتنی بر Paxos با قانون اکثریت |
| **HBase** | هماهنگی مبتنی بر ZooKeeper با سازگاری قوی |
| **MongoDB** (پیش‌فرض) | تکرار تک‌اولیه با تضمین نوشتن اکثریت |
| **etcd** | پروتکل اجماع Raft |
| **ZooKeeper** | پروتکل ZAB (پخش اتمی ZooKeeper) |
| **CockroachDB** | اجماع Raft با ایزوله‌سازی سریالی |

### چه زمانی CP انتخاب کنیم

- سیستم‌های مالی که دقت داده‌ها حیاتی است (بانکداری، پرداخت‌ها)
- سرویس‌های قفل توزیع‌شده و هماهنگی
- سیستم‌های مدیریت پیکربندی
- سیستم‌هایی که داده‌های قدیمی می‌تواند باعث خرابی‌های آبشاری شود
- انتخاب رهبر و کشف سرویس

## ۵. سیستم‌های AP: انتخاب دسترس‌پذیری

یک **سیستم AP** دسترس‌پذیری و تحمل پارتیشن را تضمین می‌کند اما ممکن است سازگاری را در طول پارتیشن‌های شبکه فدا کند. وقتی پارتیشن رخ می‌دهد، همه گره‌ها به پذیرش خواندن و نوشتن ادامه می‌دهند، حتی اگر ممکن است داده‌های قدیمی یا متناقض برگردانند.

### نحوه کار سیستم‌های AP

وقتی یک پارتیشن شبکه در یک سیستم AP رخ می‌دهد:

۱. همه گره‌ها به پذیرش خواندن و نوشتن ادامه می‌دهند
۲. گره‌ها در طرف‌های مختلف پارتیشن ممکن است واگرا شوند
۳. وقتی پارتیشن برطرف می‌شود، سیستم باید تعارضات را حل کند
۴. استراتژی‌های حل تعارض (آخرین-نوشتن-برنده، ساعت‌های برداری، CRDTها) استفاده می‌شوند

```
عملکرد عادی:
[گره A] <--همگام--> [گره B] <--همگام--> [گره C]
  X=5                 X=5                 X=5

در طول پارتیشن:
[گره A]     X     [گره B] <--همگام--> [گره C]
  X=7                X=9                 X=9
(نوشتن می‌پذیرد)  (نوشتن می‌پذیرد)   (نوشتن می‌پذیرد)

بعد از برطرف شدن پارتیشن:
[گره A] <--حل تعارض--> [گره B] <--همگام--> [گره C]
  X=?                     X=?                 X=?
          (حل تعارض مورد نیاز است)
```

### مشکل واگرایی داده‌ها

همان‌طور که در مستندات FoundationDB نشان داده شده، پیامد انتخاب دسترس‌پذیری تلخ است:

> *فرض کنید یک پایگاه داده توزیع‌شده ساده متشکل از دو گره و یک پارتیشن شبکه که آن‌ها را قادر به ارتباط نمی‌سازد. برای دسترس‌پذیر بودن، هر یک از دو گره باید به پذیرش نوشتن از کلاینت‌ها ادامه دهد. چون پارتیشن ارتباط را غیرممکن می‌سازد، یک نوشتن روی یک گره توسط گره دیگر قابل مشاهده نیست. چنین سیستمی اکنون فقط به نام «پایگاه داده» است.*

در طول یک پارتیشن، یک سیستم AP عملاً معادل چندین پایگاه داده مستقل است که محتوای آن‌ها حتی لازم نیست مرتبط باشد، چه رسد به سازگار.

### ویژگی‌ها

- **همیشه پاسخ می‌دهد**: هیچ درخواستی هرگز به دلیل پارتیشن خطا نمی‌گیرد
- **سازگاری نهایی**: داده‌ها پس از برطرف شدن پارتیشن همگرا می‌شوند
- **نیاز به حل تعارض**: باید نوشتن‌های واگرا را مدیریت کند
- **تأخیر کمتر**: نیازی به هماهنگی بین گره‌ای برای نوشتن نیست
- **دسترس‌پذیری بالاتر**: سیستم هرگز یک درخواست معتبر را رد نمی‌کند

### نمونه‌های دنیای واقعی

| سیستم | استراتژی حل تعارض |
|-------|-------------------|
| **Cassandra** | آخرین-نوشتن-برنده با سازگاری قابل تنظیم |
| **DynamoDB** | ساعت‌های برداری و حل در سطح برنامه |
| **CouchDB** | همزمانی چند نسخه‌ای با تشخیص تعارض |
| **Riak** | ساعت‌های برداری، CRDTها و خواهران |
| **Voldemort** | ساعت‌های برداری با تعمیر خواندن |

### چه زمانی AP انتخاب کنیم

- فیدهای شبکه‌های اجتماعی که تأخیر جزئی قابل قبول است
- سبد خرید و لیست علاقه‌مندی‌ها
- سیستم‌های DNS
- لایه‌های تحویل محتوا و کش
- جمع‌آوری داده‌های حسگر IoT
- سیستم‌هایی که توان عملیاتی نوشتن بالا مهم‌تر از سازگاری فوری است

## ۶. سردرگمی: دسترس‌پذیری CAP در مقابل دسترس‌پذیری بالا

یکی از رایج‌ترین منابع سردرگمی پیرامون قضیه CAP شامل تفسیر ویژگی «دسترس‌پذیری» است. تمایز حیاتی بین **دسترس‌پذیری CAP** و **دسترس‌پذیری بالای عملیاتی** وجود دارد.

### دسترس‌پذیری CAP

دسترس‌پذیری CAP یک ویژگی مطلق است: **تمام** گره‌ها باید حتی هنگام پارتیشن شدن قادر به خواندن و نوشتن باقی بمانند. این یک تضمین نظری درباره هر گره منفرد در سیستم است.

### دسترس‌پذیری بالای عملیاتی

دسترس‌پذیری بالای عملیاتی به این معناست که سیستم برای کلاینت‌ها در دسترس باقی می‌ماند و SLAهای خود را برآورده می‌سازد (مثلاً ۹۹.۹۹٪ زمان فعالیت). یک سیستم می‌تواند در عمل بسیار دسترس‌پذیر باشد حتی اگر برخی گره‌ها به طور موقت قادر به سرویس‌دهی درخواست‌ها در طول یک پارتیشن نباشند.

### تمایز کلیدی

سیستمی که **برخی، اما نه همه** گره‌هایش قادر به خواندن و نوشتن در طول یک پارتیشن باشند:
- در مفهوم CAP دسترس‌پذیر **نیست**
- اما در مفهوم عملی و عملیاتی بسیار دسترس‌پذیر **هست**

```
در طول پارتیشن:
[گره A - ایزوله]  [گره B] <---> [گره C]
  نمی‌تواند بنویسد ✗   نوشتن ✓       نوشتن ✓

دسترس‌پذیری CAP:    خیر  (گره A غیردسترس است)
دسترس‌پذیری بالا:   بله  (کلاینت‌ها هنوز می‌توانند به B و C دسترسی داشته باشند)
```

این تمایز حیاتی است. بسیاری از سیستم‌های CP (مانند FoundationDB) به عنوان سیستم‌های بسیار دسترس‌پذیر بازاریابی می‌شوند و در عمل نیز چنین رفتار می‌کنند، حتی اگر دسترس‌پذیری CAP را فدا کنند.

## ۷. مثال عملی: رویکرد FoundationDB

FoundationDB یک نمونه عالی از دنیای واقعی ارائه می‌دهد که چگونه یک سیستم CP دسترس‌پذیری بالای عملی را در عین حفظ سازگاری سخت‌گیرانه به دست می‌آورد. این مثال از مستندات FoundationDB گرفته شده است.

### معماری

FoundationDB با مجموعه‌ای از **سرورهای هماهنگی** پیکربندی شده است که از **الگوریتم Paxos** برای حفظ مقدار کمی از حالت اشتراکی استفاده می‌کنند. این حالت خودش سازگار و تحمل‌کننده پارتیشن است. سرورهای هماهنگی تعیین می‌کنند کدام پارتیشن از خوشه باید به پذیرش تراکنش‌ها ادامه دهد.

**قانون اکثریت:** FoundationDB پارتیشنی را که در آن اکثریت سرورهای هماهنگی در دسترس هستند به عنوان پارتیشنی که پاسخگو باقی خواهد ماند انتخاب می‌کند. فقط اگر خرابی‌ها آن‌قدر گسترده باشند که چنین پارتیشنی وجود نداشته باشد، پایگاه داده واقعاً غیردسترس خواهد شد.

### مثال: خوشه سه‌گره‌ای حداقلی

یک استارتاپ کوچک را در نظر بگیرید که FoundationDB را روی سه ماشین (A، B، C) اجرا می‌کند، هر کدام یک سرور پایگاه داده و یک سرور هماهنگی را اجرا می‌کنند و در حالت افزونگی `double` پیکربندی شده‌اند (دو کپی از هر قطعه داده).

**عملکرد عادی:**
```
[ماشین A]  <---->  [ماشین B]  <---->  [ماشین C]
 سرور DB            سرور DB            سرور DB
 سرور هماهنگی       سرور هماهنگی       سرور هماهنگی
 کپی داده ۱         کپی داده ۲         کپی داده ۱
                    کپی داده ۱         کپی داده ۲
```

**در طول پارتیشن (ماشین A ایزوله):**
```
[ماشین A]    X    [ماشین B]  <---->  [ماشین C]
 سرور DB          سرور DB            سرور DB
 سرور هماهنگی     سرور هماهنگی       سرور هماهنگی

 نمی‌تواند تأیید     عملکرد کامل        عملکرد کامل
 (بدون اکثریت)      (اکثریت: B+C)      (اکثریت: B+C)
```

**چه اتفاقی می‌افتد:**
۱. ماشین A نمی‌تواند تراکنش‌های جدید را تأیید کند زیرا نمی‌تواند به اکثریت سرورهای هماهنگی دسترسی پیدا کند (نیاز به ۲ از ۳)
۲. ماشین‌های B و C می‌توانند به یکدیگر دسترسی داشته باشند و اکثریت را تشکیل دهند
۳. همانندسازی تضمین می‌کند یک کپی کامل از داده‌ها روی B و C در دسترس است
۴. کلاینت‌های متصل به B یا C با دسترسی کامل خواندن/نوشتن ادامه می‌دهند
۵. کلاینت‌هایی که فقط به A متصل هستند، پایگاه داده را غیردسترس تجربه می‌کنند

**بعد از برطرف شدن پارتیشن:**
۱. ماشین A دوباره می‌تواند با اکثریت سرورهای هماهنگی ارتباط برقرار کند
۲. A با دریافت تراکنش‌های از دست رفته یا در بدترین حالت، انتقال کل محتوای پایگاه داده مجدداً ملحق می‌شود
۳. همه ماشین‌ها عملکرد کامل تحمل‌خطا را از سر می‌گیرند

### پیکربندی تولید

در تولید، FoundationDB معمولاً در حالت افزونگی `triple` روی پنج یا بیشتر ماشین پیکربندی می‌شود و دسترس‌پذیری و تحمل خطای متناسباً بالاتری فراهم می‌کند.

## ۸. فراتر از CAP: قضیه PACELC

قضیه CAP فقط رفتار سیستم را در طول پارتیشن‌ها توصیف می‌کند. **قضیه PACELC** (پیشنهاد شده توسط دانیل آبادی در ۲۰۱۲) با در نظر گرفتن مصالحه در طول عملکرد عادی (بدون پارتیشن) CAP را گسترش می‌دهد:

> **اگر** یک **P**ارتیشن وجود دارد، بین **A**سترس‌پذیری و **C**ازگاری انتخاب کنید؛
> **و**گرنه (عملکرد عادی)، بین **L**تأخیر و **C**ازگاری انتخاب کنید.

```
                    آیا پارتیشن وجود دارد؟
                         /        \
                       بله         خیر
                      /              \
               انتخاب:              انتخاب:
            A یا C؟               L یا C؟
              /  \                  /  \
            PA    PC              EL    EC
```

### طبقه‌بندی‌های PACELC

| سیستم | پارتیشن (P) | در غیر این صورت (E) | طبقه‌بندی |
|-------|-------------|---------------------|-----------|
| **Cassandra** | PA | EL | PA/EL - دسترس‌پذیری و تأخیر کم را ترجیح می‌دهد |
| **DynamoDB** | PA | EL | PA/EL - دسترس‌پذیری و تأخیر کم را ترجیح می‌دهد |
| **MongoDB** | PC | EC | PC/EC - همیشه سازگاری را ترجیح می‌دهد |
| **FoundationDB** | PC | EC | PC/EC - همیشه سازگاری را ترجیح می‌دهد |
| **CockroachDB** | PC | EC | PC/EC - همیشه سازگاری را ترجیح می‌دهد |
| **Cosmos DB** | PA/PC | EL/EC | قابل تنظیم - قابل پیکربندی در هر درخواست |
| **YugabyteDB** | PC | EC | PC/EC - سازگاری با تأخیر کم را ترجیح می‌دهد |

PACELC از CAP ظریف‌تر است زیرا تصدیق می‌کند که حتی وقتی پارتیشنی وجود ندارد، هنوز مصالحه‌ای بین تأخیر و سازگاری به دلیل نیاز به همگام‌سازی رپلیکاها وجود دارد.

## ۹. سازگاری قابل تنظیم

بسیاری از پایگاه‌داده‌های توزیع‌شده مدرن به طور دقیق در یک دسته‌بندی CAP قرار نمی‌گیرند. در عوض، **سازگاری قابل تنظیم** ارائه می‌دهند که به اپراتورها اجازه می‌دهد تصمیمات مصالحه را بر اساس هر پرس‌وجو یا هر جدول بگیرند.

### نحوه کار سازگاری قابل تنظیم

رایج‌ترین رویکرد از **خواندن و نوشتن مبتنی بر حد نصاب** استفاده می‌کند:

- **N**: تعداد کل رپلیکاها
- **W**: تعداد رپلیکاهایی که باید یک نوشتن را تأیید کنند
- **R**: تعداد رپلیکاهایی که باید به یک خواندن پاسخ دهند

**سازگاری قوی** زمانی حاصل می‌شود که: `W + R > N`

```
مثال با N=3:

سازگاری قوی (W=2, R=2):
  نوشتن روی 2/3 گره، خواندن از 2/3 گره
  همپوشانی تضمین‌شده => همیشه آخرین نوشتن را می‌بیند

سازگاری نهایی (W=1, R=1):
  نوشتن روی 1/3 گره، خواندن از 1/3 گره
  بدون همپوشانی تضمین‌شده => ممکن است داده قدیمی ببیند
```

### نمونه‌هایی از سیستم‌های قابل تنظیم

**Cassandra** چندین سطح سازگاری ارائه می‌دهد:
- `ONE`: نوشتن/خواندن روی یک رپلیکا (سریع، سازگاری نهایی)
- `QUORUM`: نوشتن/خواندن روی اکثریت رپلیکاها (متعادل)
- `ALL`: نوشتن/خواندن روی همه رپلیکاها (کند، سازگاری قوی)
- `LOCAL_QUORUM`: حد نصاب درون مرکز داده محلی

**DynamoDB** ارائه می‌دهد:
- خواندن‌های سازگار نهایی (پیش‌فرض، توان عملیاتی بالاتر)
- خواندن‌های سازگار قوی (همیشه آخرین داده را برمی‌گرداند، تأخیر بالاتر)

## ۱۰. باورهای غلط رایج

### باور غلط ۱: «همیشه باید دو تا از سه تا انتخاب کنید»
**واقعیت:** این انتخاب فقط در طول پارتیشن‌ها مرتبط است. وقتی شبکه سالم است، می‌توانید هم سازگاری و هم دسترس‌پذیری داشته باشید. قضیه CAP فقط زمانی مصالحه را اجباری می‌کند که واقعاً یک رویداد پارتیشن رخ دهد.

### باور غلط ۲: «CP به این معناست که سیستم همیشه غیردسترس است»
**واقعیت:** سیستم‌های CP در عمل بسیار دسترس‌پذیر هستند. آن‌ها فقط دسترس‌پذیری را روی گره‌های خاصی که تحت تأثیر پارتیشن قرار گرفته‌اند فدا می‌کنند، نه کل سیستم. بیشتر کلاینت‌ها به طور عادی سرویس‌دهی می‌شوند.

### باور غلط ۳: «AP به این معناست که داده‌ها همیشه ناسازگارند»
**واقعیت:** سیستم‌های AP سازگاری نهایی دارند. در طول عملکرد عادی (بدون پارتیشن)، داده‌ها معمولاً در عرض میلی‌ثانیه بین گره‌ها سازگار هستند. ناسازگاری فقط در طول رویدادهای پارتیشن واقعی بروز می‌کند.

### باور غلط ۴: «CAP به این معناست که می‌توانید یک ویژگی را کاملاً نادیده بگیرید»
**واقعیت:** هر سه ویژگی روی یک طیف وجود دارند. سیستم‌ها مصالحه‌های ظریف انجام می‌دهند نه اینکه یک ویژگی را کاملاً رها کنند. بسیاری از پایگاه‌داده‌های مدرن سطوح سازگاری قابل تنظیم ارائه می‌دهند.

### باور غلط ۵: «پارتیشن‌های شبکه نادر هستند، پس CAP اهمیتی ندارد»
**واقعیت:** پارتیشن‌های شبکه بیشتر از آنچه فکر می‌کنید رخ می‌دهند، به‌ویژه در محیط‌های ابری، بین مراکز داده و در مقیاس بزرگ. هر سیستمی که روی بیش از یک ماشین اجرا می‌شود باید برای پارتیشن‌ها برنامه‌ریزی کند.

## ۱۱. قضیه CAP در مصاحبه‌های طراحی سیستم

قضیه CAP موضوعی مکرر در مصاحبه‌های طراحی سیستم است. در اینجا نحوه بحث مؤثر درباره آن آمده است:

### چارچوب تحلیل

۱. **نوع داده را شناسایی کنید**: سیستم چه نوع داده‌ای را مدیریت می‌کند؟
۲. **الزامات سازگاری را تعیین کنید**: آیا سیستم می‌تواند خواندن‌های قدیمی را تحمل کند؟
۳. **الزامات دسترس‌پذیری را ارزیابی کنید**: آیا سیستم می‌تواند خرابی یا خطاها را تحمل کند؟
۴. **سناریوی پارتیشن را در نظر بگیرید**: وقتی گره‌ها نمی‌توانند ارتباط برقرار کنند چه اتفاقی می‌افتد؟
۵. **انتخاب و توجیه کنید**: بر اساس الزامات کسب‌وکار CP یا AP را انتخاب کنید

### سناریوهای رایج مصاحبه

| سیستم برای طراحی | پیشنهاد | استدلال |
|-------------------|---------|---------|
| بانکداری/پرداخت‌ها | CP | نمی‌توان موجودی اشتباه نشان داد؛ دقت مالی حیاتی است |
| فید شبکه اجتماعی | AP | تأخیر جزئی در نمایش پست‌های جدید قابل قبول است |
| موجودی/انبار | CP | فروش بیش از حد به دلیل خواندن‌های قدیمی غیرقابل قبول است |
| DNS | AP | رکوردهای DNS قدیمی بهتر از عدم تفکیک نام هستند |
| پیام‌رسانی چت | AP (با ترتیب) | تحویل پیام مهم‌تر از ترتیب دقیق است |
| قفل توزیع‌شده | CP | قفل‌ها باید سازگار باشند؛ split-brain باعث خرابی داده می‌شود |
| سبد خرید | AP | سبد را می‌توان بعداً ادغام کرد؛ از دست دادن آیتم بدتر از تکرار است |
| ذخیره پیکربندی | CP | همه گره‌ها باید پیکربندی یکسان ببینند |

## ۱۲. مصالحه‌ها و ملاحظات طراحی

### انتخاب بین CP و AP

| فاکتور | سیستم CP | سیستم AP |
|--------|----------|----------|
| **در طول پارتیشن** | برخی گره‌ها درخواست‌ها را رد می‌کنند | همه گره‌ها درخواست‌ها را می‌پذیرند |
| **تضمین داده** | همیشه سازگار | سازگاری نهایی |
| **تأخیر نوشتن** | بالاتر (هماهنگی لازم است) | کمتر (نوشتن محلی) |
| **تأخیر خواندن** | احتمالاً بالاتر | کمتر |
| **حل تعارض** | نیازی نیست (جلوگیری می‌شود) | ضروری (بعد از پارتیشن) |
| **پیچیدگی** | پروتکل‌های اجماع | منطق حل تعارض |
| **بهترین برای** | مالی، هماهنگی، پیکربندی | اجتماعی، کش، IoT، CDN |

### استراتژی‌هایی برای به حداقل رساندن مصالحه‌ها

۱. **جداسازی نگرانی‌ها**: از CP برای داده‌های حیاتی (موجودی حساب) و AP برای داده‌های کم‌اهمیت‌تر (ترجیحات کاربر) در همان سیستم استفاده کنید
۲. **استفاده از سازگاری قابل تنظیم**: سطح سازگاری را بر اساس هر پرس‌وجو بر اساس الزامات تنظیم کنید
۳. **طراحی برای بازیابی پارتیشن**: استراتژی‌های واضح برای حل تعارض هنگام برطرف شدن پارتیشن‌ها داشته باشید
۴. **استقرار چند منطقه‌ای**: از اجماع درون یک منطقه (تأخیر کم) و سازگاری نهایی بین مناطق استفاده کنید
۵. **رپلیکاهای خواندن**: خواندن‌ها را از رپلیکاها (احتمالاً قدیمی) سرویس دهید در حالی که سازگاری قوی برای نوشتن‌ها حفظ می‌شود

## ۱۳. مفاهیم مرتبط

- **الگوریتم Paxos**: پروتکل اجماع مورد استفاده بسیاری از سیستم‌های CP (مثلاً FoundationDB) برای توافق بر مقادیر بین گره‌های توزیع‌شده
- **اجماع Raft**: یک الگوریتم اجماع قابل فهم‌تر مورد استفاده etcd، CockroachDB و دیگران
- **سازگاری نهایی**: مدل سازگاری سیستم‌های AP که در آن همه رپلیکاها با زمان کافی همگرا می‌شوند
- **سازگاری قوی (خطی‌سازی)**: مدل سازگاری سیستم‌های CP که در آن خواندن‌ها همیشه آخرین نوشتن را منعکس می‌کنند
- **CRDTها (انواع داده تکرارشده بدون تعارض)**: ساختارهای داده‌ای که می‌توانند بین گره‌ها تکرار و بدون تعارض ادغام شوند
- **ساعت‌های برداری**: مکانیزمی برای ردیابی علیت در سیستم‌های توزیع‌شده برای تشخیص و حل تعارضات
- **[تأیید دو مرحله‌ای (2PC)](../distributed-transactions/two-phase-commit.fa.md)**: پروتکل تراکنش توزیع‌شده که سازگاری را فراهم می‌کند اما دسترس‌پذیری را فدا می‌کند
- **[الگوی Saga](../distributed-transactions/saga.fa.md)**: الگو برای مدیریت تراکنش‌های توزیع‌شده با سازگاری نهایی
- **حد نصاب (Quorum)**: حداقل تعداد گره‌هایی که باید برای موفقیت یک عملیات توافق کنند

## ۱۴. خلاصه

قضیه CAP یک محدودیت بنیادی بر سیستم‌های توزیع‌شده ایجاد می‌کند: در طول یک پارتیشن شبکه، باید بین سازگاری و دسترس‌پذیری انتخاب کنید. نکات کلیدی:

۱. **تحمل پارتیشن اختیاری نیست** در هیچ سیستم توزیع‌شده واقعی - انتخاب واقعی بین C و A در طول پارتیشن‌هاست
۲. **سیستم‌های CP** (FoundationDB، HBase، etcd) دسترس‌پذیری گره‌های تحت تأثیر را در طول پارتیشن‌ها فدا می‌کنند تا سازگاری داده‌ها حفظ شود
۳. **سیستم‌های AP** (Cassandra، DynamoDB، CouchDB) سازگاری را فدا می‌کنند تا کاملاً دسترس‌پذیر بمانند و نیاز به حل تعارض دارند
۴. **دسترس‌پذیری CAP ≠ دسترس‌پذیری بالا** - یک سیستم می‌تواند در عمل بسیار دسترس‌پذیر باشد در حالی که تعریف سخت‌گیرانه CAP را برآورده نمی‌سازد
۵. **قضیه PACELC** با در نظر گرفتن مصالحه تأخیر در مقابل سازگاری در طول عملکرد عادی، CAP را گسترش می‌دهد
۶. **پایگاه‌داده‌های مدرن** اغلب سازگاری قابل تنظیم ارائه می‌دهند که امکان تصمیمات مصالحه بر اساس هر پرس‌وجو را فراهم می‌سازد
۷. **طراحی سیستم** نیاز به تحلیل الزامات کسب‌وکار برای تعیین مدل سازگاری مناسب برای هر مؤلفه دارد

درک قضیه CAP به معماران کمک می‌کند تصمیمات آگاهانه‌ای درباره انتخاب پایگاه داده، استراتژی‌های تکرار و رفتار سیستم در طول سناریوهای خرابی بگیرند. به جای اینکه آن را به عنوان یک محدودیت ببینید، آن را به عنوان راهنمایی برای درک اینکه سیستم شما به طور واقع‌بینانه چه تضمین‌هایی می‌تواند ارائه دهد، در نظر بگیرید.

---

**مراجع:**
- Brewer, E. (2000). *Towards Robust Distributed Systems* (سخنرانی کلیدی حدس CAP)
- Gilbert, S. & Lynch, N. (2002). *Brewer's Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services*
- Brewer, E. (2012). *CAP Twelve Years Later: How the "Rules" Have Changed*
- Abadi, D. (2012). *Consistency Tradeoffs in Modern Distributed Database System Design*
- مستندات Apple/FoundationDB - *CAP Theorem*
