# پایگاه داده مشترک (Shared Database)

## ۱. مقدمه

الگوی **پایگاه داده مشترک (Shared Database)** یکی از رایج‌ترین و سنتی‌ترین رویکردها برای مدیریت داده در معماری‌های چندسرویسی است. در این الگو، چندین سرویس (یا ماژول) از یک پایگاه داده متمرکز واحد مشترکاً استفاده می‌کنند. به جای اینکه هر سرویس مالک ذخیره‌گاه داده خصوصی خود باشد، همه سرویس‌ها از مجموعه‌ای یکسان از جداول در یک سرور پایگاه داده مشترک خوانده و در آن می‌نویسند.

این الگو نقطه شروع پیش‌فرض برای اکثر سازمان‌ها است، به‌ویژه آنهایی که از معماری یکپارچه (Monolith) به [میکروسرویس‌ها](../architecture/microservices.md) مهاجرت می‌کنند. اگرچه در محیط‌های بالغ میکروسرویس اغلب به عنوان یک **ضد الگو (Anti-Pattern)** در نظر گرفته می‌شود، اما همچنان یک انتخاب عملگرایانه و معتبر در بسیاری از سناریوهای دنیای واقعی باقی می‌ماند -- به‌ویژه در مراحل اولیه مهاجرت یا زمانی که سازگاری قوی داده یک نیاز سخت‌گیرانه است.

### ایده اصلی

> به جای اختصاص پایگاه داده مستقل به هر سرویس، اجازه دهید چندین سرویس از یک پایگاه داده مشترک استفاده کنند تا بتوانند از تراکنش‌های ACID و joinهای ساده در مرزهای سرویس بهره ببرند.

```
┌──────────────────────────────────────────────────────────┐
│                   پایگاه داده مشترک                       │
│                                                          │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │
│   │ Orders  │  │ Users   │  │Products │  │Payments │   │
│   │  Table  │  │  Table  │  │  Table  │  │  Table  │   │
│   └─────────┘  └─────────┘  └─────────┘  └─────────┘   │
│                                                          │
└──────────┬──────────┬──────────┬──────────┬──────────────┘
           │          │          │          │
           ▼          ▼          ▼          ▼
     ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
     │  Order   │ │  User    │ │ Product  │ │ Payment  │
     │ Service  │ │ Service  │ │ Service  │ │ Service  │
     └──────────┘ └──────────┘ └──────────┘ └──────────┘
```

---

## ۲. زمینه و مسئله

### زمینه

سازمانی را در نظر بگیرید که یک برنامه یکپارچه بزرگ با یک پایگاه داده رابطه‌ای واحد دارد. تیم تصمیم می‌گیرد این یکپارچه را به میکروسرویس‌ها تجزیه کند تا استقرار مستقل، مقیاس‌پذیری بهتر و مالکیت واضح‌تر تیمی را به دست آورد. با این حال، جداسازی پایگاه داده یکی از سخت‌ترین بخش‌های مهاجرت است.

### مسئله

هنگام حرکت از یکپارچه به [میکروسرویس‌ها](../architecture/microservices.md)، با یک سوال بنیادی مواجه می‌شوید:

**چگونه داده‌ها را در چندین سرویس مدیریت کنید و در عین حال سازگاری را حفظ کنید، بدون اینکه پیچیدگی تراکنش‌های توزیع‌شده را معرفی کنید؟**

تقسیم فوری پایگاه داده به این معناست که:
- **تراکنش‌های ACID** را در مرزهای سرویس از دست می‌دهید
- به الگوهایی مانند [Saga](../distributed-transactions/saga.md) یا [Two-Phase Commit](../distributed-transactions/two-phase-commit.md) برای سازگاری بین سرویس‌ها نیاز دارید
- عملیات `JOIN` ساده SQL بین داده‌های سرویس‌ها دیگر ممکن نیست
- تکرار داده و همگام‌سازی چالش‌های عملیاتی جدیدی ایجاد می‌کنند

برای بسیاری از تیم‌ها، به‌ویژه در ابتدای مهاجرت، این پیچیدگی توجیه‌پذیر نیست.

---

## ۳. نیروها

چندین نیروی رقابتی به سمت یا بر خلاف الگوی پایگاه داده مشترک فشار وارد می‌کنند:

| نیرو | به سمت DB مشترک فشار می‌دهد | از DB مشترک دور می‌کند |
|------|------------------------------|-------------------------|
| **سازگاری** | تراکنش‌های ACID بین سرویس‌ها به سادگی ممکن است | وابستگی شدید، تکامل مستقل را محدود می‌کند |
| **سادگی** | یک DB برای مدیریت، نظارت و پشتیبان‌گیری | تغییرات اسکیما نیاز به هماهنگی بین تیمی دارد |
| **عملکرد** | Joinها و تجمیع‌ها روی یک DB کارآمد هستند | پایگاه داده تبدیل به گلوگاه می‌شود |
| **استقلال تیم** | هزینه هماهنگی اولیه کم | تیم‌ها نمی‌توانند به صورت مستقل فناوری داده خود را انتخاب کنند |
| **مقیاس‌پذیری** | برای مقیاس کوچک/متوسط کافی | مقیاس‌بندی عمودی محدودیت دارد؛ افقی با وضعیت مشترک دشوار است |
| **هزینه مهاجرت** | هزینه صفر مهاجرت از یکپارچه | تأخیر در جداسازی وابستگی بیشتری را انباشته می‌کند |

### زمانی که نیروها به نفع پایگاه داده مشترک هستند

- مراحل اولیه مهاجرت یکپارچه به میکروسرویس (رویکرد "Strangler Fig")
- تعداد کم سرویس‌ها (۲-۵) با همپوشانی قابل توجه داده
- نیازمندی‌های سازگاری قوی که سازگاری نهایی را تحمل نمی‌کنند
- تیم‌های کوچک که می‌توانند تغییرات اسکیما را به راحتی هماهنگ کنند
- حجم ترافیک پایین که گلوگاه پایگاه داده نگرانی نیست

---

## ۴. راه‌حل

### الگو

در الگوی پایگاه داده مشترک، چندین سرویس به یک پایگاه داده رابطه‌ای مشترک متصل شده و از آن استفاده می‌کنند. دو نوع وجود دارد:

#### نوع A: جداول مشترک

چندین سرویس از **جداول یکسان** می‌خوانند و در آنها می‌نویسند. این بالاترین درجه وابستگی است.

```
┌────────────┐     ┌────────────┐
│   Order    │     │  Shipping  │
│  Service   │     │  Service   │
└─────┬──────┘     └─────┬──────┘
      │                  │
      │   هر دو در جدول orders خوانده/نوشته می‌کنند
      │                  │
      ▼                  ▼
┌──────────────────────────────┐
│        Shared Database       │
│  ┌────────────────────────┐  │
│  │     orders table       │  │
│  │ ┌────┬───────┬───────┐ │  │
│  │ │ id │ total │status │ │  │
│  │ └────┴───────┴───────┘ │  │
│  └────────────────────────┘  │
└──────────────────────────────┘
```

**ریسک:** اگر Order Service اسکیمای جدول `orders` را تغییر دهد (مثلاً `status` را به `order_status` تغییر نام دهد)، Shipping Service فوراً از کار می‌افتد.

#### نوع B: سرور مشترک، اسکیماهای جداگانه

هر سرویس **اسکیمای خود** (یا مجموعه‌ای از جداول) را در همان سرور پایگاه داده دارد. سرویس‌ها مستقیماً به جداول یکدیگر دسترسی ندارند اما می‌توانند در صورت نیاز از joinهای بین اسکیما یا viewها استفاده کنند.

```
┌────────────┐     ┌────────────┐     ┌────────────┐
│   Order    │     │  Shipping  │     │  Payment   │
│  Service   │     │  Service   │     │  Service   │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │
      ▼                  ▼                  ▼
┌──────────────────────────────────────────────────┐
│              Shared Database Server               │
│                                                  │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐     │
│  │  orders  │   │ shipping │   │ payments │     │
│  │  schema  │   │  schema  │   │  schema  │     │
│  └──────────┘   └──────────┘   └──────────┘     │
│                                                  │
│  (joinهای بین اسکیما ممکن اما توصیه نمی‌شود)    │
└──────────────────────────────────────────────────┘
```

**این یک گام میانی** به سمت [پایگاه داده به ازای هر سرویس](./database-per-service.md) است، جایی که هر سرویس در نهایت سرور پایگاه داده اختصاصی خود را دریافت می‌کند.

### راهنمای استفاده از پایگاه داده مشترک

1. **مالکیت واضح جدول تعریف کنید** -- حتی اگر DB مشترک باشد، هر جدول باید یک سرویس مالک داشته باشد. سایر سرویس‌ها باید از طریق API سرویس مالک به آن داده دسترسی پیدا کنند، نه مستقیماً.
2. **از viewها یا stored procedureهای پایگاه داده** به عنوان لایه قرارداد بین سرویس‌ها و اسکیمای زیربنایی استفاده کنید.
3. **فرآیندهای تغییر اسکیما ایجاد کنید** -- هر تغییر اسکیما باید توسط همه تیم‌های وابسته بررسی شود.
4. **خزش وابستگی را نظارت کنید** -- پیگیری کنید که کدام سرویس‌ها به کدام جداول دسترسی دارند. هشدار در مورد دسترسی فرامرزی به جلوگیری از وابستگی خاموش کمک می‌کند.
5. **مسیر مهاجرت خود را برنامه‌ریزی کنید** -- پایگاه داده مشترک را به عنوان وضعیت موقت در نظر بگیرید و نقشه راهی به سمت [پایگاه داده به ازای هر سرویس](./database-per-service.md) داشته باشید.

---

## ۵. مثال

### سناریو: مهاجرت یکپارچه تجارت الکترونیک

یک شرکت تجارت الکترونیک متوسط یک برنامه یکپارچه با یک پایگاه داده PostgreSQL واحد دارد. آنها تصمیم می‌گیرند سرویس‌ها را به صورت تدریجی استخراج کنند.

#### فاز ۱: یکپارچه (نقطه شروع)

```
┌──────────────────────────────────────┐
│          Monolith Application        │
│                                      │
│  ┌─────────┐  ┌──────────────────┐   │
│  │ Orders  │  │ User Management  │   │
│  │ Module  │  │     Module       │   │
│  └─────────┘  └──────────────────┘   │
│  ┌─────────┐  ┌──────────────────┐   │
│  │Inventory│  │    Payments      │   │
│  │ Module  │  │     Module       │   │
│  └─────────┘  └──────────────────┘   │
└──────────────────┬───────────────────┘
                   │
                   ▼
         ┌──────────────────┐
         │   PostgreSQL DB  │
         │                  │
         │  users           │
         │  orders          │
         │  order_items     │
         │  products        │
         │  inventory       │
         │  payments        │
         │  shipping        │
         └──────────────────┘
```

#### فاز ۲: استخراج سرویس‌ها، اشتراک‌گذاری پایگاه داده

تیم ماژول‌های User و Payment را به سرویس‌های جداگانه استخراج می‌کند. همه سرویس‌ها هنوز از همان پایگاه داده مشترک استفاده می‌کنند.

```
                    ┌──────────────┐
                    │   API GW     │
                    └──────┬───────┘
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Monolith   │ │    User     │ │   Payment   │
    │ (Orders +   │ │   Service   │ │   Service   │
    │  Inventory) │ │ (extracted) │ │ (extracted) │
    └──────┬──────┘ └──────┬──────┘ └──────┬──────┘
           │               │               │
           └───────────────┼───────────────┘
                           │
                           ▼
                 ┌──────────────────┐
                 │   PostgreSQL DB  │
                 │  (shared by all) │
                 │                  │
                 │  users      ◄──── User Service مالک
                 │  orders     ◄──── Monolith مالک
                 │  order_items◄──── Monolith مالک
                 │  products   ◄──── Monolith مالک
                 │  inventory  ◄──── Monolith مالک
                 │  payments   ◄──── Payment Service مالک
                 │  shipping   ◄──── Monolith مالک
                 └──────────────────┘
```

**در این فاز:**
- سرویس User مالک جدول `users` است و داده‌های کاربر را از طریق API ارائه می‌دهد
- سرویس Payment مالک جدول `payments` است
- بقیه یکپارچه هنوز مستقیماً به جداول `users` و `payments` دسترسی دارد (وابستگی قدیمی)
- یک تراکنش `BEGIN ... COMMIT` هنوز می‌تواند orders + payments را شامل شود

#### فاز ۳: جداسازی تدریجی (وضعیت هدف)

با گذشت زمان، تیم دسترسی مستقیم به جدول را با فراخوانی‌های API جایگزین می‌کند و در نهایت هر سرویس را به پایگاه داده خود مهاجرت می‌دهد -- و به [پایگاه داده به ازای هر سرویس](./database-per-service.md) دست می‌یابد.

```
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │   Order     │ │    User     │ │   Payment   │
    │   Service   │ │   Service   │ │   Service   │
    └──────┬──────┘ └──────┬──────┘ └──────┬──────┘
           │               │               │
           ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │ Orders   │    │ Users    │    │ Payments │
    │   DB     │    │   DB     │    │   DB     │
    └──────────┘    └──────────┘    └──────────┘
```

سازگاری داده بین سرویسی اکنون توسط [الگوی Saga](../distributed-transactions/saga.md) یا ارتباطات رویداد-محور مدیریت می‌شود.

---

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیحات |
|------|---------|
| **تراکنش‌های ACID** | یک تراکنش واحد می‌تواند داده‌های چندین سرویس را شامل شود. نیازی به الگوهای تراکنش توزیع‌شده نیست. |
| **پرس‌وجوهای ساده** | `JOIN`های SQL بین داده‌های سرویس‌ها ساده است -- نیازی به ترکیب API یا غیرنرمال‌سازی داده نیست. |
| **بدون تکرار داده** | یک منبع حقیقت واحد برای تمام داده‌ها. بدون چالش‌های همگام‌سازی یا سازگاری نهایی. |
| **ابزارهای آشنا** | ابزارهای استاندارد RDBMS برای پشتیبان‌گیری، نظارت، مهاجرت و گزارش‌گیری BI به صورت آماده کار می‌کنند. |
| **هزینه اولیه کم** | هزینه صفر برای شروع -- به‌ویژه هنگام مهاجرت از یکپارچه که DB مشترک از قبل وجود دارد. |
| **عملیات ساده‌تر** | یک پایگاه داده برای نظارت، پشتیبان‌گیری، وصله و ایمن‌سازی به جای تعداد زیادی. |

### معایب

| عیب | توضیحات |
|-----|---------|
| **وابستگی شدید** | سرویس‌ها از طریق اسکیمای مشترک وابسته هستند. تغییر نام یک ستون می‌تواند چندین سرویس را همزمان خراب کند. |
| **گلوگاه مقیاس‌بندی** | پایگاه داده تبدیل به نقطه واحد رقابت می‌شود. همه سرویس‌ها برای همان connection pool، I/O و CPU رقابت می‌کنند. |
| **هماهنگی تغییرات اسکیما** | هر مهاجرت نیاز به هماهنگی دقیق بین همه تیم‌هایی دارد که به جداول تأثیرپذیر دسترسی دارند. |
| **وابستگی فناوری** | همه سرویس‌ها باید از همان فناوری پایگاه داده استفاده کنند. نمی‌توانید برای یک سرویس MongoDB و برای دیگری PostgreSQL استفاده کنید. |
| **کاهش استقلال تیم** | تیم‌ها نمی‌توانند به صورت مستقل مدل داده خود را توسعه دهند، فناوری ذخیره‌سازی انتخاب کنند یا تغییرات اسکیما را طبق برنامه خود اعمال کنند. |
| **پیچیدگی تست** | تست‌های یکپارچگی نیاز به پایگاه داده مشترک کامل دارند، که تست سرویس‌ها به صورت ایزوله را دشوارتر می‌کند. |
| **نقطه شکست واحد** | قطعی پایگاه داده همه سرویس‌ها را همزمان تحت تأثیر قرار می‌دهد و تاب‌آوری کلی سیستم را کاهش می‌دهد. |

### مقایسه: پایگاه داده مشترک در برابر پایگاه داده به ازای هر سرویس

| جنبه | پایگاه داده مشترک | [پایگاه داده به ازای هر سرویس](./database-per-service.md) |
|------|-------------------|------------------------------|
| **وابستگی** | بالا -- سرویس‌ها از طریق اسکیما وابسته | کم -- سرویس‌ها فقط از طریق APIها وابسته |
| **سازگاری** | قوی (ACID) | نهایی (نیاز به [Saga](../distributed-transactions/saga.md) یا مشابه) |
| **Join** | joinهای بومی SQL | ترکیب API یا مدل‌های خواندن [CQRS](./cqrs.md) |
| **مقیاس‌پذیری** | محدود به یک DB | هر سرویس به صورت مستقل مقیاس می‌شود |
| **آزادی فناوری** | محدود به یک فناوری DB | ذخیره‌سازی چندزبانه ممکن |
| **هزینه عملیاتی** | کم (یک DB) | بالاتر (پایگاه داده‌های متعدد برای مدیریت) |
| **استقلال تیم** | کم | بالا |
| **پیچیدگی مهاجرت** | هیچ (از اینجا شروع کنید) | نیاز به استخراج دقیق داده |
| **ایزوله‌سازی خطا** | ضعیف -- خرابی DB همه را تحت تأثیر قرار می‌دهد | خوب -- خرابی به یک سرویس محدود می‌شود |
| **تکامل اسکیما** | نیاز به هماهنگی بین تیمی | مستقل به ازای هر سرویس |
| **بهترین برای** | مهاجرت اولیه، تیم‌های کوچک، سازگاری قوی | میکروسرویس‌های بالغ، تیم‌های بزرگ، مقیاس بالا |

---

## ۷. الگوهای مرتبط

### جایگزین‌های مستقیم

- **[پایگاه داده به ازای هر سرویس](./database-per-service.md)** -- رویکرد مقابل که در آن هر سرویس مالک پایگاه داده خود است. این وضعیت هدف توصیه‌شده برای معماری‌های بالغ میکروسرویس است. مهاجرت از پایگاه داده مشترک به پایگاه داده به ازای هر سرویس یک مسیر تکاملی رایج است.

### الگوهای مکمل

- **[الگوی Saga](../distributed-transactions/saga.md)** -- وقتی از پایگاه داده مشترک فاصله می‌گیرید، تراکنش‌های ACID بین سرویس‌ها را از دست می‌دهید. الگوی Saga جایگزینی برای مدیریت تراکنش‌های توزیع‌شده از طریق دنباله‌ای از تراکنش‌های محلی با اقدامات جبرانی فراهم می‌کند.

- **[CQRS](./cqrs.md)** -- وقتی پایگاه داده مشترک تقسیم شود، پرس‌وجوهای بین سرویسی دشوار می‌شوند. CQRS با نگهداری مدل‌های خواندن جداگانه که داده‌ها را از چندین سرویس تجمیع می‌کنند، کمک می‌کند.

- **[معماری میکروسرویس‌ها](../architecture/microservices.md)** -- زمینه معماری گسترده‌تری که الگوی پایگاه داده مشترک (و جایگزین‌های آن) در آن وجود دارد. اصول میکروسرویس‌ها عموماً پایگاه داده به ازای هر سرویس را توصیه می‌کنند، اما پایگاه داده مشترک را به عنوان یک گام میانی عملگرایانه می‌پذیرند.

### الگوهایی که در طول مهاجرت باید در نظر گرفته شوند

- **الگوی Strangler Fig** -- به صورت تدریجی بخش‌هایی از یکپارچه را با سرویس‌های جدید جایگزین کنید در حالی که پایگاه داده مشترک را نگه می‌دارید و به تدریج مالکیت داده را مهاجرت می‌دهید.
- **تغییرات داده‌ای ضبط شده (CDC)** -- از ابزارهایی مانند Debezium برای ضبط تغییرات پایگاه داده و انتشار آنها به سرویس‌های دیگر در طول انتقال از پایگاه داده مشترک به جداگانه استفاده کنید.
- **API Gateway** -- درخواست‌ها را به سرویس مناسب هدایت کنید همان‌طور که سرویس‌ها را از یکپارچه استخراج می‌کنید. به [الگوی API Gateway](../architecture/api-gateway.md) مراجعه کنید.

---

## ۸. استفاده در دنیای واقعی

### شرکت‌ها در طول مهاجرت

بسیاری از شرکت‌های بزرگ با پایگاه داده‌های مشترک کار می‌کنند، به‌ویژه در طول پروژه‌های مهاجرت چندساله:

- **بانک‌ها و مؤسسات مالی بزرگ** اغلب سیستم‌های بانکداری هسته‌ای بر روی یک پایگاه داده Oracle یا DB2 واحد دارند که توسط ده‌ها سرویس مشترک است. مهاجرت به میکروسرویس‌ها در حال انجام است، اما نیازمندی‌های سازگاری ACID برای تراکنش‌های مالی جایگزینی پایگاه داده مشترک را دشوار می‌کند.

- **سیستم‌های ERP قدیمی** (SAP، Oracle EBS) ذاتاً از مدل پایگاه داده مشترک استفاده می‌کنند. تلاش‌های مدرن‌سازی این پایگاه داده‌ها را با لایه‌های API می‌پوشانند در حالی که پایگاه داده مشترک را در زیر نگه می‌دارند.

- **سیستم‌های دولتی و بهداشتی** اغلب الزامات نظارتی برای سازگاری قوی و قابلیت حسابرسی دارند که الگوهای سازگاری نهایی (مانند Saga) را سخت‌تر برای توجیه می‌کنند.

### زمانی که پایگاه داده مشترک معنا دارد

| سناریو | چرا پایگاه داده مشترک کار می‌کند |
|--------|----------------------------------|
| **فاز اولیه مهاجرت** | ریسک کم، به تیم‌ها اجازه می‌دهد الگوهای میکروسرویس را به صورت تدریجی یاد بگیرند |
| **۲-۵ سرویس با همپوشانی زیاد داده** | هزینه همگام‌سازی داده از هزینه وابستگی بیشتر است |
| **نیازمندی‌های سازگاری قوی** | تراکنش‌های مالی، مدیریت موجودی، گزارش‌گیری نظارتی |
| **تیم کوچک (< ۱۰ توسعه‌دهنده)** | سربار ارتباطی هماهنگی اسکیما قابل مدیریت است |
| **بارهای کاری گزارش‌گیری سنگین** | ابزارهای BI/تحلیل بهتر با یک پایگاه داده واحد کار می‌کنند |
| **پروژه کوتاه‌مدت** | ارزش سرمایه‌گذاری برای تقسیم پایگاه داده را ندارد |

### زمان مهاجرت

مهاجرت به [پایگاه داده به ازای هر سرویس](./database-per-service.md) را زمانی در نظر بگیرید که:

1. **تغییرات اسکیما دردناک شوند** -- چندین تیم توسط یک مهاجرت واحد مسدود شده‌اند
2. **پایگاه داده تبدیل به گلوگاه شود** -- اتمام connection pool، رقابت قفل، پرس‌وجوهای کند
3. **تیم‌ها آزادی فناوری بخواهند** -- بعضی داده‌ها بهتر توسط document store، graph DB یا time-series DB سرویس‌دهی می‌شوند
4. **وابستگی استقرار سرعت شما را کم کند** -- نمی‌توانید یک سرویس را بدون تست در برابر اسکیمای مشترک کامل مستقر کنید
5. **ایزوله‌سازی خطا حیاتی باشد** -- قطعی پایگاه داده نباید کل سیستم را از کار بیندازد

---

## ۹. خلاصه

الگوی پایگاه داده مشترک ساده‌ترین رویکرد برای مدیریت داده در معماری چندسرویسی است. همه سرویس‌ها از یک پایگاه داده واحد مشترک استفاده می‌کنند که تراکنش‌های ACID، پرس‌وجوهای ساده و عدم تکرار داده را ممکن می‌سازد.

```
┌──────────────────────────────────────────────────────────────┐
│                     فلوچارت تصمیم‌گیری                        │
│                                                              │
│   آیا از یکپارچه مهاجرت می‌کنید؟                              │
│     بله ──► با پایگاه داده مشترک شروع کنید                    │
│              │                                               │
│              ▼                                               │
│   آیا < ۵ سرویس با نیاز سازگاری قوی دارید؟                   │
│     بله ──► فعلاً با پایگاه داده مشترک بمانید                  │
│     خیر ──► مهاجرت به پایگاه داده به ازای هر سرویس را برنامه‌ریزی کنید │
│              │                                               │
│              ▼                                               │
│   آیا تغییرات اسکیما باعث اصطکاک بین تیمی شده؟               │
│     بله ──► به پایگاه داده به ازای هر سرویس مهاجرت کنید       │
│              از Saga برای تراکنش‌های توزیع‌شده استفاده کنید     │
│              از CQRS برای پرس‌وجوهای بین سرویسی استفاده کنید  │
│     خیر ──► پایگاه داده مشترک را نگه دارید، دوره‌ای بازبینی کنید │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### نکات کلیدی

- **پایگاه داده مشترک ذاتاً بد نیست** -- هنگامی که آگاهانه و با درک مصالحه‌هایش استفاده شود، یک الگوی معتبر است.
- **نقطه شروع طبیعی** برای مهاجرت‌های یکپارچه به میکروسرویس است.
- **مالکیت واضح تعریف کنید** -- حتی در پایگاه داده مشترک، هر جدول باید یک سرویس مالک داشته باشد.
- **به عنوان وضعیت گذرا در نظر بگیرید** -- نقشه راهی به سمت [پایگاه داده به ازای هر سرویس](./database-per-service.md) داشته باشید اگر در حال ساخت سیستم میکروسرویس در مقیاس بزرگ هستید.
- **بدانید چه زمانی حرکت کنید** -- وقتی هزینه‌های وابستگی از مزایای سازگاری بیشتر شد، زمان مهاجرت است.

### مطالعه بیشتر

- کتاب *Building Microservices* نوشته Sam Newman -- فصل مدیریت داده
- کتاب *Monolith to Microservices* نوشته Sam Newman -- استراتژی‌های مهاجرت شامل پایگاه داده مشترک
- کتاب *Microservices Patterns* نوشته Chris Richardson -- پایگاه داده به ازای هر سرویس و الگوهای مرتبط
- مقالات Martin Fowler درباره [میکروسرویس‌ها](https://martinfowler.com/articles/microservices.html)

---

*[بازگشت به الگوهای داده](./README.md) | [بازگشت به README اصلی](../../README.md)*
