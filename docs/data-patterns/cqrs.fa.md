# CQRS (Command Query Responsibility Segregation)

## 1. مقدمه

**Command Query Responsibility Segregation (CQRS)** یک الگوی معماری است که عملیات خواندن (queries) را از عملیات نوشتن (commands) با استفاده از مدل‌های مختلف جداسازی می‌کند. این جداسازی امکان بهینه‌سازی، مقیاس‌پذیری و تکامل مستقل سمت خواندن و نوشتن یک اپلیکیشن را فراهم می‌کند.

### منشا و تکامل

CQRS توسط **Greg Young** در حدود سال 2010 معرفی شد و بر اساس اصل **Command Query Separation (CQS)** از Bertrand Meyer در دهه 1980 بنا شده است. در حالی که CQS در سطح متد اعمال می‌شود، CQRS این مفهوم را به سطح معماری ارتقا می‌دهد و مدل‌های کاملاً جداگانه‌ای برای خواندن و نوشتن داده ایجاد می‌کند.

### مشکل اصلی

اپلیکیشن‌های CRUD سنتی از یک مدل واحد برای هم خواندن و هم نوشتن داده استفاده می‌کنند. این کار تنش‌هایی ایجاد می‌کند:

- **عملیات نوشتن** نیاز به اعتبارسنجی، منطق کسب‌وکار و سازگاری تراکنشی دارند
- **عملیات خواندن** به viewهای denormalized، کوئری‌های بهینه و زمان پاسخ سریع نیاز دارند
- **نیازهای مقیاس‌پذیری** متفاوت است: خواندن معمولاً بیش از 90% ترافیک در اکثر اپلیکیشن‌ها است
- **پیچیدگی مدل** با افزایش تلاش برای ارائه هر دو هدف، رشد می‌کند

CQRS این مشکل را با پذیرفتن این نکته حل می‌کند که **نیازمندی‌های خواندن و نوشتن شما اساساً متفاوت هستند** و باید به شکل متفاوتی مدل شوند.

---

## 2. CQS در مقابل CQRS

### اصل Command Query Separation (CQS)

CQS یک اصل طراحی است که بیان می‌کند هر متد باید یکی از موارد زیر باشد:

- **Command**: تغییر وضعیت اما برگرداندن داده نمی‌دهد (متدهای void)
- **Query**: برگرداندن داده اما تغییر وضعیت نمی‌دهد (توابع خالص)

```
// CQS در سطح متد
public void UpdateCustomerAddress(customerId, address) {  // Command
    // تغییر وضعیت، چیزی برنمی‌گرداند
}

public Customer GetCustomer(customerId) {  // Query
    // برگرداندن داده، بدون عوارض جانبی
}
```

### Command Query Responsibility Segregation (CQRS)

CQRS با استفاده از **مدل‌های کاملاً جداگانه**، CQS را به سطح معماری گسترش می‌دهد:

| جنبه | CQS | CQRS |
|------|-----|------|
| **محدوده** | سطح متد/تابع | سطح سیستم/معماری |
| **مدل** | یک مدل دامنه | مدل‌های جداگانه خواندن و نوشتن |
| **ذخیره‌سازی داده** | پایگاه داده یکسان | می‌تواند از پایگاه‌های داده متفاوت استفاده کند |
| **پیچیدگی** | کم - اصل ساده | بالاتر - نیاز به همگام‌سازی |
| **مورد استفاده** | هر اپلیکیشنی | دامنه‌های پیچیده، نیازهای مقیاس‌پذیری متفاوت |

---

## 3. رویکرد CRUD سنتی در مقابل CQRS

### رویکرد CRUD سنتی

در یک اپلیکیشن سنتی، یک مدل واحد هم خواندن و هم نوشتن را ارائه می‌دهد:

```
┌─────────────────────────────────────────────────────────┐
│                    Client Application                    │
└───────────────────┬─────────────────────────────────────┘
                    │
                    │ (همه عملیات از همان مدل استفاده می‌کنند)
                    ▼
        ┌───────────────────────┐
        │   Application Layer   │
        │  (Business Logic)     │
        └───────────┬───────────┘
                    │
                    │ (Single Domain Model)
                    ▼
        ┌───────────────────────┐
        │    Domain Model       │
        │  - Customer           │
        │  - Order              │
        │  - Product            │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │      Database         │
        │  (Normalized Schema)  │
        └───────────────────────┘
```

**مشکلات این رویکرد:**

- کوئری‌های پیچیده نیاز به چندین JOIN دارند
- عملیات نوشتن باید در گراف‌های پیچیده اشیاء پیمایش کنند
- بهینه‌سازی برای هر دو خواندن و نوشتن دشوار است
- مدل واحد با annotationها و concernها پر می‌شود
- مقیاس‌پذیری خواندن و نوشتن با هم (ناکارآمد)

### رویکرد CQRS

CQRS این را به دو مسیر جداگانه تقسیم می‌کند:

```
┌─────────────────────────────────────────────────────────────────┐
│                      Client Application                          │
└────────────┬────────────────────────────────────┬────────────────┘
             │                                    │
     Commands│(Write)                     Queries│(Read)
             ▼                                    ▼
┌────────────────────────┐          ┌────────────────────────┐
│   Command Handlers     │          │    Query Handlers      │
│  (Business Logic)      │          │  (No Business Logic)   │
└────────────┬───────────┘          └────────────┬───────────┘
             │                                    │
             │                                    │
             ▼                                    ▼
┌────────────────────────┐          ┌────────────────────────┐
│   Write Model          │          │    Read Model          │
│  (Normalized)          │◀────────▶│  (Denormalized)        │
│  - Aggregates          │   Sync   │  - DTOs/Views          │
│  - Domain Logic        │          │  - Optimized Queries   │
└────────────┬───────────┘          └────────────┬───────────┘
             │                                    │
             ▼                                    ▼
┌────────────────────────┐          ┌────────────────────────┐
│   Write Database       │          │   Read Database(s)     │
│   (SQL, consistent)    │          │  (NoSQL, materialized) │
└────────────────────────┘          └────────────────────────┘
```

---

## 4. معماری CQRS

### کامپوننت‌های اصلی

```
                          ┌─────────────────────────┐
                          │    Client/API Layer     │
                          └───────┬──────────┬──────┘
                                  │          │
                        Commands  │          │  Queries
                                  │          │
              ┌───────────────────┘          └──────────────────┐
              │                                                  │
              ▼                                                  ▼
┌─────────────────────────┐                      ┌─────────────────────────┐
│   WRITE SIDE (Command)  │                      │   READ SIDE (Query)     │
│─────────────────────────│                      │─────────────────────────│
│                         │                      │                         │
│  1. Command Bus         │                      │  1. Query Bus           │
│  2. Command Handlers    │                      │  2. Query Handlers      │
│  3. Domain Model        │                      │  3. Read Model/DTOs     │
│  4. Aggregates          │                      │  4. Denormalized Views  │
│  5. Business Logic      │                      │                         │
│  6. Validation          │                      │  (بدون منطق کسب‌وکار،  │
│                         │                      │   فقط بازیابی داده)    │
│         │               │                      │                         │
│         ▼               │                      │         ▲               │
│  ┌──────────────┐      │                      │  ┌──────────────┐      │
│  │Write Database│      │                      │  │Read Database │      │
│  │  (Source of  │      │                      │  │(Optimized for│      │
│  │   Truth)     │      │                      │  │  Queries)    │      │
│  └──────┬───────┘      │                      │  └──────▲───────┘      │
│         │               │                      │         │               │
└─────────┼───────────────┘                      └─────────┼───────────────┘
          │                                                │
          │              ┌─────────────────┐              │
          └─────────────▶│  Event Stream   │──────────────┘
                         │  (Sync Mechanism)│
                         └─────────────────┘
```

### سمت نوشتن (Write Side - Command Model)

**مسئولیت‌ها:**

- پذیرش commandها (CreateOrder، UpdateCustomer، CancelPayment)
- اعتبارسنجی قوانین کسب‌وکار
- اجرای منطق کسب‌وکار
- ذخیره‌سازی در write store
- انتشار رویدادها برای همگام‌سازی سمت خواندن

**ویژگی‌ها:**

- سازگاری تراکنشی
- شامل منطق کامل دامنه
- ساختار داده normalized
- بهینه برای نوشتن
- منبع حقیقت (source of truth)

### سمت خواندن (Read Side - Query Model)

**مسئولیت‌ها:**

- پذیرش queryها (GetOrderById، SearchProducts، GetCustomerDashboard)
- بازیابی کارآمد داده
- برگرداندن DTOها/ViewModelها
- بدون منطق کسب‌وکار

**ویژگی‌ها:**

- سازگاری نهایی (معمولاً)
- Denormalized برای خواندن سریع
- می‌تواند از ذخیره‌سازی متفاوت استفاده کند (NoSQL، cache، search index)
- بهینه برای الگوهای کوئری خاص
- مشتق شده از سمت نوشتن

---

## 5. چگونه کار می‌کند: جریان گام‌به‌گام

### جریان عملیات نوشتن

```
مرحله 1: Command وارد می‌شود
┌──────────┐
│  Client  │ ─── CreateOrderCommand(userId, items) ───▶
└──────────┘

مرحله 2: Command Handler
                    ┌──────────────────────────┐
                    │   CreateOrderHandler     │
                    │  1. اعتبارسنجی command  │
                    │  2. بارگذاری aggregate  │
                    │  3. اجرای منطق کسب‌وکار │
                    │  4. ذخیره در write DB   │
                    │  5. انتشار رویدادها     │
                    └────────┬─────────────────┘
                             │
                             ▼
مرحله 3: نوشتن در Database
                    ┌──────────────────┐
                    │  Write Database  │
                    │  Orders Table    │
                    │  [رکورد جدید]    │
                    └────────┬─────────┘
                             │
                             ▼
مرحله 4: انتشار Event
                    ┌──────────────────┐
                    │   Event Bus      │
                    │ OrderCreatedEvent│
                    └────────┬─────────┘
                             │
                             ▼
مرحله 5: به‌روزرسانی Read Model
                    ┌──────────────────┐
                    │ Event Handler    │
                    │ به‌روزرسانی Read DB │
                    └────────┬─────────┘
                             │
                             ▼
                    ┌──────────────────┐
                    │  Read Database   │
                    │ Denormalized View│
                    └──────────────────┘
```

### جریان عملیات خواندن

```
مرحله 1: Query وارد می‌شود
┌──────────┐
│  Client  │ ─── GetOrderDetailsQuery(orderId) ───▶
└──────────┘

مرحله 2: Query Handler
                    ┌──────────────────────────┐
                    │  GetOrderDetailsHandler  │
                    │  1. دریافت query         │
                    │  2. اجرای کوئری ساده    │
                    │  3. برگرداندن DTO        │
                    │  (بدون منطق کسب‌وکار)   │
                    └────────┬─────────────────┘
                             │
                             ▼
مرحله 3: کوئری Read Database
                    ┌──────────────────┐
                    │  Read Database   │
                    │  OrderView Table │
                    │  (Denormalized)  │
                    └────────┬─────────┘
                             │
                             ▼
مرحله 4: برگرداندن داده
                    ┌──────────────────┐
                    │   OrderViewDTO   │
                    │  - orderId       │
                    │  - customerName  │
                    │  - items[]       │
                    │  - total         │
                    └──────────────────┘
```

---

## 6. CQRS با Event Sourcing

CQRS و [Event Sourcing](../event-driven/event-driven-architecture.fa.md) به طور طبیعی الگوهای مکمل یکدیگر هستند. در حالی که CQRS می‌تواند بدون Event Sourcing پیاده‌سازی شود، آن‌ها با هم به طور استثنایی خوب کار می‌کنند.

### مبانی Event Sourcing

به جای ذخیره وضعیت فعلی، Event Sourcing **تمام تغییرات را به عنوان یک دنباله از رویدادها** ذخیره می‌کند:

```
ذخیره‌سازی سنتی:              Event Sourcing:
┌─────────────────┐              ┌─────────────────────────────┐
│ Order Table     │              │     Event Store             │
│─────────────────│              │─────────────────────────────│
│ id: 123         │              │ OrderCreated (t1)           │
│ status: SHIPPED │              │ OrderPaid (t2)              │
│ total: $100     │              │ OrderShipped (t3)           │
│ items: [...]    │              │                             │
└─────────────────┘              │ وضعیت فعلی = پخش همه       │
 (فقط وضعیت فعلی)               └─────────────────────────────┘
                                  (تاریخچه کامل حفظ شده)
```

### معماری CQRS + Event Sourcing

```
                    WRITE SIDE
┌────────────────────────────────────────────┐
│  Command ──▶ Handler ──▶ Aggregate         │
│                          │                  │
│                          ▼                  │
│                    ┌─────────────┐         │
│                    │ Event Store │         │
│                    │ (Append-only)│        │
│                    │             │         │
│                    │ - Event1    │         │
│                    │ - Event2    │         │
│                    │ - Event3    │         │
│                    │ - ...       │         │
│                    └──────┬──────┘         │
│                           │                 │
└───────────────────────────┼─────────────────┘
                            │
                            │ رویدادها منتشر می‌شوند
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ▼                  ▼                  ▼
    ┌─────────┐       ┌─────────┐       ┌─────────┐
    │Read DB 1│       │Read DB 2│       │Read DB 3│
    │(SQL)    │       │(NoSQL)  │       │(Search) │
    └─────────┘       └─────────┘       └─────────┘
         ▲                  ▲                  ▲
         │                  │                  │
         └──────────────────┴──────────────────┘
                       READ SIDE
                  (چندین Projection)
```

**مزایای ترکیب CQRS با Event Sourcing:**

1. **تطابق طبیعی**: رویدادهای Event Store به مکانیزم همگام‌سازی تبدیل می‌شوند
2. **مسیر ممیزی کامل**: هر تغییری به طور دائمی ثبت می‌شود
3. **کوئری‌های زمانی**: می‌تواند وضعیت را در هر نقطه از زمان بازسازی کند
4. **چندین Projection**: رویدادهای یکسان می‌توانند read modelهای مختلف بسازند
5. **قابلیت Replay**: می‌تواند read modelها را با پخش مجدد رویدادها بازسازی کند

**مثال: ساخت Read Modelها از Events**

```
Event Stream:                      Projection 1: Order Summary
─────────────                      ────────────────────────────
OrderCreated                       OrderId | Customer | Status | Total
  orderId: 123                     ────────────────────────────
  customerId: 456                  123     | John     | Created| $0
  items: [...]

OrderPaid                          OrderId | Customer | Status | Total
  orderId: 123                     ────────────────────────────
  amount: $100                     123     | John     | Paid   | $100
  method: CreditCard

OrderShipped                       OrderId | Customer | Status | Total
  orderId: 123                     ────────────────────────────
  trackingId: ABC123               123     | John     | Shipped| $100
```

برای جزئیات بیشتر درباره الگوهای event به [معماری Event-Driven](../event-driven/event-driven-architecture.fa.md) مراجعه کنید.

---

## 7. استراتژی‌های همگام‌سازی

چالش کلیدی در CQRS حفظ همگام‌سازی read model با write model است.

### استراتژی 1: به‌روزرسانی‌های همزمان (Synchronous)

```
Command ──▶ Write DB ──▶ Update Read DB ──▶ Return
                 │              │
                 └──(همان تراکنش)──┘
```

**ویژگی‌ها:**

- Read model در همان تراکنش به‌روز می‌شود
- سازگاری قوی
- پیاده‌سازی ساده
- بدون مشکلات سازگاری نهایی

**معایب:**

- عملیات نوشتن و خواندن جفت می‌شوند
- عملیات نوشتن کندتر
- هر دو پایگاه داده باید در دسترس باشند
- برخی مزایای CQRS را از دست می‌دهد

**زمانی استفاده کنید که:**

- سازگاری قوی مورد نیاز است
- اپلیکیشن‌های کم‌مقیاس
- استقرار ساده

### استراتژی 2: ناهمزمان از طریق Events

```
Command ──▶ Write DB ──▶ Publish Event ──▶ Return (فوری)
                              │
                              ▼
                        Event Handler ──▶ Update Read DB
                        (اجرای async)
```

**ویژگی‌ها:**

- نوشتن سریع تکمیل می‌شود
- Read model به صورت ناهمزمان به‌روز می‌شود
- سازگاری نهایی
- سیستم‌های جداشده

**گزینه‌های پیاده‌سازی:**

برای سیستم‌های messaging، به مقایسه [RabbitMQ و Kafka](../messaging/rabbitmq-vs-kafka.fa.md) مراجعه کنید.

#### گزینه A: Message Queue

```
Write DB ──▶ RabbitMQ ──▶ Consumer ──▶ Read DB
```

- خوب برای توزیع تسک
- تحویل تضمین‌شده
- می‌تواند در بار بالا تاخیر داشته باشد

#### گزینه B: Event Stream

```
Write DB ──▶ Kafka ──▶ Stream Processor ──▶ Read DB
```

- قابلیت replay رویداد
- توان عملیاتی بالا
- ساخته‌شده برای معماری‌های event-driven

### استراتژی 3: Change Data Capture (CDC)

```
Write DB ──▶ CDC Tool (Debezium) ──▶ Event Stream ──▶ Read DB
            (نظارت بر لاگ‌های دیتابیس)
```

**ویژگی‌ها:**

- نیاز به کد اپلیکیشن ندارد
- تمام تغییرات را capture می‌کند
- تاخیر کم
- قابل اعتماد

**ابزارها:**

- Debezium (محبوب‌ترین)
- AWS DMS
- Maxwell's Daemon

### ملاحظات سازگاری

CQRS با به‌روزرسانی‌های async به معنای **سازگاری نهایی** است (به [قضیه CAP](../fundamentals/cap-theorem.fa.md) مراجعه کنید):

| جنبه | تاثیر | کاهش |
|------|-------|------|
| **خواندن‌های قدیمی** | کاربر ممکن است فوراً نوشته‌های خود را نبیند | برگرداندن version/timestamp به کلاینت، polling تا به‌روزرسانی |
| **Race Conditions** | چندین رویداد که همان read model را به‌روز می‌کنند | event handlerهای idempotent، versioning |
| **تاخیر همگام‌سازی** | Read model عقب‌تر از write model | نظارت بر متریک‌های تاخیر، بازخورد UI |
| **خرابی‌های جزئی** | رویداد منتشر شده اما read model به‌روز نشده | منطق retry، dead letter queues، نظارت |

**مدیریت "Read Your Writes":**

```
1. کلاینت command را ارسال می‌کند
   ──▶ سرور برمی‌گرداند: commandId, expectedVersion

2. کلاینت read model را کوئری می‌کند
   ──▶ شامل: expectedVersion در درخواست

3. Query handler چک می‌کند:
   if (readModel.version >= expectedVersion)
       return data
   else
       صبر کن یا وضعیت "در حال پردازش" برگردان
```

---

## 8. بهینه‌سازی Read Model

CQRS به شما اجازه می‌دهد read modelها را به طور خاص برای الگوهای کوئری بهینه کنید.

### چندین Read Model

read modelهای مختلف برای موارد استفاده مختلف ایجاد کنید:

```
                        Event Stream
                              │
          ┌───────────────────┼───────────────────┐
          │                   │                   │
          ▼                   ▼                   ▼
    ┌──────────┐        ┌──────────┐       ┌──────────┐
    │ SQL View │        │ Redis    │       │Elasticsearch│
    │ (Reports)│        │ (Cache)  │       │ (Search) │
    └──────────┘        └──────────┘       └──────────┘
         │                   │                   │
         ▼                   ▼                   ▼
    GetSalesReport     GetProductById      SearchProducts
```

### استراتژی‌های Denormalization

#### استراتژی 1: Viewهای کاملاً Denormalized

**Write Model (Normalized):**

```
Orders Table              Customers Table        Products Table
─────────────             ─────────────          ─────────────
orderId                   customerId             productId
customerId (FK)           name                   name
orderDate                 email                  price
```

**Read Model (Denormalized):**

```
OrderView Table
─────────────────────────
orderId
orderDate
customerName            ← Denormalized
customerEmail           ← Denormalized
totalAmount             ← محاسبه‌شده
itemCount               ← محاسبه‌شده
productNames[]          ← آرایه Denormalized
shippingStatus
```

**مزایا:**

- یک کوئری برای دریافت تمام داده
- نیاز به JOIN ندارد
- خواندن سریع

**معایب:**

- تکرار داده
- ذخیره‌سازی بیشتر
- باید چندین جا را به‌روز کند

#### استراتژی 2: Materialized Views

کوئری‌های پرهزینه را از پیش محاسبه کنید:

```
Event: OrderPlaced
  ──▶ Update: DailySalesView
              MonthlySalesView
              CustomerLifetimeValue
              ProductPopularity
```

#### استراتژی 3: پایگاه‌های داده ترکیبی (Hybrid)

از پایگاه‌های داده مختلف برای خواندن در مقابل نوشتن استفاده کنید:

```
Write Side:                   Read Side:
┌─────────────┐              ┌─────────────────────────┐
│ PostgreSQL  │              │ MongoDB (کوئری سریع)    │
│ (ACID)      │─────────────▶│ Redis (caching)         │
│ (normalized)│   Events     │ Elasticsearch (search)  │
└─────────────┘              └─────────────────────────┘
```

**ترکیب‌های نمونه:**

| Write Database | Read Database(s) | مورد استفاده |
|----------------|------------------|---------------|
| PostgreSQL | PostgreSQL views | CQRS ساده، همان DB |
| PostgreSQL | MongoDB | کوئری‌های پیچیده، schema انعطاف‌پذیر |
| PostgreSQL | Redis | caching با سرعت بالا |
| PostgreSQL | Elasticsearch | جستجوی متن کامل |
| PostgreSQL | Redis + MongoDB | چندمنظوره (cache + کوئری) |

### Caching در CQRS

```
جریان Query با Cache:

Query ──▶ Check Cache ──▶ [Hit?] ──Yes──▶ Return
                │
                No
                │
                ▼
         Query Read DB ──▶ Update Cache ──▶ Return


جریان Event:

Event ──▶ Update Read DB ──▶ Invalidate Cache
                               (یا update cache)
```

---

## 9. مبادلات (Trade-offs)

### مزایا

| مزیت | توضیح | تاثیر |
|------|-------|-------|
| **مقیاس‌پذیری مستقل** | مقیاس‌پذیری جداگانه خواندن و نوشتن | اپلیکیشن‌های read-heavy می‌توانند سمت خواندن را به طور مستقل مقیاس دهند (اکثر اپ‌ها 90%+ خواندن هستند) |
| **مدل‌های بهینه** | هر سمت برای هدف خود بهینه | نوشتن: normalized، منطق کسب‌وکار. خواندن: denormalized، کوئری سریع |
| **عملکرد** | خواندن‌ها با نوشتن‌ها رقابت نمی‌کنند | زمان پاسخ بهتر برای هر دو عملیات |
| **کوئری‌های ساده‌شده** | بدون JOINهای پیچیده | viewهای denormalized از پیش join شده بسیار سریع‌ترند |
| **چندین Read Model** | viewهای مختلف برای نیازهای مختلف | search index + cache + reporting DB همه از همان write model |
| **Event-Driven** | تطابق طبیعی برای event sourcing | مسیر ممیزی کامل، کوئری‌های زمانی، replay رویداد |
| **انتخاب تکنولوژی** | استفاده از بهترین ابزار برای هر کار | SQL برای نوشتن، NoSQL برای خواندن، موتور جستجو برای متن کامل |

### معایب

| معایب | توضیح | کاهش |
|-------|-------|------|
| **پیچیدگی** | دو مدل به جای یکی | فقط زمانی استفاده کنید که مزایا بیش از هزینه پیچیدگی باشد |
| **سازگاری نهایی** | خواندن‌ها ممکن است قدیمی باشند | بازخورد UI، versioning، نظارت بر تاخیر |
| **همگام‌سازی داده** | باید مدل‌ها را همگام نگه دارید | مدیریت رویداد قوی، retryها، نظارت |
| **سربار عملیاتی** | کامپوننت‌های بیشتر برای deploy/نظارت | شیوه‌های DevOps خوب، اتوماسیون |
| **منحنی یادگیری** | تیم باید الگو را درک کند | آموزش، مستندات، شروع ساده |
| **دشواری debugging** | سیستم‌های توزیع‌شده سخت‌تر برای debug | Correlation IDها، distributed tracing، لاگینگ خوب |
| **تکرار داده** | داده یکسان در چندین جا | پذیرش به عنوان مبادله برای عملکرد |

### تحلیل هزینه-فایده

```
پیچیدگی Application
        ▲
        │                    ┌──────────────┐
  بالا  │                    │CQRS+ES ارزشش را دارد│
        │                    │              │
        │          ┌─────────┤              │
        │          │ CQRS    │              │
        │          │ارزشش را دارد│              │
  متوسط │    ┌─────┤         │              │
        │    │CRUD │         │              │
        │    │بهترین│         │              │
  پایین │    │     │         │              │
        └────┴─────┴─────────┴──────────────┴──▶
           ساده    الگوهای    Event-Driven
                   خواندن/نوشتن  + دامنه
                   متفاوت       پیچیده
```

---

## 10. چه زمانی استفاده کنیم / چه زمانی اجتناب کنیم

### از CQRS استفاده کنید وقتی:

1. **الگوهای خواندن/نوشتن متفاوت**
   - نوشتن پیچیده با منطق کسب‌وکار
   - خواندن ساده با نیاز به پاسخ سریع
   - مثال: پردازش سفارش (پیچیده) در مقابل مرور کاتالوگ محصول (ساده)

2. **نیازهای مقیاس‌پذیری متفاوت**
   - بار کاری read-heavy (بیش از 90% خواندن)
   - نیاز به مقیاس‌پذیری مستقل خواندن
   - مثال: فید رسانه اجتماعی، لیست محصولات e-commerce

3. **چندین نمایش خواندن**
   - نیاز به viewهای مختلف از داده یکسان
   - نیازمندی‌های جستجو، گزارش‌گیری، caching
   - مثال: داشبورد آنالیتیکس + API + جستجو

4. **نیازمندی‌های عملکرد**
   - خواندن باید بسیار سریع باشد
   - JOINهای پیچیده خیلی کند هستند
   - مثال: سایت e-commerce با ترافیک بالا

5. **معماری Event-Driven**
   - در حال استفاده از event sourcing
   - microserviceهای event-driven
   - مثال: پیاده‌سازی‌های [الگوی Saga](../distributed-transactions/saga.fa.md)

6. **منطق دامنه پیچیده**
   - مدل دامنه غنی در سمت نوشتن
   - DTOهای ساده در سمت خواندن
   - مثال: سیستم‌های بانکی، سیستم‌های رزرو

### از CQRS اجتناب کنید وقتی:

1. **اپلیکیشن‌های CRUD ساده**
   - ایجاد، خواندن، به‌روزرسانی، حذف پایه
   - بدون منطق کسب‌وکار پیچیده
   - بدون نیازمندی‌های مقیاس‌پذیری
   - مثال: پنل‌های ادمین ساده، ابزارهای داخلی کوچک

2. **سازگاری قوی مورد نیاز**
   - نمی‌توان سازگاری نهایی را تحمل کرد
   - باید فوراً نوشته‌های خود را بخواند
   - مثال: برخی تراکنش‌های مالی (هرچند [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) می‌تواند کمک کند)

3. **تیم کوچک/استارتاپ اولیه**
   - منابع محدود
   - نیاز به حرکت سریع
   - پیچیدگی توجیه ندارد
   - با CRUD شروع کنید، در صورت نیاز به CQRS مهاجرت کنید

4. **دامنه ساده**
   - بدون قوانین کسب‌وکار پیچیده
   - الگوهای خواندن/نوشتن مشابه
   - بدون نگرانی مقیاس‌پذیری
   - مثال: مدیریت پیکربندی، ورود داده ساده

5. **ترافیک کم**
   - کاربران کم
   - بدون گلوگاه عملکرد
   - معماری سنتی خوب کار می‌کند

### چارچوب تصمیم‌گیری

```
┌─────────────────────────────────────┐
│ آیا دامنه شما پیچیده است؟          │
└─────────────┬───────────────────────┘
              │
         خیر  │   بله
              │
    ┌─────────▼─────────┐
    │ از معماری        │
    │ CRUD سنتی استفاده│
    │      کنید         │
    └───────────────────┘
              │
              │ بله
              ▼
┌─────────────────────────────────────┐
│ آیا الگوهای خواندن/نوشتن بسیار     │
│ متفاوت یا نیازهای مقیاس‌پذیری دارید؟│
└─────────────┬───────────────────────┘
              │
         خیر  │   بله
              │
    ┌─────────▼─────────┐
    │ CQRS ساده را در  │
    │ نظر بگیرید (همان DB)│
    └─────────┬─────────┘
              │
              │ بله
              ▼
┌─────────────────────────────────────┐
│ نیاز به event sourcing، چندین     │
│ read model، یا [Microservices](../architecture/microservices.fa.md) دارید؟│
└─────────────┬───────────────────────┘
              │
              │ بله
              ▼
    ┌─────────────────┐
    │ CQRS کامل با    │
    │ Event Sourcing  │
    └─────────────────┘
```

---

## 11. مثال‌های دنیای واقعی

### مثال 1: کاتالوگ محصول E-commerce

**سناریو**: پلتفرم e-commerce بزرگ با میلیون‌ها محصول، ترافیک خواندن بالا، به‌روزرسانی‌های محصول گاه‌به‌گاه.

**نیازمندی‌ها**:

- خواندن: 100,000 کوئری/ثانیه (مرور، جستجو)
- نوشتن: 100 به‌روزرسانی/ثانیه (تغییرات اطلاعات محصول)
- الگوهای دسترسی متفاوت: جستجو، فیلتر، پیشنهادها

**پیاده‌سازی CQRS**:

```
WRITE SIDE:
───────────
Command: UpdateProductCommand
  ├─ اعتبارسنجی قوانین کسب‌وکار
  ├─ به‌روزرسانی جداول normalized
  │   ├─ Products
  │   ├─ Categories
  │   ├─ Inventory
  └─ انتشار: ProductUpdatedEvent

         │
         ▼
    Event Stream
         │
         ├────────────────┬────────────────┬────────────────┐
         ▼                ▼                ▼                ▼

READ SIDE:
──────────
1. PostgreSQL           2. Elasticsearch      3. Redis
   (Reporting)             (Search)              (Cache)

   ProductReports         ProductDocument       ProductCache
   - آنالیتیکس فروش      - جستجوی متن کامل    - محصولات داغ
   - گزارش موجودی         - فیلترهای faceted   - اخیراً مشاهده شده
   - آمار فروشنده        - Autocomplete        - جستجوهای سریع

مثال‌های QUERY:
───────────────
SearchProducts(query)        ──▶ Elasticsearch
GetProductById(id)           ──▶ Redis (cache) → PostgreSQL (fallback)
GetProductAnalytics(id)      ──▶ PostgreSQL analytical views
GetRecommendations(userId)   ──▶ Redis (از پیش محاسبه شده)
```

**نتایج**:

- تاخیر خواندن: <50ms (از cache/search index)
- تاخیر نوشتن: <200ms (به‌روزرسانی‌های async)
- مقیاس‌پذیری: می‌تواند replicaهای خواندن را به طور مستقل مقیاس دهد
- ذخیره‌سازی: تکرار داده 3 برابر، اما عملکرد کوئری هزینه را توجیه می‌کند

### مثال 2: سیستم دفتر کل بانکی

**سناریو**: اپلیکیشن بانکی ردیابی تراکنش‌های حساب با نیازمندی‌های ممیزی سخت‌گیرانه.

**نیازمندی‌ها**:

- هر تراکنش باید به طور دائمی ثبت شود
- موجودی حساب باید دقیق باشد
- مسیر ممیزی برای انطباق
- کوئری‌های موجودی سریع
- موجودی تاریخی در هر نقطه از زمان

**پیاده‌سازی CQRS + Event Sourcing**:

```
WRITE SIDE:
───────────
Command: TransferMoneyCommand
  fromAccount: ACC001
  toAccount: ACC002
  amount: $1000

         │
         ▼
    Account Aggregate
    (منطق دامنه)
    - اعتبارسنجی موجودی کافی
    - بررسی وضعیت حساب
    - اعمال قوانین کسب‌وکار
         │
         ▼
    Event Store (فقط-افزودن)
    ┌─────────────────────────────────┐
    │ MoneyDebited                    │
    │   account: ACC001               │
    │   amount: $1000                 │
    │   timestamp: 2024-01-15T10:00   │
    ├─────────────────────────────────┤
    │ MoneyCredited                   │
    │   account: ACC002               │
    │   amount: $1000                 │
    │   timestamp: 2024-01-15T10:00   │
    └─────────────────────────────────┘
    (مسیر ممیزی کامل حفظ شده)
         │
         ▼
    Event Projection
         │
         ├─────────────────┬────────────────┐
         ▼                 ▼                ▼

READ SIDE:
──────────
1. Account Balance       2. Transaction      3. Daily Summary
   (وضعیت فعلی)            History             (آنالیتیکس)

   ACC001: $5,000          ACC001 Txns        تاریخ    | حجم
   ACC002: $3,000          - بدهکار $1000     01/15    | $50,000
   ACC003: $1,200          - بستانکار $500    01/14    | $48,000
                           - ...

مثال‌های QUERY:
───────────────
GetAccountBalance(accountId)              ──▶ Balance View
GetTransactionHistory(accountId)          ──▶ Transaction View
GetBalanceAtDate(accountId, date)         ──▶ پخش رویدادها تا تاریخ
GetDailySummary(startDate, endDate)       ──▶ Analytics View
```

**مزایا**:

- مسیر ممیزی کامل (انطباق نظارتی)
- می‌تواند وضعیت حساب را در هر زمان بازسازی کند
- کوئری‌های موجودی سریع (materialized view)
- پشتیبانی از کوئری‌های زمانی
- چندین projection برای گزارش‌های مختلف

**مثال Event Replay**:

```
دریافت موجودی ACC001 در 2024-01-10:

1. بارگذاری تمام رویدادها برای ACC001 قبل از 2024-01-10
2. پخش رویدادها به ترتیب:
   AccountOpened        ──▶ Balance: $0
   MoneyDeposited($5000)──▶ Balance: $5,000
   MoneyWithdrawn($500) ──▶ Balance: $4,500
   MoneyCredited($1000) ──▶ Balance: $5,500

3. برگرداندن: $5,500 (موجودی در 2024-01-10)
```

---

## 12. اشتباهات رایج

### اشتباه 1: استفاده از CQRS برای CRUD ساده

**مشکل**: اعمال CQRS به یک اپلیکیشن ساده، پیچیدگی غیرضروری اضافه می‌کند.

```
بد: اپلیکیشن ساده وبلاگ با استفاده از CQRS
     - CreatePostCommand
     - PostCreatedEvent
     - پایگاه‌های داده جداگانه خواندن/نوشتن
     - سازگاری نهایی
     (پیچیدگی بیش از مزایاست)

خوب: CRUD ساده برای وبلاگ
     - عملیات مستقیم پایگاه داده
     - ORM سنتی
     - ساده و قابل نگهداری
```

**چه زمانی اجتناب کنید**: اگر اپلیکیشن شما بیشتر CRUD ساده بدون منطق دامنه پیچیده است، به معماری سنتی بچسبید.

### اشتباه 2: به‌روزرسانی‌های همزمان که هدف را باطل می‌کنند

**مشکل**: به‌روزرسانی read model به صورت همزمان در همان تراکنش.

```
بد:
┌────────────────────────────────┐
│ Begin Transaction              │
│   1. Update write database     │
│   2. Update read database      │ ← جفت شدگی سفت
│   3. Commit both               │
└────────────────────────────────┘

خوب:
Command ──▶ Update Write DB ──▶ Publish Event ──▶ Return
                                       │
                                       ▼
                              Async Handler ──▶ Update Read DB
```

**چرا بد است**: مزایای مقیاس‌پذیری مستقل را از دست می‌دهد، جفت شدگی ایجاد می‌کند، نوشتن کندتر.

### اشتباه 3: مدیریت نکردن سازگاری نهایی

**مشکل**: کاربران پس از عملیات نوشتن داده قدیمی می‌بینند.

```
سناریوی مشکل:
1. کاربر سفارش ایجاد می‌کند ──▶ Command پردازش شد
2. کاربر فوراً کوئری می‌کند ──▶ سفارش هنوز در read model نیست
3. کاربر می‌بیند: "سفارش یافت نشد" ← تجربه بد
```

**راه حل**:

```
رویکرد بهتر:
1. Command برمی‌گرداند: commandId, expectedVersion
2. UI نشان می‌دهد: "در حال پردازش..." با polling
3. کوئری با بررسی version:
   if (readModel.version >= expectedVersion)
       نمایش سفارش
   else
       همچنان "در حال پردازش" نمایش بده
```

### اشتباه 4: نداشتن Event Handlerهای Idempotent

**مشکل**: رویداد دو بار تحویل داده شد، read model دو بار به‌روز شد.

```
بد:
Event: ProductStockIncreased(productId: 123, amount: 10)
Handler: stock = stock + 10

اگر رویداد دوبار تحویل داده شود:
  اول:  stock = 100 + 10 = 110 ✓
  دوم: stock = 110 + 10 = 120 ✗ (باید 110 باشد)
```

**راه حل - Handler Idempotent**:

```
خوب:
Event: ProductStockIncreased(eventId, productId: 123, amount: 10)
Handler:
  if (eventId قبلاً پردازش شده)
      return (تکراری را نادیده بگیر)
  else
      stock = stock + 10
      ثبت eventId به عنوان پردازش‌شده
```

### اشتباه 5: تعداد زیاد Read Model

**مشکل**: ایجاد یک read model برای هر کوئری.

```
بد:
- GetOrderByIdReadModel
- GetOrderByCustomerReadModel
- GetOrderByDateReadModel
- GetOrderByStatusReadModel
- ... (100+ read model)
```

**راه حل**: read modelها را برای **الگوهای دسترسی** بسازید، نه کوئری‌های فردی:

```
خوب:
- OrderSummaryView (پوشش اکثر کوئری‌های سفارش)
- OrderSearchIndex (Elasticsearch برای جستجوهای پیچیده)
- OrderAnalyticsView (برای گزارش‌گیری)
```

### اشتباه 6: نادیده گرفتن نظارت و مشاهده‌پذیری

**مشکل**: دید به تاخیر همگام‌سازی یا خرابی‌ها وجود ندارد.

**باید نظارت شود**:

```
متریک‌های کلیدی:
├─ Event Processing Lag (زمان از نوشتن تا به‌روزرسانی خواندن)
├─ Event Handler Failures
├─ وضعیت همگام‌سازی Read Model
├─ عملکرد Query (تاخیر P95, P99)
├─ زمان پردازش Command
└─ اندازه Dead Letter Queue

هشدارها:
├─ تاخیر > 5 ثانیه
├─ نرخ خرابی handler > 1%
├─ Dead letter queue در حال رشد
└─ تاخیر کوئری > SLA
```

### اشتباه 7: نداشتن استراتژی Versioning

**مشکل**: نمی‌توان رویدادها را بدون شکستن consumerها تکامل داد.

```
بد:
OrderCreatedEvent v1 { orderId, amount }

بعداً نیاز به اضافه کردن customerId:
OrderCreatedEvent v1 { orderId, amount, customerId } ← consumerهای قدیمی را می‌شکند

خوب - استراتژی Versioning:
OrderCreatedEvent_v1 { orderId, amount }
OrderCreatedEvent_v2 { orderId, amount, customerId }

Event Handler:
  switch (event.version) {
    case 1: handle_v1(event)
    case 2: handle_v2(event)
  }
```

---

## 13. چارچوب مصاحبه و نکات کلیدی

### هنگامی که در مصاحبه درباره CQRS سوال می‌شود

**گام 1: مشکل را روشن کنید**

- "الگوهای خواندن در مقابل نوشتن چیست؟"
- "نیازمندی‌های مقیاس‌پذیری چیست؟"
- "آیا سازگاری نهایی قابل قبول است؟"
- "پیچیدگی دامنه چیست؟"

**گام 2: ساده شروع کنید، پیچیدگی اضافه کنید**

```
سطح 1: CRUD سنتی
  └─ اگر نیازمندی‌ها الگوهای متفاوت نشان می‌دهند...

سطح 2: CQRS ساده (همان پایگاه داده)
  └─ اگر نیاز به مقیاس‌پذیری مستقل...

سطح 3: CQRS با پایگاه‌های داده جداگانه
  └─ اگر نیاز به event sourcing یا مسیر ممیزی...

سطح 4: CQRS + Event Sourcing + چندین Read Model
```

**گام 3: درباره مبادلات بحث کنید**

همیشه ذکر کنید:

- پیامدهای سازگاری نهایی
- پیچیدگی عملیاتی
- تخصص تیم مورد نیاز
- چه زمانی CQRS را استفاده نکنید

**گام 4: دیاگرام معماری**

معماری را رسم کنید:

```
┌─────────┐
│ Client  │
└────┬────┘
     │
     ├─────── Commands ─────▶ [Write Model] ─────▶ [Write DB]
     │                             │
     │                             ▼
     │                        [Event Bus]
     │                             │
     │                             ▼
     └─────── Queries  ─────▶ [Read Model] ◀───── [Read DB]
```

### نکات کلیدی

1. **CQRS خواندن و نوشتن را جدا می‌کند** به مدل‌های مختلف، امکان بهینه‌سازی و مقیاس‌پذیری مستقل را فراهم می‌کند.

2. **یک انتخاب پیش‌فرض نیست** - از CQRS استفاده کنید وقتی الگوهای واضح متفاوت برای خواندن و نوشتن دارید، یا نیازهای مقیاس‌پذیری قابل توجه.

3. **سازگاری نهایی** معمولاً مبادله است. سیستم و UI خود را طراحی کنید تا آن را به خوبی مدیریت کند.

4. **تطابق طبیعی با Event Sourcing** - رویدادها به مکانیزم همگام‌سازی بین write و read modelها تبدیل می‌شوند.

5. **چندین read model** - یکی از بزرگترین مزایا ایجاد viewهای تخصصی برای الگوهای کوئری مختلف است.

6. **هزینه پیچیدگی** - نیاز به مدیریت رویداد قوی، نظارت و تخصص عملیاتی دارد. فقط زمانی استفاده کنید که مزایا هزینه را توجیه کنند.

7. **ساده شروع کنید** - می‌توانید با CQRS ساده (همان پایگاه داده) شروع کنید و در صورت نیاز به جداسازی کامل تکامل یابید.

8. **Idempotency مهم است** - event handlerها باید idempotent باشند تا تحویل‌های تکراری را مدیریت کنند.

9. **نظارت حیاتی است** - باید تاخیر همگام‌سازی، خرابی‌ها و متریک‌های عملکرد را ردیابی کنید.

10. **آمادگی تیم** - تیم باید سیستم‌های توزیع‌شده، سازگاری نهایی و الگوهای event-driven را درک کند.

### الگوهای مرتبط

- [معماری Event-Driven](../event-driven/event-driven-architecture.fa.md) - مکمل طبیعی CQRS
- [الگوی Saga](../distributed-transactions/saga.fa.md) - تراکنش‌های توزیع‌شده در سیستم‌های CQRS
- [قضیه CAP](../fundamentals/cap-theorem.fa.md) - درک مبادلات سازگاری
- [RabbitMQ در مقابل Kafka](../messaging/rabbitmq-vs-kafka.fa.md) - انتخاب messaging برای همگام‌سازی رویداد
- [Microservices](../architecture/microservices.fa.md) - CQRS معمولاً در معماری‌های microservice استفاده می‌شود

### مطالعه بیشتر

- **"Implementing Domain-Driven Design"** از Vaughn Vernon - CQRS در زمینه DDD
- **"Versioning in an Event Sourced System"** از Greg Young
- **Microsoft CQRS Journey** - راهنمای جامع با پیاده‌سازی واقعی
- **مقاله Martin Fowler درباره CQRS** - مرور مفهومی روشن
- **الگوی Event Sourcing** در microservices.io

---

**به یاد داشته باشید**: CQRS یک الگوی قدرتمند است که مشکلات خاصی را حل می‌کند. این یک گلوله نقره‌ای نیست. زمانی از آن استفاده کنید که مزایا به وضوح بیش از هزینه پیچیدگی باشد، و تیم شما آماده مدیریت چالش‌های عملیاتی سیستم‌های توزیع‌شده باشد.
