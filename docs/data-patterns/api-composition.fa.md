# ترکیب API (API Composition)

## 1. مقدمه

**ترکیب API (API Composition)** الگویی برای پیاده‌سازی کوئری‌ها در معماری میکروسرویس‌ها است که با فراخوانی APIهای چندین سرویس و ترکیب نتایج در حافظه انجام می‌شود. به جای اجرای یک SQL JOIN واحد در جداول مختلف (مانند معماری یکپارچه)، یک API Composer داده‌ها را از هر سرویس مالک به طور جداگانه دریافت می‌کند و پاسخ‌ها را قبل از بازگشت به کلاینت ادغام می‌کند.

این الگو به طور طبیعی زمانی ظاهر می‌شود که استراتژی [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) را اتخاذ کنید. وقتی هر سرویس مالک ذخیره‌سازی داده خودش است، کوئری‌های بین‌سرویسی دیگر نمی‌توانند بر joinهای سطح پایگاه داده تکیه کنند. ترکیب API روشی مستقیم برای پاسخ به آن کوئری‌ها بدون معرفی پایگاه‌های داده مشترک یا زیرساخت اضافی ارائه می‌دهد.

### چرا اهمیت دارد

در یک اپلیکیشن یکپارچه معمولی، پاسخ به سوالی مثل "صفحه جزئیات سفارش را نشان بده" یک کوئری SQL واحد است که جداول سفارشات، مشتریان، محصولات و ارسال را join می‌کند. در دنیای میکروسرویس‌ها، این جداول در سرویس‌های مختلف با پایگاه‌های داده متفاوت قرار دارند. ترکیب API ساده‌ترین الگو برای پر کردن این شکاف است.

**ویژگی‌های کلیدی:**

- از چندین API سرویس برای جمع‌آوری داده‌ها کوئری می‌گیرد
- نتایج را در حافظه ترکیب (join، تجمیع، فیلتر) می‌کند
- می‌تواند در [API Gateway](../architecture/api-gateway.fa.md) یا یک سرویس اختصاصی پیاده‌سازی شود
- با هر سرویسی بدون توجه به پشته فناوری آن کار می‌کند
- هیچ زیرساخت اضافی فراتر از خود سرویس‌ها نیاز ندارد

---

## 2. زمینه و مسئله

### چالش داده در میکروسرویس‌ها

وقتی یک اپلیکیشن یکپارچه را به میکروسرویس‌ها با [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) تجزیه می‌کنید، هر سرویس به طور انحصاری مالک داده‌های خود است:

```
MONOLITH (پایگاه داده واحد)
┌──────────────────────────────────────────────┐
│                  Database                     │
│                                              │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐    │
│  │  Orders   │ │Customers │ │ Products │    │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘    │
│       │             │            │           │
│       └─────────────┴────────────┘           │
│              SQL JOIN                        │
│  SELECT o.*, c.name, p.title                 │
│  FROM orders o                               │
│  JOIN customers c ON o.customer_id = c.id    │
│  JOIN products p  ON o.product_id  = p.id    │
└──────────────────────────────────────────────┘
        ساده. یک کوئری. تمام.


MICROSERVICES (پایگاه داده به ازای هر سرویس)
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Order Service│  │Customer Svc  │  │Product Svc   │
│  ┌────────┐  │  │  ┌────────┐  │  │  ┌────────┐  │
│  │OrdersDB│  │  │  │CustDB  │  │  │  │ProdDB  │  │
│  └────────┘  │  │  └────────┘  │  │  └────────┘  │
└──────────────┘  └──────────────┘  └──────────────┘
       ?                 ?                 ?
       └─────────────────┴─────────────────┘
         چگونه در این سرویس‌ها JOIN کنیم؟
```

### مسئله اصلی

**چگونه کوئری‌هایی را پیاده‌سازی کنیم که نیاز به بازیابی داده‌های متعلق به چندین سرویس دارند، وقتی دیگر نمی‌توانیم SQL JOIN در مرزهای سرویس انجام دهیم؟**

به عنوان مثال، صفحه جزئیات سفارش یک فروشگاه آنلاین نیاز دارد:

| داده | سرویس مالک |
|------|-----------|
| شناسه سفارش، وضعیت، مجموع | سرویس سفارش |
| نام مشتری، ایمیل | سرویس مشتری |
| نام محصولات، تصاویر | سرویس محصول |
| شماره پیگیری، زمان تحویل | سرویس ارسال |

در یک اپلیکیشن یکپارچه، این یک کوئری است. در میکروسرویس‌ها، داده‌ها در چهار سرویس مستقل با چهار پایگاه داده مستقل پراکنده هستند.

---

## 3. نیروها (Forces)

چندین نیرو راه‌حل این مسئله را شکل می‌دهند:

| نیرو | توضیح |
|------|-------|
| **مالکیت داده** | هر سرویس مالک داده‌های خود است؛ پایگاه داده مشترک مجاز نیست |
| **پیچیدگی کوئری** | برخی کوئری‌ها به داده‌هایی از دو یا چند سرویس نیاز دارند |
| **عملکرد** | کاربران نهایی پاسخ سریع (< 500ms) حتی برای کوئری‌های ترکیبی انتظار دارند |
| **سادگی** | راه‌حل باید آسان برای درک، پیاده‌سازی و نگهداری باشد |
| **دسترس‌پذیری** | خرابی جزئی سرویس‌ها لزوماً نباید کل کوئری را شکست دهد |
| **سازگاری** | داده‌های سرویس‌های مختلف ممکن است در نقاط زمانی کمی متفاوت باشند |
| **استقلال سرویس** | سرویس‌ها باید به طور مستقل قابل استقرار و تکامل باقی بمانند |
| **تنوع فناوری** | سرویس‌ها ممکن است از زبان‌ها، فریم‌ورک‌ها و پایگاه‌های داده متفاوت استفاده کنند |

تنش واضح است: شما باید داده‌ها را از منابع متعدد ترکیب کنید در حالی که سرویس‌ها را جداگانه نگه دارید، عملکرد معقول حفظ کنید و خرابی‌ها را به خوبی مدیریت کنید.

---

## 4. راه‌حل

### الگوی ترکیب API

یک **API Composer** (همچنین aggregator نامیده می‌شود) بین کلاینت و سرویس‌های بک‌اند قرار می‌گیرد. یک درخواست واحد از کلاینت دریافت می‌کند، به چندین سرویس fan-out می‌کند، پاسخ‌های آنها را جمع‌آوری می‌کند و نتایج را در یک پاسخ واحد ادغام می‌کند.

### نحوه کار گام به گام

```
مرحله 1: کلاینت یک درخواست واحد ارسال می‌کند

┌──────────┐
│  Client  │ ─── GET /order-details/789 ───▶
└──────────┘

مرحله 2: API Composer درخواست را دریافت و سرویس‌های مورد نیاز را شناسایی می‌کند

┌────────────────────────────────────────────┐
│            API Composer                     │
│                                            │
│  Request: GET /order-details/789           │
│                                            │
│  Plan:                                     │
│   1. Order Service   → GET /orders/789     │
│   2. Customer Service→ GET /customers/456  │
│   3. Product Service → GET /products/101   │
│   4. Shipping Service→ GET /shipments/789  │
└────────────────────────────────────────────┘

مرحله 3: API Composer سرویس‌ها را به صورت موازی فراخوانی می‌کند

┌────────────────────────────────────────────┐
│            API Composer                     │
│                                            │
│  ┌────────────┐ ┌────────────┐            │
│  │  Thread 1  │ │  Thread 2  │            │
│  │Order Svc   │ │Customer Svc│            │
│  │  45ms      │ │  30ms      │            │
│  └────────────┘ └────────────┘            │
│  ┌────────────┐ ┌────────────┐            │
│  │  Thread 3  │ │  Thread 4  │            │
│  │Product Svc │ │Shipping Svc│            │
│  │  55ms      │ │  40ms      │            │
│  └────────────┘ └────────────┘            │
│                                            │
│  زمان کل: ~55ms                           │
│  (محدود به کندترین فراخوانی)               │
└────────────────────────────────────────────┘

مرحله 4: API Composer نتایج را ترکیب و به کلاینت برمی‌گرداند

┌────────────────────────────────────────────┐
│            API Composer                     │
│                                            │
│  Combined Response:                        │
│  {                                         │
│    orderId: 789,                           │
│    status: "shipped",                      │
│    customer: { name: "Alice", ... },       │
│    products: [ { name: "Widget", ... } ],  │
│    shipping: { tracking: "TRK123", ... }   │
│  }                                         │
└────────────────────────────────────────────┘
          │
          ▼
     ┌──────────┐
     │  Client  │  ◀── پاسخ تجمیع‌شده واحد
     └──────────┘
```

### نمودار جریان سطح بالا

```
┌──────────┐         ┌───────────────────────────────────────────────┐
│          │  (1)    │              API Composer                      │
│  Client  │────────▶│                                               │
│          │         │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐     │
│          │         │  │Svc A │  │Svc B │  │Svc C │  │Svc D │     │
│          │◀────────│  │  ▼   │  │  ▼   │  │  ▼   │  │  ▼   │     │
│          │  (6)    │  │Resp A│  │Resp B│  │Resp C│  │Resp D│     │
└──────────┘         │  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘     │
                     │     │         │         │         │          │
                     │     └─────────┴─────────┴─────────┘          │
                     │                    │                          │
                     │              (5) ترکیب                       │
                     │                    │                          │
                     │              نتیجه ادغام شده                  │
                     └───────────────────────────────────────────────┘

  (1) کلاینت درخواست ارسال می‌کند
  (2) Composer به سرویس A fan-out می‌کند  ─┐
  (3) Composer به سرویس B fan-out می‌کند  ─┤ به صورت موازی
  (4) Composer به سرویس C fan-out می‌کند  ─┤
      Composer به سرویس D fan-out می‌کند  ─┘
  (5) Composer تمام پاسخ‌ها را ادغام می‌کند
  (6) Composer نتیجه ترکیبی را به کلاینت برمی‌گرداند
```

### دو رویکرد پیاده‌سازی

دو روش اصلی برای پیاده‌سازی API Composer وجود دارد:

#### رویکرد 1: API Gateway به عنوان Composer

[API Gateway](../architecture/api-gateway.fa.md) خودش منطق ترکیب را مدیریت می‌کند.

```
┌──────────┐       ┌──────────────────────────────┐
│          │       │     API Gateway               │
│  Client  │──────▶│  ┌────────────────────────┐  │
│          │       │  │  Composition Logic      │  │
│          │◀──────│  │  - Fan-out to services  │  │
│          │       │  │  - Merge responses      │  │
└──────────┘       │  │  - Handle errors        │  │
                   │  └────────────────────────┘  │
                   └──────────┬────────────────────┘
                              │
                   ┌──────────┼──────────┐
                   ▼          ▼          ▼
              ┌────────┐ ┌────────┐ ┌────────┐
              │Svc A   │ │Svc B   │ │Svc C   │
              └────────┘ └────────┘ └────────┘
```

**چه زمانی استفاده کنید:**

- ترکیب‌های ساده (2-3 سرویس)
- gateway از قبل مسیریابی را مدیریت می‌کند
- منطق کسب‌وکار پیچیده‌ای در مرحله ادغام وجود ندارد

**معایب:**

- gateway را با منطق ترکیب سنگین می‌کند
- تست ترکیب به صورت جداگانه دشوارتر است
- تغییرات در ترکیب نیاز به استقرار مجدد gateway دارد

#### رویکرد 2: سرویس Composer اختصاصی

یک سرویس مستقل ترکیب را برای یک دامنه خاص یا مجموعه‌ای از کوئری‌ها مدیریت می‌کند.

```
┌──────────┐       ┌───────────┐       ┌──────────────────────┐
│          │       │           │       │  Order Details       │
│  Client  │──────▶│API Gateway│──────▶│  Composer Service    │
│          │       │ (routing) │       │                      │
│          │◀──────│           │◀──────│  - Fetch order       │
└──────────┘       └───────────┘       │  - Fetch customer    │
                                       │  - Fetch products    │
                                       │  - Merge & return    │
                                       └──────────┬───────────┘
                                                  │
                                       ┌──────────┼──────────┐
                                       ▼          ▼          ▼
                                  ┌────────┐ ┌────────┐ ┌────────┐
                                  │Order   │ │Customer│ │Product │
                                  │Service │ │Service │ │Service │
                                  └────────┘ └────────┘ └────────┘
```

**چه زمانی استفاده کنید:**

- ترکیب‌های پیچیده با منطق کسب‌وکار
- منطق ترکیب به طور مکرر تغییر می‌کند
- نیاز به تست ترکیب به صورت مستقل
- انواع مختلف کوئری برای همان دامنه

**معایب:**

- سرویس اضافی برای استقرار و نگهداری
- hop شبکه اضافی (gateway -> composer -> services)

### مقایسه رویکردها

| جنبه | Gateway به عنوان Composer | سرویس Composer اختصاصی |
|------|--------------------------|------------------------|
| **سادگی** | ساده‌تر برای موارد پایه | نیاز به سرویس جداگانه |
| **انعطاف‌پذیری** | محدود به فریم‌ورک gateway | انعطاف‌پذیری برنامه‌نویسی کامل |
| **تست** | تست جداگانه دشوارتر | قابل تست به صورت مستقل |
| **استقرار** | وابسته به انتشارهای gateway | استقرار مستقل |
| **مقیاس‌پذیری** | با gateway مقیاس می‌شود | به صورت مستقل مقیاس می‌شود |
| **بهترین برای** | 2-3 سرویس، ادغام ساده | منطق پیچیده، سرویس‌های زیاد |

### مدیریت خرابی‌ها

وقتی یکی از سرویس‌های downstream خراب شود، چندین گزینه دارید:

```
سناریو: سرویس ارسال از کار افتاده

┌────────────────────────────────────────────┐
│            API Composer                     │
│                                            │
│  Order Service    ── 200 OK  ── ✓         │
│  Customer Service ── 200 OK  ── ✓         │
│  Product Service  ── 200 OK  ── ✓         │
│  Shipping Service ── TIMEOUT ── ✗         │
│                                            │
│  گزینه‌های استراتژی:                       │
│  ┌──────────────────────────────────────┐ │
│  │ 1. نتایج جزئی (PARTIAL RESULTS)     │ │
│  │    برگرداندن داده‌های موجود با null  │ │
│  │    برای ارسال. کلاینت مدیریت کند.   │ │
│  ├──────────────────────────────────────┤ │
│  │ 2. داده کش‌شده / FALLBACK            │ │
│  │    برگرداندن آخرین داده ارسال شناخته │ │
│  │    شده از کش با فلگ stale.           │ │
│  ├──────────────────────────────────────┤ │
│  │ 3. شکست کل درخواست                  │ │
│  │    برگرداندن 503 به کلاینت.         │ │
│  │    زمانی که همه داده‌ها ضروری هستند. │ │
│  ├──────────────────────────────────────┤ │
│  │ 4. مقادیر پیش‌فرض                    │ │
│  │    برگرداندن placeholder: "اطلاعات  │ │
│  │    پیگیری موقتاً در دسترس نیست."    │ │
│  └──────────────────────────────────────┘ │
└────────────────────────────────────────────┘
```

**بهترین روش:** برای هر فیلد تصمیم بگیرید که آیا داده ضروری است یا اختیاری. نتایج جزئی را برای داده‌های اختیاری برگردانید و فقط زمانی شکست دهید که داده‌های ضروری گم شده باشند.

### ملاحظات عملکرد

```
ترتیبی (SEQUENTIAL) - بد برای فراخوانی‌های مستقل
──────────────────────────────────────────────────

  Order Svc    ├──── 45ms ────┤
  Customer Svc                 ├──── 30ms ────┤
  Product Svc                                  ├──── 55ms ────┤
  Shipping Svc                                                 ├──── 40ms ────┤

  مجموع: 170ms


موازی (PARALLEL) - ترجیحی برای فراخوانی‌های مستقل
──────────────────────────────────────────────────

  Order Svc    ├──── 45ms ────┤
  Customer Svc ├──── 30ms ───┤
  Product Svc  ├──── 55ms ─────┤
  Shipping Svc ├──── 40ms ────┤

  مجموع: 55ms  (محدود به کندترین)


ترکیبی (HYBRID) - وقتی فراخوانی‌ها وابستگی دارند
──────────────────────────────────────────────────

  مرحله 1: Order Svc  ├──── 45ms ────┤  (نیاز به order برای customer_id)
  مرحله 2 (موازی):
    Customer Svc  ├──── 30ms ───┤
    Product Svc   ├──── 55ms ─────┤
    Shipping Svc  ├──── 40ms ────┤

  مجموع: 100ms
```

**تکنیک‌های بهینه‌سازی:**

| تکنیک | توضیح | تاثیر |
|--------|-------|-------|
| **فراخوانی‌های موازی** | فراخوانی همزمان سرویس‌های مستقل | کاهش عمده تاخیر |
| **کش کردن** | کش داده‌های پرتکرار (اطلاعات محصول، پروفایل مشتری) | حذف فراخوانی‌های شبکه |
| **Timeoutها** | تنظیم timeout تهاجمی برای هر سرویس | جلوگیری از مسدود شدن توسط سرویس‌های کند |
| **Connection pooling** | استفاده مجدد از اتصالات HTTP به سرویس‌های بک‌اند | کاهش سربار اتصال |
| **نزدیکی داده** | قرار دادن composer نزدیک سرویس‌ها | تاخیر شبکه کمتر |
| **APIهای دسته‌ای** | دریافت چندین آیتم در یک فراخوانی (مثلاً محصولات بر اساس IDها) | کاهش دور رفت‌وبرگشت HTTP |

---

## 5. مثال

### صفحه جزئیات سفارش فروشگاه آنلاین

یک مشتری صفحه جزئیات سفارش خود را در یک سایت فروشگاه آنلاین مشاهده می‌کند. صفحه باید نشان دهد:

```
┌───────────────────────────────────────────────────┐
│  Order #789                    Status: Shipped     │
├───────────────────────────────────────────────────┤
│                                                   │
│  Customer: Alice Johnson                          │
│  Email:    alice@example.com                      │
│                                                   │
│  Items:                                           │
│  ┌─────────────────────────────────────────────┐ │
│  │  1x Widget Pro       $49.99                 │ │
│  │  2x Gadget Mini      $29.99 ea              │ │
│  └─────────────────────────────────────────────┘ │
│                                                   │
│  Subtotal:     $109.97                            │
│  Shipping:      $5.99                             │
│  Total:       $115.96                             │
│                                                   │
│  Shipping:                                        │
│  Carrier:  FedEx                                  │
│  Tracking: TRK-2024-ABC123                        │
│  ETA:      Feb 10, 2026                           │
│                                                   │
└───────────────────────────────────────────────────┘
```

### فراخوانی‌های سرویس مورد نیاز

```
┌───────────────────────────────────────────────────────────────┐
│                  Order Details Composer                        │
│                                                               │
│  ورودی: orderId = 789                                        │
│                                                               │
│  مرحله 1: دریافت سفارش (نیاز به customer_id و product_ids)  │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ GET /orders/789                                         │ │
│  │ Response:                                               │ │
│  │ { orderId: 789, customerId: 456,                        │ │
│  │   items: [{productId:101, qty:1}, {productId:102, qty:2}],│ │
│  │   subtotal: 109.97, shipping: 5.99, total: 115.96,     │ │
│  │   status: "shipped" }                                   │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                               │
│  مرحله 2: دریافت داده‌های باقیمانده به صورت موازی            │
│  ┌──────────────────┐ ┌──────────────────┐ ┌──────────────┐ │
│  │Customer Service   │ │Product Service   │ │Shipping Svc  │ │
│  │GET /customers/456 │ │GET /products?    │ │GET /shipments│ │
│  │                   │ │  ids=101,102     │ │  ?orderId=789│ │
│  │{ name: "Alice     │ │[{ id:101,        │ │{ carrier:    │ │
│  │  Johnson",        │ │  name:"Widget    │ │  "FedEx",    │ │
│  │  email: "alice@   │ │  Pro",           │ │  tracking:   │ │
│  │  example.com" }   │ │  price: 49.99 }, │ │  "TRK-...",  │ │
│  │                   │ │ { id:102,        │ │  eta: "2026- │ │
│  │                   │ │  name:"Gadget    │ │  02-10" }    │ │
│  │                   │ │  Mini",          │ │              │ │
│  │                   │ │  price: 29.99 }] │ │              │ │
│  └──────────────────┘ └──────────────────┘ └──────────────┘ │
│                                                               │
│  مرحله 3: ادغام در پاسخ یکپارچه                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ {                                                       │ │
│  │   orderId: 789,                                         │ │
│  │   status: "shipped",                                    │ │
│  │   customer: { name: "Alice Johnson",                    │ │
│  │               email: "alice@example.com" },             │ │
│  │   items: [                                              │ │
│  │     { name: "Widget Pro",  qty: 1, price: 49.99 },     │ │
│  │     { name: "Gadget Mini", qty: 2, price: 29.99 }      │ │
│  │   ],                                                    │ │
│  │   subtotal: 109.97, shipping: 5.99, total: 115.96,     │ │
│  │   delivery: { carrier: "FedEx",                         │ │
│  │               tracking: "TRK-2024-ABC123",              │ │
│  │               eta: "2026-02-10" }                       │ │
│  │ }                                                       │ │
│  └─────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────┘
```

### مقایسه: ترکیب API در مقابل کوئری مستقیم پایگاه داده

```
کوئری مستقیم DB (یکپارچه)
──────────────────────────────────────────────
  SELECT o.id, o.status, o.total,
         c.name, c.email,
         p.name, oi.qty, p.price,
         s.carrier, s.tracking, s.eta
  FROM orders o
  JOIN customers c  ON o.customer_id = c.id
  JOIN order_items oi ON oi.order_id = o.id
  JOIN products p   ON oi.product_id = p.id
  JOIN shipments s  ON s.order_id = o.id
  WHERE o.id = 789;

  تاخیر: ~5ms (یک فراخوانی DB)
  سازگاری: قوی (تراکنش واحد)


ترکیب API (میکروسرویس‌ها)
──────────────────────────────────────────────
  1. GET /orders/789            → 45ms
  2. GET /customers/456         → 30ms  ─┐
     GET /products?ids=101,102  → 55ms  ─┤ موازی
     GET /shipments?orderId=789 → 40ms  ─┘

  تاخیر: ~100ms (ترتیبی + موازی)
  سازگاری: نهایی (داده از نقاط زمانی مختلف)
```

مبادله واضح است: ترکیب API کندتر است و سازگاری ضعیف‌تری ارائه می‌دهد، اما استقلال سرویس را حفظ می‌کند و به هر سرویس اجازه می‌دهد به طور مستقل مقیاس شود، مستقر شود و تکامل یابد.

---

## 6. مزایا و معایب

### مزایا

| مزیت | توضیح |
|------|-------|
| **پیاده‌سازی ساده** | نیاز به زیرساخت خاصی ندارد؛ فقط فراخوانی‌های HTTP و ادغام در حافظه |
| **کار با هر سرویسی** | مستقل از زبان؛ هر سرویسی با API می‌تواند شرکت کند |
| **بدون پایگاه داده مشترک** | کپسوله‌سازی [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) را حفظ می‌کند |
| **انعطاف‌پذیر** | اضافه یا حذف آسان سرویس‌ها از ترکیب |
| **پذیرش تدریجی** | می‌تواند کوئری به کوئری اعمال شود بدون تغییر سرویس‌های موجود |
| **مدل برنامه‌نویسی آشنا** | توسعه‌دهندگان فراخوانی‌های HTTP و تبدیل داده را درک می‌کنند |
| **بدون زیرساخت اضافی** | بر خلاف [CQRS](./cqrs.fa.md)، نیاز به event store یا پایگاه‌های داده read-model ندارد |

### معایب

| معایب | توضیح | کاهش |
|-------|-------|------|
| **افزایش تاخیر** | چندین فراخوانی شبکه جمع می‌شوند، حتی به صورت موازی | فراخوانی موازی، کش، timeout |
| **محدودیت join در حافظه** | مجموعه‌های داده بزرگ نمی‌توانند به طور کارآمد در حافظه join شوند | صفحه‌بندی، محدود کردن اندازه نتایج |
| **سازگاری داده** | سرویس‌های مختلف ممکن است داده‌هایی از نقاط زمانی مختلف برگردانند | پذیرش سازگاری نهایی یا استفاده از versioning |
| **مدیریت خرابی جزئی** | خرابی یک سرویس می‌تواند کل کوئری را تضعیف یا بشکند | Fallbackها، circuit breakerها، نتایج جزئی |
| **کاهش دسترس‌پذیری** | دسترس‌پذیری کلی حاصل‌ضرب دسترس‌پذیری سرویس‌های فردی است | کش، fallbackها، تضعیف graceful |
| **بدون تجمیع پیچیده** | انجام GROUP BY، SUM در مرزهای سرویس در حافظه دشوار است | برای آنالیتیکس پیچیده [CQRS](./cqrs.fa.md) را در نظر بگیرید |
| **افزایش ترافیک شبکه** | چندین فراخوانی داخلی به ازای هر درخواست کلاینت | APIهای دسته‌ای، کش |
| **پیچیدگی منطق ترکیب** | ادغام داده‌های ناهمگن می‌تواند با گذشت زمان پیچیده شود | ترکیب‌ها را متمرکز نگه دارید؛ به چندین composer تقسیم کنید |

### ریاضیات دسترس‌پذیری

اگر هر سرویس 99.9% دسترس‌پذیری داشته باشد و ترکیب در 4 سرویس انجام شود:

```
دسترس‌پذیری ترکیبی = 99.9% x 99.9% x 99.9% x 99.9%
                     = 99.6%

این یعنی ~3.5 ساعت downtime اضافی در سال
در مقایسه با یک سرویس واحد.

کاهش: از کش و fallbackها برای جدا کردن
دسترس‌پذیری از سرویس‌های downstream استفاده کنید.
```

---

## 7. الگوهای مرتبط

### ترکیب API در مقابل CQRS

وقتی ترکیب API بیش از حد پیچیده یا کند می‌شود، [CQRS (جداسازی مسئولیت Command و Query)](./cqrs.fa.md) جایگزین معمول است.

```
ترکیب API                                CQRS
─────────────────                        ─────────────────

زمان کوئری:                               زمان نوشتن:
  Composer از N سرویس فراخوانی             رویدادها یک read model
  و در حافظه ادغام می‌کند                 denormalized از پیش ساخته شده
                                          را به‌روز می‌کنند

  ┌──────────┐                           ┌──────────┐
  │  Client  │                           │  Client  │
  └─────┬────┘                           └─────┬────┘
        │ query                                │ query
        ▼                                      ▼
  ┌──────────────┐                       ┌──────────────┐
  │   Composer   │                       │  Read Model  │
  │  (ادغام     │                       │  (پایگاه داده│
  │   زمان اجرا)│                       │   از پیش join│
  └──┬──┬──┬──┬──┘                       │   شده)      │
     │  │  │  │                          └──────────────┘
     ▼  ▼  ▼  ▼                          یک کوئری سریع
  Svc A B C D
  چندین فراخوانی شبکه
```

| جنبه | ترکیب API | CQRS |
|------|-----------|------|
| **تاخیر کوئری** | بالاتر (چندین فراخوانی) | کمتر (یک خوانش از view از پیش ساخته شده) |
| **تلاش پیاده‌سازی** | کم | زیاد (event handlerها، read model، sync) |
| **زیرساخت** | بدون اضافه | event store، پایگاه داده خوانش |
| **تازگی داده** | بلادرنگ از سرویس‌ها | سازگاری نهایی (تاخیر sync) |
| **تجمیع‌های پیچیده** | دشوار (در حافظه) | آسان (از پیش محاسبه شده در read model) |
| **بهترین برای** | joinهای ساده، حجم کوئری کم تا متوسط | کوئری‌های پیچیده، حجم کوئری بالا، آنالیتیکس |

**قاعده سرانگشتی:** با ترکیب API شروع کنید. اگر یک کوئری خیلی کند شد، سرویس‌های زیادی را درگیر کرد، یا به تجمیع‌های پیچیده نیاز داشت، آن کوئری خاص را به [CQRS](./cqrs.fa.md) مهاجرت دهید.

### خلاصه الگوهای مرتبط

| الگو | رابطه با ترکیب API |
|------|-------------------|
| [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) | نیاز به ترکیب API را ایجاد می‌کند |
| [CQRS](./cqrs.fa.md) | جایگزین برای کوئری‌های پیچیده یا پرحجم |
| [API Gateway](../architecture/api-gateway.fa.md) | مکان رایج برای پیاده‌سازی composer |
| [Circuit Breaker](../resilience/circuit-breaker.fa.md) | از composer در برابر سرویس‌های خراب downstream محافظت می‌کند |
| [الگوی Saga](../distributed-transactions/saga.fa.md) | نوشتن‌های توزیع‌شده را مدیریت می‌کند؛ ترکیب API خوانش‌های توزیع‌شده را مدیریت می‌کند |
| [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) | رویدادها می‌توانند کش‌های محلی را تازه نگه دارند تا ترکیب سریع‌تر شود |

---

## 8. استفاده در دنیای واقعی

### Netflix: ترکیب API Gateway

Netflix پیشگام ترکیب API در مقیاس بالا از طریق API Gateway خود (اصلاً Zuul، اکنون Spring Cloud Gateway) بود. gateway آنها پاسخ‌ها را از ده‌ها میکروسرویس ترکیب می‌کند تا داده‌های مورد نیاز یک صفحه واحد در اپلیکیشن‌هایشان را بسازد.

```
┌────────────────────────────────────────────────────┐
│             Netflix API Gateway                     │
│                                                    │
│  صفحه: "جزئیات فیلم"                              │
│  ترکیب داده از:                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │ Movie Metadata Service   → عنوان، سال، خلاصه│ │
│  │ Rating Service           → امتیاز کاربر، میانگین│ │
│  │ Recommendation Service   → "مشابه این"       │ │
│  │ Availability Service     → مناطق پخش        │ │
│  │ Image Service            → پوستر، پس‌زمینه  │ │
│  │ Audio/Subtitle Service   → گزینه‌های زبان    │ │
│  └──────────────────────────────────────────────┘ │
│                                                    │
│  تصمیمات کلیدی:                                   │
│  • فراخوانی‌های موازی با timeout برای هر سرویس   │
│  • Fallback به داده کش‌شده وقتی سرویس کند است   │
│  • ترکیب‌های مختلف برای TV، موبایل، وب           │
│    (مشابه الگوی BFF)                              │
└────────────────────────────────────────────────────┘
```

### GraphQL به عنوان لایه ترکیب

GraphQL به طور فزاینده به عنوان یک لایه ترکیب API اعلانی استفاده می‌شود. به جای اینکه سرور تصمیم بگیرد چه چیزی ترکیب شود، کلاینت دقیقاً مشخص می‌کند که به کدام فیلدها نیاز دارد و resolver GraphQL از سرویس‌های مرتبط دریافت می‌کند.

```
┌──────────┐       ┌───────────────────────────────────┐
│          │       │        GraphQL Server              │
│  Client  │──────▶│                                   │
│          │       │  query {                           │
│          │       │    order(id: 789) {                │
│          │       │      status          → Order Svc   │
│          │       │      customer {                    │
│          │       │        name          → Customer Svc│
│          │       │      }                             │
│          │       │      items {                       │
│          │       │        product {                   │
│          │       │          name        → Product Svc │
│          │       │          price       → Product Svc │
│          │       │        }                           │
│          │       │      }                             │
│          │       │    }                               │
│          │       │  }                                 │
│          │       │                                   │
│          │◀──────│  Resolverها از هر سرویس دریافت    │
└──────────┘       │  می‌کنند                           │
                   └───────────────────────────────────┘
```

**مزایای GraphQL برای ترکیب:**

- کلاینت دقیقاً کنترل می‌کند که به چه داده‌ای نیاز دارد (بدون over-fetching)
- یک دور رفت‌وبرگشت از کلاینت به سرور
- تایپ قوی از طریق schema
- ابزارهای داخلی برای batching و caching (DataLoader)

### Amazon: ترکیب Service Mesh

Amazon صفحات جزئیات محصول را از سرویس‌های داخلی متعدد ترکیب می‌کند:

```
صفحه جزئیات محصول ترکیب می‌کند از:
├── Catalog Service        → اطلاعات محصول، تصاویر
├── Pricing Service        → قیمت فعلی، تخفیف‌ها
├── Inventory Service      → موجودی انبار
├── Reviews Service        → امتیازها، نظرات کاربران
├── Recommendations Service→ "مشتریان همچنین خریدند"
├── Shipping Service       → تخمین تحویل
├── Advertising Service    → محصولات اسپانسری
└── Seller Service         → اطلاعات فروشنده، امتیازها
```

در مقیاس Amazon، هر سرویس میلیون‌ها درخواست در ثانیه را مدیریت می‌کند. ترکیب API الگوی پیش‌فرض برای صفحات read-heavy است، با کش تهاجمی و circuit breakerها در هر لایه.

### وقتی شرکت‌ها از ترکیب API فراتر می‌روند

با افزایش پیچیدگی کوئری، بسیاری از سازمان‌ها رویکرد ترکیبی اتخاذ می‌کنند:

```
┌─────────────────────────────────────────────────┐
│  نوع کوئری             │  الگوی استفاده شده     │
├──────────────────────┼──────────────────────────┤
│  بارگذاری ساده صفحه  │  ترکیب API              │
│  نماهای داشبورد      │  ترکیب API + کش         │
│  جستجو               │  CQRS (Elasticsearch)    │
│  آنالیتیکس/گزارش‌ها  │  CQRS (Data Warehouse)   │
│  فیدهای بلادرنگ      │  رویداد-محور + CQRS      │
└─────────────────────────────────────────────────┘
```

---

## 9. خلاصه

ترکیب API **ساده‌ترین و طبیعی‌ترین الگو** برای کوئری زدن به داده‌ها در میکروسرویس‌ها است. استقلال سرویس را حفظ می‌کند، نیاز به زیرساخت اضافی ندارد و با هر پشته فناوری کار می‌کند.

### نکات کلیدی

1. **ترکیب API به کوئری‌های بین‌سرویسی پاسخ می‌دهد** با فراخوانی APIهای چندین سرویس و ادغام نتایج در حافظه.

2. **نقطه شروع پیش‌فرض است** وقتی [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) را اتخاذ می‌کنید. از آن استفاده کنید تا شواهدی داشته باشید که چیز پیچیده‌تری لازم است.

3. **فراخوانی‌های موازی ضروری هستند** برای تاخیر قابل قبول. ترکیب ترتیبی در سرویس‌های زیاد بسیار کند خواهد بود.

4. **خرابی‌های جزئی را به خوبی مدیریت کنید.** همه داده‌ها به یک اندازه حیاتی نیستند. نتایج جزئی را با fallback برای داده‌های غیرضروری برگردانید.

5. **دو مکان پیاده‌سازی:** [API Gateway](../architecture/api-gateway.fa.md) برای موارد ساده، یا سرویس composer اختصاصی برای منطق پیچیده.

6. **بدانید چه زمانی به [CQRS](./cqrs.fa.md) ارتقا دهید.** اگر یک کوئری سرویس‌های زیادی را درگیر می‌کند، به تجمیع‌های پیچیده نیاز دارد، یا باید حجم خوانش بسیار بالا را سرویس دهد، CQRS با یک read model از پیش ساخته شده قدم بعدی است.

7. **کش بهترین دوست شماست.** داده‌های پایدار (اطلاعات محصول، پروفایل مشتری) را به شدت کش کنید تا تعداد فراخوانی‌های واقعی شبکه را کاهش دهید.

8. **تاخیر ترکیب را نظارت کنید.** تاخیرهای P50، P95 و P99 را برای هر کوئری ترکیبی و هر فراخوانی سرویس downstream ردیابی کنید.

9. **APIهای سرویس را با در نظر گرفتن ترکیب طراحی کنید.** endpointهای دسته‌ای ارائه دهید (مثلاً `GET /products?ids=1,2,3`) تا تعداد فراخوانی‌ها را کاهش دهید.

10. **ترکیب API یک الگوی خوانش است.** برای نوشتن‌های توزیع‌شده، به [الگوی Saga](../distributed-transactions/saga.fa.md) یا [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) مراجعه کنید.

### چارچوب تصمیم‌گیری

```
┌─────────────────────────────────────────┐
│ آیا به داده از چندین سرویس نیاز دارید؟ │
└─────────────────┬───────────────────────┘
                  │
             خیر  │   بله
                  │
   ┌──────────────▼──────────────┐
   │ مستقیماً سرویس واحد را     │
   │ فراخوانی کنید. بدون ترکیب. │
   └─────────────────────────────┘
                  │
                  │ بله
                  ▼
┌─────────────────────────────────────────┐
│ آیا کوئری ساده است (< 5 سرویس،        │
│ بدون تجمیع پیچیده)؟                    │
└─────────────────┬───────────────────────┘
                  │
             خیر  │   بله
                  │
   ┌──────────────▼──────────────┐
   │ از ترکیب API استفاده کنید.  │
   │ ساده شروع کنید، کش و       │
   │ fallback در صورت نیاز اضافه │
   │ کنید.                       │
   └─────────────────────────────┘
                  │
                  │ خیر (کوئری پیچیده، حجم بالا، آنالیتیکس)
                  ▼
┌─────────────────────────────────────────┐
│ CQRS را با یک read model اختصاصی      │
│ برای این کوئری خاص در نظر بگیرید.     │
└─────────────────────────────────────────┘
```

---

**موضوعات مرتبط:**

- [CQRS](./cqrs.fa.md) - جایگزین برای کوئری‌های پیچیده با read modelهای از پیش ساخته شده
- [پایگاه داده به ازای هر سرویس](./database-per-service.fa.md) - الگویی که نیاز به ترکیب API را ایجاد می‌کند
- [API Gateway](../architecture/api-gateway.fa.md) - مکان رایج برای پیاده‌سازی ترکیب
- [Circuit Breaker](../resilience/circuit-breaker.fa.md) - محافظت از composer در برابر خرابی‌های downstream
- [الگوی Saga](../distributed-transactions/saga.fa.md) - عملیات نوشتن توزیع‌شده
- [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) - رویدادها برای تازه نگه داشتن داده‌های کش‌شده
- [قضیه CAP](../fundamentals/cap-theorem.fa.md) - درک مبادلات سازگاری در کوئری‌های توزیع‌شده

**منابع:**

- **"Microservices Patterns"** از Chris Richardson (فصل 7: ترکیب API)
- microservices.io - الگوی API Composition
- Netflix Tech Blog: بهینه‌سازی Netflix API
- **"Building Microservices"** از Sam Newman (فصل مربوط به داده)
- مستندات GraphQL درباره ترکیب کوئری
