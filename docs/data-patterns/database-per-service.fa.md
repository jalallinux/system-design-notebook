# پایگاه داده به ازای هر سرویس (Database per Service)

## ۱. مقدمه

الگوی **پایگاه داده به ازای هر سرویس** یک اصل بنیادی مدیریت داده در [معماری میکروسرویس‌ها](../architecture/microservices.fa.md) است. این الگو مشخص می‌کند که هر میکروسرویس مالک یک **پایگاه داده خصوصی** (یا حداقل یک اسکیمای خصوصی/مجموعه‌ای از جداول) است که هیچ سرویس دیگری نمی‌تواند مستقیماً به آن دسترسی داشته باشد. تمام دسترسی‌های بین سرویسی به داده‌ها باید از طریق API تعریف‌شده سرویس مالک انجام شود.

این الگو معادل لایه داده‌ای کپسوله‌سازی سرویس است: همان‌طور که سرویس‌ها جزئیات پیاده‌سازی خود را پشت APIها پنهان می‌کنند، داده‌های خود را نیز پشت APIها مخفی می‌کنند. این یکی از مهم‌ترین تصمیماتی است که هنگام مهاجرت از معماری یکپارچه (Monolith) به میکروسرویس‌ها می‌گیرید.

```
+---------------------------------------------+
|              Monolithic Application          |
|                                             |
|  +---------+  +---------+  +---------+      |
|  | Module A|  | Module B|  | Module C|      |
|  +----+----+  +----+----+  +----+----+      |
|       |            |            |            |
|       v            v            v            |
|  +-------------------------------------+    |
|  |         Shared Database              |    |
|  |  (All modules read/write freely)     |    |
|  +-------------------------------------+    |
+---------------------------------------------+

          vs.

+-------------+   +-------------+   +-------------+
| Service A   |   | Service B   |   | Service C   |
|  (Order)    |   | (Product)   |   |  (Search)   |
+------+------+   +------+------+   +------+------+
       |                 |                 |
       v                 v                 v
  +---------+      +-----------+    +-------------+
  |  SQL DB |      |  MongoDB  |    |Elasticsearch|
  | (Private)|     | (Private) |    |  (Private)  |
  +---------+      +-----------+    +-------------+
```

---

## ۲. زمینه و مسئله

هنگام ساخت یک سیستم با استفاده از [معماری میکروسرویس‌ها](../architecture/microservices.fa.md)، یکی از اولین و تاثیرگذارترین تصمیمات **نحوه سازمان‌دهی لایه داده** است.

در یک اپلیکیشن یکپارچه (Monolithic) سنتی، تمام ماژول‌ها یک پایگاه داده رابطه‌ای مشترک را به اشتراک می‌گذارند. این کار کوئری‌های بین ماژولی را ساده می‌کند (فقط یک JOIN بنویسید) و تراکنش‌ها را آسان می‌کند (فقط از یک تراکنش ACID استفاده کنید). اما این اتصال محکم در لایه داده مشکلات جدی ایجاد می‌کند:

- **تغییرات اسکیما** در یک ماژول می‌تواند ماژول‌های دیگر را خراب کند.
- **گلوگاه‌های عملکردی** در کوئری‌های یک ماژول بر تمام ماژول‌ها تاثیر می‌گذارد.
- **استقرار مستقل** در صورت اشتراک چند سرویس در یک اسکیما غیرممکن است.
- **قفل شدن به فناوری** هر ماژول را مجبور می‌کند از همان فناوری پایگاه داده استفاده کند، حتی وقتی یک ذخیره‌ساز دیگر بسیار مناسب‌تر است.
- **مقیاس‌دهی** پایگاه داده به یک عملیات همه یا هیچ تبدیل می‌شود.

سوال اصلی این می‌شود:

> **چگونه معماری پایگاه داده را برای یک سیستم مبتنی بر میکروسرویس‌ها تعریف کنیم تا سرویس‌ها با اتصال سست، قابلیت استقرار مستقل و مقیاس‌پذیری مستقل باقی بمانند؟**

---

## ۳. نیروها (Forces)

چندین نیروی رقابتی بر تصمیم طراحی تاثیر می‌گذارند:

| نیرو | توضیحات |
|------|---------|
| **اتصال سست** | سرویس‌ها باید بتوانند مستقلاً تکامل یابند. تغییر اسکیما در سرویس A هرگز نباید سرویس B را خراب کند. |
| **قابلیت استقرار مستقل** | هر سرویس باید در جدول زمانی خودش قابل استقرار باشد، بدون هماهنگی مهاجرت‌های پایگاه داده با تیم‌های دیگر. |
| **نیازهای مختلف ذخیره‌سازی داده** | سرویس سفارش ممکن است به تراکنش‌های ACID (SQL) نیاز داشته باشد، در حالی که کاتالوگ محصول از یک ذخیره‌ساز سند (MongoDB) و سرویس جستجو از یک ایندکس متن کامل (Elasticsearch) بهره‌مند می‌شود. |
| **کوئری‌های بین سرویسی** | برخی عملیات‌های کسب‌وکاری به طور طبیعی به داده‌هایی از چندین سرویس نیاز دارند (مثلاً "سفارش را با جزئیات محصول و وضعیت ارسال نمایش بده"). |
| **سازگاری داده** | برخی عملیات‌ها چندین سرویس را در بر می‌گیرند و به نوعی تضمین تراکنشی نیاز دارند. |
| **افزونگی و دسترس‌پذیری** | پایگاه‌های داده گاهی باید برای failover تکثیر شوند، اما تکثیر در مرزهای سرویس پیچیدگی اضافه می‌کند. |
| **سادگی عملیاتی** | اجرای چندین پایگاه داده سخت‌تر از اجرای یکی است. پایگاه‌های داده بیشتر یعنی پشتیبان‌گیری بیشتر، نظارت بیشتر و تخصص بیشتر مورد نیاز. |

---

## ۴. راه‌حل

### اصل اساسی

**به هر میکروسرویس ذخیره‌ساز داده خصوصی خودش را بدهید.** هیچ سرویس دیگری نباید مستقیماً به آن ذخیره‌ساز دسترسی داشته باشد -- نه از طریق کوئری‌های SQL مستقیم، نه از طریق لینک‌های پایگاه داده مشترک و نه از طریق تکثیر در سطح پایگاه داده. تنها راه برای سرویس B جهت خواندن یا تغییر داده‌های سرویس A، از طریق API منتشرشده سرویس A (REST، gRPC، پیام‌رسانی ناهمزمان و غیره) است.

### سطوح ایزوله‌سازی

مفهوم "پایگاه داده خصوصی" می‌تواند در سطوح مختلفی از سخت‌گیری پیاده‌سازی شود:

```
Level 1: Private Tables          Level 2: Private Schema
(weakest isolation)              (moderate isolation)

+---------------------------+    +---------------------------+
|    Shared DB Server       |    |    Shared DB Server       |
|                           |    |                           |
| +--------+ +--------+    |    | +----------+ +----------+ |
| |Table A1| |Table B1|    |    | | Schema A | | Schema B | |
| |Table A2| |Table B2|    |    | | (Tables) | | (Tables) | |
| +--------+ +--------+    |    | +----------+ +----------+ |
|  Service A  Service B     |    |  Service A    Service B   |
+---------------------------+    +---------------------------+

Level 3: Private DB Server       Level 4: Polyglot Persistence
(strong isolation)               (strongest isolation)

+------------+ +------------+    +------------+ +------------+
| DB Server  | | DB Server  |    | PostgreSQL | |  MongoDB   |
| (Service A)| | (Service B)|    | (Service A)| | (Service B)|
+------------+ +------------+    +------------+ +------------+
                                 +------------+
                                 |Elasticsearch|
                                 | (Service C) |
                                 +------------+
```

| سطح | ایزوله‌سازی | مزایا | معایب |
|-----|------------|-------|-------|
| **جداول خصوصی** | ضعیف‌ترین | هزینه عملیاتی کم، راه‌اندازی آسان | امکان دسترسی تصادفی بین سرویسی، رقابت بر منابع مشترک |
| **اسکیمای خصوصی** | متوسط | جداسازی فضای نام، همچنان یک DB برای مدیریت | منابع سرور مشترک، نیاز به ارتقاء هماهنگ |
| **سرور DB خصوصی** | قوی | ایزوله‌سازی کامل منابع، مقیاس‌دهی مستقل | هزینه عملیاتی بالاتر، زیرساخت بیشتر |
| **Polyglot Persistence** | قوی‌ترین | بهترین فناوری متناسب با هر سرویس | بالاترین پیچیدگی عملیاتی، نیاز به تخصص متنوع |

### نحوه دسترسی سرویس‌ها به داده‌های یکدیگر

از آنجا که دسترسی مستقیم به پایگاه داده ممنوع است، سرویس‌ها باید از یکی از این روش‌ها استفاده کنند:

```
+-------------+         API Call           +-------------+
|  Service A  | -------------------------> |  Service B  |
| (needs B's  |    GET /api/products/42    | (owns the   |
|   data)     | <------------------------- |   data)     |
|             |    { "name": "Widget" }    |             |
+------+------+                            +------+------+
       |                                          |
       v                                          v
  +---------+                                +---------+
  | DB (A)  |                                | DB (B)  |
  +---------+                                +---------+
```

**رویکردهای همزمان:**
- **REST/HTTP APIs** -- سرویس A اندپوینت REST سرویس B را فراخوانی می‌کند.
- **gRPC** -- کارآمدتر برای فراخوانی‌های بین سرویسی داخلی.

**رویکردهای ناهمزمان:**
- **رویداد-محور** -- سرویس B هنگام تغییر داده‌هایش رویدادها منتشر می‌کند؛ سرویس A مشترک می‌شود و یک کپی محلی بهینه‌شده برای خواندن نگهداری می‌کند.
- **پیام‌رسانی** -- سرویس A یک پیام درخواست ارسال می‌کند؛ سرویس B آن را پردازش کرده و پاسخ ارسال می‌کند.

### مدیریت سازگاری داده

بدون پایگاه داده مشترک، توانایی استفاده از یک تراکنش ACID واحد در سرویس‌ها را از دست می‌دهید. دو استراتژی اصلی این مسئله را حل می‌کنند:

1. **[الگوی Saga](../distributed-transactions/saga.fa.md)** -- دنباله‌ای از تراکنش‌های محلی که هر سرویس تراکنش خودش را انجام داده و رویدادی منتشر می‌کند. اگر هر مرحله‌ای شکست بخورد، تراکنش‌های جبرانی مراحل قبلی را لغو می‌کنند. این کار **سازگاری نهایی** را محقق می‌سازد.

2. **سازگاری نهایی با رویدادهای دامنه** -- سرویس‌ها هنگام تغییر داده‌هایشان رویدادها منتشر می‌کنند. سرویس‌های دیگر این رویدادها را مصرف کرده و وضعیت خودشان را به‌روزرسانی می‌کنند. سیستم موقتاً ناسازگار است اما به سازگاری همگرا می‌شود.

```
     Saga: Order Creation Flow

  Order Service     Payment Service    Inventory Service
       |                  |                   |
  1. Create Order         |                   |
  (status=PENDING)        |                   |
       |                  |                   |
       +--- OrderCreated -->                  |
       |                  |                   |
       |           2. Process Payment         |
       |           (charge card)              |
       |                  |                   |
       |                  +-- PaymentDone ---->
       |                  |                   |
       |                  |            3. Reserve Stock
       |                  |            (decrement qty)
       |                  |                   |
       <-------------- StockReserved ---------+
       |                  |                   |
  4. Confirm Order        |                   |
  (status=CONFIRMED)      |                   |
```

### کوئری‌زدن در بین سرویس‌ها

هنگامی که یک کلاینت به داده‌هایی از چندین سرویس نیاز دارد، دو الگو کمک می‌کنند:

1. **ترکیب API** -- یک لایه [ترکیب API](./api-composition.fa.md) (اغلب یک [API Gateway](../architecture/api-gateway.fa.md)) چندین API سرویس را فراخوانی کرده و نتایج را در حافظه ادغام می‌کند.

2. **[CQRS](./cqrs.fa.md)** -- نگهداری یک ذخیره‌ساز داده اختصاصی بهینه‌شده برای خواندن که داده‌ها را از چندین سرویس از طریق رویدادها تجمیع می‌کند. این به ویژه برای کوئری‌های پیچیده، داشبوردها و گزارش‌دهی مفید است.

```
  API Composition Pattern:

  +--------+       +-------------+
  | Client | ----> | API Gateway |
  +--------+       |  /Composer  |
                   +------+------+
                          |
              +-----------+-----------+
              |           |           |
              v           v           v
         +---------+ +---------+ +---------+
         | Order   | | Product | | User    |
         | Service | | Service | | Service |
         +---------+ +---------+ +---------+


  CQRS Pattern:

  +----------+    events    +----------------+
  | Order    | ----------> | Read Store     |
  | Service  |             | (Denormalized  |
  +----------+             |  view joining  |
  +----------+    events   |  orders,       |
  | Product  | ----------> |  products,     |
  | Service  |             |  users)        |
  +----------+             +-------+--------+
  +----------+    events           |
  | User     | ---------->        |
  | Service  |                    |
  +----------+             +------v------+
                           |   Client    |
                           +-------------+
```

---

## ۵. مثال

یک **پلتفرم تجارت الکترونیک** ساخته‌شده با میکروسرویس‌ها را در نظر بگیرید. هر سرویس بهترین پایگاه داده را برای بار کاری خاص خود انتخاب می‌کند:

```
+------------------------------------------------------+
|                  E-Commerce Platform                  |
+------------------------------------------------------+
|                                                      |
|  +----------------+  +----------------+  +----------+|
|  | Order Service  |  | Product Service|  |  Search  ||
|  |                |  |                |  | Service  ||
|  | - Create order |  | - Manage       |  |          ||
|  | - Track status |  |   catalog      |  | - Full   ||
|  | - Order history|  | - Pricing      |  |   text   ||
|  |                |  | - Categories   |  |   search ||
|  +-------+--------+  +-------+--------+  +----+-----+|
|          |                   |                 |      |
|          v                   v                 v      |
|   +------------+     +------------+    +------------+ |
|   | PostgreSQL |     |  MongoDB   |    |Elasticsearch||
|   |            |     |            |    |            | |
|   | - orders   |     | - products |    | - product  | |
|   | - payments |     | - reviews  |    |   index    | |
|   | - line     |     | - variants |    | - search   | |
|   |   items    |     |            |    |   suggest  | |
|   +------------+     +------------+    +------------+ |
+------------------------------------------------------+
```

**چرا هر پایگاه داده انتخاب شد:**

| سرویس | پایگاه داده | دلیل |
|-------|------------|------|
| **سرویس سفارش** | PostgreSQL | نیاز به تراکنش‌های ACID برای داده‌های مالی، کوئری‌های رابطه‌ای پیچیده برای تاریخچه سفارش، تضمین‌های سازگاری قوی |
| **سرویس محصول** | MongoDB | اسکیمای انعطاف‌پذیر برای ویژگی‌های متنوع محصول (پوشاک vs الکترونیک vs مواد غذایی)، متغیرهای تو در تو، مقیاس‌دهی افقی آسان |
| **سرویس جستجو** | Elasticsearch | جستجوی متن کامل، تطبیق فازی، ناوبری فیلتری، تکمیل خودکار، امتیازدهی مرتبط بودن |

**مثال جریان داده -- "مشتری سفارش می‌دهد":**

1. **سرویس سفارش** سفارش را در PostgreSQL ایجاد می‌کند (تراکنش ACID).
2. **سرویس سفارش** رویداد `OrderCreated` را منتشر می‌کند.
3. **سرویس محصول** رویداد را دریافت کرده و موجودی را در MongoDB کاهش می‌دهد.
4. **سرویس جستجو** رویداد را دریافت کرده و دسترس‌پذیری محصول را در Elasticsearch به‌روزرسانی می‌کند.
5. اگر کاهش موجودی شکست بخورد، یک تراکنش جبرانی (از طریق [الگوی Saga](../distributed-transactions/saga.fa.md)) سفارش را لغو می‌کند.

---

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیحات |
|------|---------|
| **اتصال سست** | سرویس‌ها از طریق یک ذخیره‌ساز داده مشترک به هم متصل نیستند. تغییرات اسکیما محلی به یک سرویس هستند. |
| **مقیاس‌دهی مستقل** | هر پایگاه داده می‌تواند مستقلاً بر اساس بار سرویس خود مقیاس‌دهی شود (مثلاً Read Replica برای سرویس محصول، Sharding برای سرویس سفارش). |
| **Polyglot Persistence** | هر سرویس از بهترین فناوری پایگاه داده متناسب با بار کاری خاص خود استفاده می‌کند. |
| **استقرار مستقل** | مهاجرت‌های پایگاه داده محدود به یک سرویس هستند. نیازی به هماهنگی بین تیمی نیست. |
| **ایزوله‌سازی خطا** | اگر پایگاه داده سرویس سفارش از کار بیفتد، سرویس محصول و سرویس جستجو به کار خود ادامه می‌دهند. |
| **استقلال تیم** | هر تیم مالکیت کامل مدل داده، طراحی اسکیما و عملیات پایگاه داده خود را دارد. |

### معایب

| عیب | توضیحات | راه‌حل |
|-----|---------|--------|
| **تراکنش‌های توزیع‌شده** | امکان استفاده از یک تراکنش ACID واحد در بین سرویس‌ها وجود ندارد. | از [الگوی Saga](../distributed-transactions/saga.fa.md) برای سازگاری نهایی استفاده کنید. |
| **پیچیدگی کوئری بین سرویسی** | JOINها در مرزهای سرویس در سطح پایگاه داده غیرممکن هستند. | از [ترکیب API](./api-composition.fa.md) یا ذخیره‌سازهای خواندنی [CQRS](./cqrs.fa.md) استفاده کنید. |
| **تکرار داده** | سرویس‌ها ممکن است به کپی‌های محلی از داده‌های سرویس‌های دیگر برای عملکرد نیاز داشته باشند. | تکرار کنترل‌شده را بپذیرید؛ از رویدادها برای همگام‌سازی کپی‌ها استفاده کنید. |
| **سربار عملیاتی** | پایگاه‌های داده بیشتر برای تامین، نظارت، پشتیبان‌گیری و ارتقاء. | از سرویس‌های مدیریت‌شده پایگاه داده (RDS، Atlas و غیره) و زیرساخت به عنوان کد استفاده کنید. |
| **سازگاری نهایی** | سیستم ممکن است موقتاً بین سرویس‌ها ناسازگار باشد. | رابط‌های کاربری را برای سازگاری نهایی طراحی کنید؛ از عملیات‌های idempotent استفاده کنید. |
| **پیچیدگی اشکال‌زدایی** | ردیابی مشکلات داده در چندین پایگاه داده سخت‌تر از کوئری‌زدن یک DB مشترک است. | در ردیابی توزیع‌شده (Jaeger، Zipkin) و لاگ‌گیری متمرکز سرمایه‌گذاری کنید. |

---

## ۷. الگوهای مرتبط

| الگو | ارتباط |
|------|--------|
| [الگوی Saga](../distributed-transactions/saga.fa.md) | مدیریت تراکنش‌های توزیع‌شده در بین چندین سرویس، هر کدام با پایگاه داده خودشان. همراه ضروری الگوی پایگاه داده به ازای هر سرویس. |
| [CQRS](./cqrs.fa.md) | چالش کوئری بین سرویسی را با نگهداری مدل‌های خواندنی denormalized که از چندین سرویس تجمیع شده‌اند، حل می‌کند. |
| [ترکیب API](./api-composition.fa.md) | جایگزین ساده‌تر CQRS برای تجمیع داده‌ها از چندین سرویس در زمان کوئری. |
| [پایگاه داده مشترک](./shared-database.fa.md) | ضد الگو / جایگزین: چندین سرویس یک پایگاه داده مشترک دارند. ساده‌تر اما اتصال محکم ایجاد می‌کند. |
| [معماری میکروسرویس‌ها](../architecture/microservices.fa.md) | سبک معماری گسترده‌تری که الگوی پایگاه داده به ازای هر سرویس از آن پشتیبانی می‌کند. |
| [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) | مکانیزم (رویدادها) را برای همگام‌سازی داده‌ها در مرزهای سرویس فراهم می‌کند. |
| [API Gateway](../architecture/api-gateway.fa.md) | اغلب به عنوان لایه ترکیب API عمل می‌کند که داده‌ها را از چندین سرویس تجمیع می‌کند. |

---

## ۸. استفاده در دنیای واقعی

### آمازون (Amazon)

آمازون به طور مشهوری از یک پایگاه داده یکپارچه Oracle به معماری میکروسرویس‌ها مهاجرت کرد، جایی که هر سرویس مالک داده‌های خودش است. پلتفرم تجارت الکترونیک آن‌ها از صدها سرویس استفاده می‌کند، هر کدام با پایگاه داده خودش. این یک عامل کلیدی ساختار تیم دو پیتزایی آن‌ها بود، جایی که تیم‌های کوچک خودمختار سرویس‌های خود را به صورت سرتاسری مالکیت و اداره می‌کنند.

### نتفلیکس (Netflix)

نتفلیکس صدها میکروسرویس را اجرا می‌کند، هر کدام با ذخیره‌ساز داده خودش. آن‌ها ترکیبی از Cassandra (برای توان نوشتن بالا)، MySQL (برای داده‌های تراکنشی)، Elasticsearch (برای جستجو) و EVCache (برای کش) استفاده می‌کنند. [API Gateway](../architecture/api-gateway.fa.md) آن‌ها (Zuul) اغلب به عنوان لایه ترکیب API عمل می‌کند.

### اوبر (Uber)

میکروسرویس‌های اوبر از انواع مختلف پایگاه‌های داده استفاده می‌کنند که برای بارهای کاری خاص انتخاب شده‌اند:
- **MySQL/PostgreSQL** برای داده‌های تراکنشی سفر
- **Cassandra** برای داده‌های سری زمانی با حجم بالا (پینگ‌های مکانی)
- **Elasticsearch** برای جستجو و تحلیل
- **Redis** برای کش و عملیات مکانی بلادرنگ

هر تیم سرویس به طور مستقل انتخاب فناوری پایگاه داده، اسکیما و مقیاس‌دهی خود را مدیریت می‌کند.

### خلاصه پذیرش صنعتی

| شرکت | رویکرد | فناوری‌های کلیدی |
|------|--------|-----------------|
| Amazon | پایگاه داده کامل به ازای هر سرویس، صدها سرویس | DynamoDB، Aurora، RDS، ElastiCache |
| Netflix | Polyglot Persistence در صدها سرویس | Cassandra، MySQL، Elasticsearch، EVCache |
| Uber | انتخاب فناوری پایگاه داده خاص هر سرویس | MySQL، PostgreSQL، Cassandra، Elasticsearch، Redis |
| Spotify | مالکیت مبتنی بر Squad، هر اسکواد مالک داده‌هایش | PostgreSQL، Cassandra، Cloud Bigtable |

---

## ۹. خلاصه

الگوی **پایگاه داده به ازای هر سرویس** سنگ بنای [معماری میکروسرویس‌های](../architecture/microservices.fa.md) موفق است. با دادن یک ذخیره‌ساز داده خصوصی به هر سرویس، تمام مزایای میکروسرویس‌ها را به دست می‌آورید: اتصال سست، قابلیت استقرار مستقل، مقیاس‌دهی مستقل و آزادی فناوری.

با این حال، این استقلال هزینه‌ای دارد. JOINهای ساده بین سرویسی و تراکنش‌های ACID واحد را از دست می‌دهید و باید به جای آن الگوهایی مانند [الگوی Saga](../distributed-transactions/saga.fa.md)، [CQRS](./cqrs.fa.md) و [ترکیب API](./api-composition.fa.md) را برای مدیریت سازگاری داده و کوئری‌های بین سرویسی بپذیرید.

**چارچوب تصمیم‌گیری کلیدی:**

```
Do you need strong ACID transactions across services?
  |
  +-- Yes --> Consider Shared Database (accept the coupling)
  |           or use Saga Pattern (accept eventual consistency)
  |
  +-- No  --> Database per Service (recommended default)
              |
              +-- Same DB technology for all services?
              |     |
              |     +-- Yes --> Private Schema or Private DB Server
              |     +-- No  --> Polyglot Persistence
              |
              +-- Need cross-service queries?
                    |
                    +-- Simple --> API Composition
                    +-- Complex --> CQRS with read store
```

**چه زمانی از الگوی پایگاه داده به ازای هر سرویس استفاده کنیم:**
- در حال ساخت یک سیستم میکروسرویسی با تیم‌های مستقل هستید.
- سرویس‌ها نیازهای مختلف ذخیره‌سازی داده دارند.
- استقرار و مقیاس‌دهی مستقل اولویت‌ها هستند.
- می‌توانید سازگاری نهایی بین سرویس‌ها را بپذیرید.

**چه زمانی جایگزین‌ها را در نظر بگیریم:**
- سیستم شما تراکنش‌های گسترده بین سرویسی دارد که به سازگاری قوی نیاز دارند.
- سربار عملیاتی مدیریت چندین پایگاه داده برای تیم شما بیش از حد زیاد است.
- سیستم به اندازه کافی کوچک است که یک پایگاه داده یکپارچه ساده‌تر و کافی است.

---

> **مطالعه بیشتر:**
> - [الگوی Saga](../distributed-transactions/saga.fa.md) -- مدیریت تراکنش‌های توزیع‌شده
> - [CQRS](./cqrs.fa.md) -- بهینه‌سازی خواندن در مرزهای سرویس
> - [معماری میکروسرویس‌ها](../architecture/microservices.fa.md) -- زمینه معماری گسترده‌تر
> - [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) -- ستون فقرات رویدادی برای همگام‌سازی داده
