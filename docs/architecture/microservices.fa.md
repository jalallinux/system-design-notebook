# معماری Microservices

## 1. مقدمه

معماری Microservices یک سبک معماری است که یک برنامه را به صورت مجموعه‌ای از سرویس‌های مستقل و loosely coupled ساختار می‌دهد که به صورت مستقل قابل استقرار هستند. هر سرویس خودکفا بوده، یک قابلیت تجاری خاص را پیاده‌سازی کرده و با سرویس‌های دیگر از طریق APIهای تعریف شده ارتباط برقرار می‌کند.

اصطلاح "microservices" توسط Martin Fowler و James Lewis در مقاله مهم آن‌ها در سال 2014 رایج شد، اگرچه الگوهای معماری آن از اواخر دهه 2000 در شرکت‌هایی مانند Netflix و Amazon در حال تکامل بود.

**تعریف اصلی:**
> یک microservice یک سرویس کوچک و مستقل است که با سرویس‌های دیگر برای ارائه ارزش تجاری همکاری می‌کند.

**مفهوم کلیدی:**
Microservices نشان‌دهنده تغییر از ساخت برنامه‌های monolithic به ترکیب برنامه‌ها از سرویس‌های کوچک و مستقل است که می‌توانند به صورت مستقل توسعه، استقرار و مقیاس‌پذیری شوند.

## 2. معماری Monolithic

قبل از پرداختن به microservices، درک معماری monolithic که از آن تکامل یافته‌اند، ضروری است.

### 2.1 Monolith چیست؟

یک برنامه monolithic به عنوان یک واحد واحد و تقسیم‌ناپذیر ساخته می‌شود. تمام کامپوننت‌ها - رابط کاربری، منطق تجاری و لایه‌های دسترسی به داده - به شدت به هم وابسته هستند و به عنوان یک سرویس واحد اجرا می‌شوند.

```
┌─────────────────────────────────────────────────┐
│         MONOLITHIC APPLICATION                  │
│                                                 │
│  ┌───────────────────────────────────────────┐ │
│  │        User Interface Layer               │ │
│  └───────────────────────────────────────────┘ │
│                     ↓                           │
│  ┌───────────────────────────────────────────┐ │
│  │        Business Logic Layer               │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐  │ │
│  │  │ Module A │ │ Module B │ │ Module C │  │ │
│  │  └──────────┘ └──────────┘ └──────────┘  │ │
│  └───────────────────────────────────────────┘ │
│                     ↓                           │
│  ┌───────────────────────────────────────────┐ │
│  │        Data Access Layer                  │ │
│  └───────────────────────────────────────────┘ │
│                     ↓                           │
│  ┌───────────────────────────────────────────┐ │
│  │           Single Database                 │ │
│  └───────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
        Single Deployment Unit
```

### 2.2 مزایا و معایب Monolith

| جنبه | مزایا | معایب |
|--------|------------|---------------|
| **توسعه** | ساده برای توسعه اولیه | کد به مرور زمان پیچیده می‌شود |
| **تست** | تست end-to-end آسان | زمان اجرای تست طولانی |
| **استقرار** | فرآیند استقرار واحد | استقرار همه یا هیچ |
| **مقیاس‌پذیری** | مقیاس‌پذیری عمودی ساده | باید کل برنامه را مقیاس داد |
| **تکنولوژی** | یک stack تکنولوژی | سخت برای پذیرش تکنولوژی‌های جدید |
| **ساختار تیم** | هماهنگی آسان در ابتدا | تیم‌ها مانع یکدیگر می‌شوند |
| **عملکرد** | بدون تأخیر شبکه بین ماژول‌ها | گلوگاه‌های عملکرد بر همه چیز تأثیر می‌گذارند |
| **قابلیت اطمینان** | مدل شکست ساده | نقطه شکست واحد |

### 2.3 کی Monolith خوب کار می‌کند

معماری Monolithic برای موارد زیر مناسب است:

- **استارتاپ‌های مرحله اولیه** - تکرار سریع، نیازمندی‌های نامشخص
- **تیم‌های کوچک** (< 10 توسعه‌دهنده) - overhead هماهنگی کم
- **دامنه‌های ساده** - پیچیدگی تجاری محدود
- **Prototypeها و MVPها** - زمان سریع به بازار
- **برنامه‌ها با نیازمندی‌های coupling شدید** - مرزهای تراکنشی مشترک

## 3. ویژگی‌های Microservices

Martin Fowler و James Lewis نه ویژگی کلیدی معماری microservices را شناسایی کردند:

### 3.1 Componentization از طریق Services

کامپوننت‌ها واحدهای قابل تعویض و ارتقا مستقل هستند. در microservices، componentization از طریق سرویس‌ها به جای کتابخانه‌ها حاصل می‌شود.

```
LIBRARY-BASED COMPONENTIZATION        SERVICE-BASED COMPONENTIZATION
┌──────────────────────┐             ┌─────────┐  ┌─────────┐
│   Single Process     │             │Service A│  │Service B│
│  ┌────┐  ┌────┐     │             │ ┌────┐  │  │ ┌────┐  │
│  │Lib │  │Lib │     │             │ │Lib │  │  │ │Lib │  │
│  │ A  │  │ B  │     │             │ │ A  │  │  │ │ B  │  │
│  └────┘  └────┘     │             │ └────┘  │  │ └────┘  │
└──────────────────────┘             └────┬────┘  └────┬────┘
   In-memory calls                        │            │
                                          └─────┬──────┘
                                            Network calls
```

**مزایا:**
- استقرار مستقل
- تنوع تکنولوژی
- مرزهای کامپوننت واضح
- ایزوله‌سازی خطا

### 3.2 سازماندهی حول قابلیت‌های تجاری

سرویس‌ها حول قابلیت‌های تجاری سازماندهی می‌شوند، نه لایه‌های فنی (قانون Conway در عمل).

```
TRADITIONAL LAYERED TEAMS           MICROSERVICES BUSINESS TEAMS

┌────────────────────┐              ┌──────────────────────┐
│   UI Team          │              │  Order Service Team  │
├────────────────────┤              │  ┌────────────────┐  │
│   Business Team    │              │  │ UI             │  │
├────────────────────┤              │  ├────────────────┤  │
│   Database Team    │              │  │ Business Logic │  │
└────────────────────┘              │  ├────────────────┤  │
        ↓                           │  │ Database       │  │
  Coordination                      │  └────────────────┘  │
   Overhead                         └──────────────────────┘
                                    ┌──────────────────────┐
                                    │ Payment Service Team │
                                    │  ┌────────────────┐  │
                                    │  │ UI             │  │
                                    │  ├────────────────┤  │
                                    │  │ Business Logic │  │
                                    │  ├────────────────┤  │
                                    │  │ Database       │  │
                                    │  └────────────────┘  │
                                    └──────────────────────┘
```

### 3.3 محصولات نه پروژه‌ها

تیم‌ها مالک سرویس برای کل طول عمر آن هستند - "شما آن را می‌سازید، شما آن را اجرا می‌کنید" (Werner Vogels، CTO آمازون).

**ذهنیت پروژه:**
- ساخت و تحویل به عملیات
- تیم بعد از تحویل منحل می‌شود
- مسئولیت بلندمدت محدود

**ذهنیت محصول:**
- مالکیت و تکامل مداوم
- تیم با سرویس باقی می‌ماند
- مسئولیت کامل DevOps
- تمرکز بر نتیجه تجاری

### 3.4 Endpointهای هوشمند و Pipeهای ساده

استفاده از مکانیسم‌های ارتباطی ساده و سبک‌وزن. سرویس‌ها درخواست‌ها را دریافت، پردازش و پاسخ ارسال می‌کنند - پیچیدگی در endpointها است، نه زیرساخت.

```
ESB (Enterprise Service Bus) - AVOID
┌─────────┐           ┌─────────────────┐           ┌─────────┐
│Service A│──────────▶│  Smart ESB      │──────────▶│Service B│
└─────────┘           │ • Routing       │           └─────────┘
                      │ • Transformation│
                      │ • Orchestration │
                      │ • Business Logic│
                      └─────────────────┘

MICROSERVICES - PREFERRED
┌─────────┐           ┌─────────┐           ┌─────────┐
│Service A│──────────▶│Dumb Pipe│──────────▶│Service B│
│ (Smart) │  HTTP/    │ (HTTP,  │  Request  │ (Smart) │
│         │  Message  │  Msg    │           │         │
└─────────┘           │ Queue)  │           └─────────┘
                      └─────────┘
```

"Dumb pipes" رایج:
- HTTP/REST
- gRPC
- Message brokerها ([RabbitMQ، Kafka](../messaging/rabbitmq-vs-kafka.fa.md))
- صف پیام‌های ساده

### 3.5 حاکمیت غیرمتمرکز

هیچ stack تکنولوژی واحدی برای همه سرویس‌ها وجود ندارد. تیم‌ها بهترین ابزار را برای مشکل خاص خود انتخاب می‌کنند.

**حاکمیت سنتی:**
- استانداردسازی روی یک پلتفرم واحد (Java EE، .NET)
- هیئت معماری مرکزی همه تصمیمات را تأیید می‌کند
- راه‌حل‌های یک‌اندازه برای همه

**حاکمیت غیرمتمرکز:**
- برنامه‌نویسی چندزبانه (Java، Go، Python، Node.js)
- تیم‌ها ابزارهای خود را انتخاب می‌کنند
- شیوه‌های مشترک، نه استانداردهای اجباری
- مدل open-source داخلی

### 3.6 مدیریت داده غیرمتمرکز

هر سرویس دیتابیس خود را مدیریت می‌کند. هیچ دیتابیس مشترکی بین سرویس‌ها وجود ندارد.

```
SHARED DATABASE (Monolith)
┌─────────┐  ┌─────────┐  ┌─────────┐
│Service A│  │Service B│  │Service C│
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┴────────────┘
                  ↓
        ┌──────────────────┐
        │ Shared Database  │
        └──────────────────┘

DATABASE PER SERVICE (Microservices)
┌─────────┐       ┌─────────┐       ┌─────────┐
│Service A│       │Service B│       │Service C│
└────┬────┘       └────┬────┘       └────┬────┘
     ↓                 ↓                 ↓
┌─────────┐       ┌─────────┐       ┌─────────┐
│  DB A   │       │  DB B   │       │  DB C   │
└─────────┘       └─────────┘       └─────────┘
```

**مزایا:**
- دیتابیس مناسب برای کار (SQL، NoSQL، Graph)
- تکامل مستقل schema
- ایزوله‌سازی سرویس

**چالش‌ها:**
- تراکنش‌های توزیع‌شده (ببینید [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) و [Saga Pattern](../distributed-transactions/saga.fa.md))
- سازگاری داده (ببینید [CAP Theorem](../fundamentals/cap-theorem.fa.md))
- کوئری‌های cross-service

### 3.7 اتوماسیون زیرساخت

اتکای زیاد به تست خودکار، استقرار و provisioning زیرساخت.

**اتوماسیون ضروری:**
- Continuous Integration/Continuous Deployment (CI/CD)
- تست خودکار (unit، integration، contract، end-to-end)
- Infrastructure as Code (Terraform، CloudFormation)
- Container orchestration (Kubernetes، Docker Swarm)
- مانیتورینگ و alerting خودکار
- Service discovery و load balancing

### 3.8 طراحی برای شکست

سرویس‌ها باید برای تحمل شکست سرویس‌های وابسته طراحی شوند.

**الگوهای انعطاف‌پذیری:**
- [Circuit Breaker](../resilience/circuit-breaker.fa.md) - جلوگیری از شکست‌های آبشاری
- Timeoutها - شکست سریع
- Retryها با exponential backoff
- Bulkheadها - ایزوله کردن منابع
- Fallbackها - تخریب تدریجی
- Health checkها و monitoring

```
SERVICE FAILURE HANDLING

Client                Service A               Service B
  │                      │                      │
  │──────request────────▶│                      │
  │                      │─────request─────────▶│
  │                      │                      │
  │                      │                      │ (Service B fails)
  │                      │                      ✗
  │                      │
  │                      │◀──Circuit Breaker────┘
  │                      │   (Opens after N failures)
  │                      │
  │                      │──Fallback Response──▶
  │◀──fallback result────│
  │                      │
```

### 3.9 طراحی تکاملی

طراحی برای قابلیت تعویض. سرویس‌ها باید به اندازه کافی کوچک باشند که در صورت نیاز بازنویسی شوند.

**اصول:**
- سرویس‌ها یکبار مصرف هستند - قابل تعویض
- refactoring مداوم
- مهاجرت تدریجی از monolith
- تحمل نسخه‌های متعدد به طور همزمان
- تحویل تدریجی (canary، blue-green deployments)

## 4. مقایسه Monolith در مقابل Microservices

| بعد | معماری Monolithic | معماری Microservices |
|-----------|------------------------|----------------------------|
| **استقرار** | واحد استقرار واحد | استقرارهای مستقل متعدد |
| **مقیاس‌پذیری** | مقیاس کل برنامه | مقیاس مستقل سرویس‌های فردی |
| **Technology Stack** | یک stack تکنولوژی | Polyglot - stackهای مختلف در هر سرویس |
| **توسعه** | ساده در ابتدا، پیچیده با گذشت زمان | پیچیده در ابتدا، قابل مدیریت با گذشت زمان |
| **اندازه تیم** | خوب با تیم‌های کوچک کار می‌کند | بهتر برای سازمان‌های بزرگتر |
| **دیتابیس** | دیتابیس مشترک واحد | دیتابیس در هر سرویس |
| **تراکنش‌ها** | تراکنش‌های ACID آسان | تراکنش‌های توزیع‌شده پیچیده |
| **سازگاری داده** | سازگاری قوی | اغلب سازگاری نهایی مورد نیاز است |
| **تست** | تست end-to-end آسان‌تر | تست integration پیچیده |
| **عملکرد** | فراخوانی‌های سریع in-memory | تأخیر شبکه بین سرویس‌ها |
| **دیباگ** | ردیابی اجرا آسان‌تر | distributed tracing مورد نیاز |
| **ریسک استقرار** | بالا - همه یا هیچ | پایین - استقرارهای ایزوله |
| **تأثیر شکست** | شکست کامل | شکست جزئی (اگر به خوبی طراحی شده باشد) |
| **زمان به بازار** | سریع‌تر در ابتدا | راه‌اندازی کندتر، تکرار سریع‌تر بعداً |
| **پیچیدگی عملیاتی** | پایین | بالا - نیاز به بلوغ DevOps |
| **هزینه** | زیرساخت کمتر در ابتدا | هزینه‌های بالاتر زیرساخت و ابزار |
| **استقلال تیم** | پایین - codebase مشترک | بالا - تیم‌های مستقل |
| **ورود** | آسان‌تر برای توسعه‌دهندگان جدید | منحنی یادگیری تندتر |
| **استفاده مجدد کد** | آسان از طریق کتابخانه‌های مشترک | نیاز به فراخوانی سرویس یا تکرار |

## 5. الگوهای ارتباطی

Microservicesها از طریق رابط‌های تعریف‌شده ارتباط برقرار می‌کنند. انتخاب بین ارتباط همزمان و ناهمزمان به طور قابل‌توجهی بر رفتار سیستم تأثیر می‌گذارد.

### 5.1 ارتباط همزمان

سرویس‌ها قبل از ادامه منتظر پاسخ‌ها می‌مانند. فراخواننده تا اتمام فراخوانی مسدود می‌شود.

#### REST (HTTP/JSON)

```
Client              API Gateway           Service A           Service B
  │                     │                     │                   │
  │──GET /orders/123───▶│                     │                   │
  │                     │───GET /order/123───▶│                   │
  │                     │                     │                   │
  │                     │                     │──GET /user/456───▶│
  │                     │                     │                   │
  │                     │                     │◀──user data───────│
  │                     │                     │                   │
  │                     │◀──order data────────│                   │
  │                     │                     │                   │
  │◀──combined data─────│                     │                   │
  │                     │                     │                   │
```

**ویژگی‌ها:**
- الگوی request-response
- ساده برای درک و دیباگ
- coupling زمانی شدید
- کدهای وضعیت HTTP برای خطاها
- قراردادهای RESTful

**بهترین برای:**
- عملیات‌های رو به کاربر که نیاز به پاسخ فوری دارند
- کوئری‌های ساده
- عملیات‌هایی که نیاز به تأیید دارند

#### gRPC

فریم‌ورک RPC با عملکرد بالا با استفاده از Protocol Buffers.

**مزایا نسبت به REST:**
- قراردادهای strongly typed
- سریال‌سازی باینری کارآمد
- multiplexing HTTP/2
- پشتیبانی از streaming
- تولید کد برای کلاینت‌ها

**مثال:**
```protobuf
service OrderService {
  rpc GetOrder (OrderRequest) returns (OrderResponse);
  rpc StreamOrders (Empty) returns (stream Order);
}
```

### 5.2 ارتباط ناهمزمان

سرویس‌ها منتظر پاسخ‌ها نمی‌مانند. ارتباط از طریق پیام‌ها و رویدادها.

```
ASYNCHRONOUS EVENT-DRIVEN COMMUNICATION

Publisher              Message Broker            Subscriber
  │                         │                        │
  │──publish(OrderCreated)─▶│                        │
  │                         │                        │
  │  (returns immediately)  │                        │
  │                         │                        │
  │                         │──OrderCreated event───▶│
  │                         │                        │
  │                         │                        │ (processes async)
  │                         │                        │
```

**Message Brokerها:**
برای مقایسه دقیق، ببینید [RabbitMQ vs Kafka](../messaging/rabbitmq-vs-kafka.fa.md).

- **RabbitMQ** - صف پیام سنتی، پروتکل AMQP
- **Apache Kafka** - پلتفرم event streaming توزیع‌شده
- **Amazon SQS** - سرویس صف مدیریت‌شده
- **Google Pub/Sub** - سرویس messaging مدیریت‌شده

**مزایا:**
- coupling زمانی سست
- تحمل خطای بهتر
- آسان‌تر برای افزودن consumerهای جدید
- تسطیح بار طبیعی
- پشتیبانی از [Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md)

**چالش‌ها:**
- سازگار نهایی
- سخت‌تر برای دیباگ
- پیچیدگی ترتیب پیام
- مدیریت پیام تکراری (idempotency مورد نیاز)

### 5.3 انتخاب سبک ارتباطی

| عامل | همزمان (REST/gRPC) | ناهمزمان (Messages/Events) |
|--------|------------------------|--------------------------------|
| **زمان پاسخ** | پاسخ فوری مورد نیاز | می‌تواند بعداً پردازش شود |
| **سازگاری** | سازگاری قوی مورد نیاز | سازگاری نهایی قابل قبول |
| **Coupling** | coupling شدیدتر | coupling سست‌تر |
| **پیچیدگی** | ساده‌تر برای استدلال | پیچیده‌تر |
| **مدیریت شکست** | بازخورد فوری شکست | مکانیسم‌های retry مورد نیاز |
| **مقیاس‌پذیری** | محدود به کندترین سرویس | مدیریت بار بهتر |
| **موارد استفاده** | کوئری‌های کاربر، عملیات حیاتی | وظایف پس‌زمینه، اعلان‌ها، تحلیل |

## 6. مدیریت داده در Microservices

یکی از چالش‌برانگیزترین جنبه‌های microservices، مدیریت داده در مرزهای سرویس است.

### 6.1 الگوی Database per Service

**اصل اصلی:** هر microservice schema دیتابیس خود را دارد. سرویس‌ها نمی‌توانند مستقیماً به دیتابیس سرویس‌های دیگر دسترسی پیدا کنند.

```
┌─────────────────────┐         ┌─────────────────────┐
│  Order Service      │         │  Inventory Service  │
│  ┌──────────────┐   │         │  ┌──────────────┐   │
│  │ Order Logic  │   │         │  │ Inventory    │   │
│  └──────┬───────┘   │         │  │ Logic        │   │
│         │           │         │  └──────┬───────┘   │
│  ┌──────▼───────┐   │         │  ┌──────▼───────┐   │
│  │ Order DB     │   │         │  │ Inventory DB │   │
│  │ - orders     │   │         │  │ - stock      │   │
│  │ - order_items│   │         │  │ - warehouses │   │
│  └──────────────┘   │         │  └──────────────┘   │
└─────────────────────┘         └─────────────────────┘
         │                               │
         └──────────API calls────────────┘
         (NOT direct database access)
```

**مزایا:**
- coupling سست - سرویس‌ها به طور مستقل تکامل می‌یابند
- دیتابیس مناسب برای کار (polyglot persistence)
- ایزوله‌سازی سرویس - مشکلات دیتابیس منتشر نمی‌شوند
- مالکیت واضح - تیم صاحب داده و schema است

**انتخاب‌های تکنولوژی دیتابیس:**

| نوع سرویس | نوع دیتابیس | مثال |
|--------------|---------------|---------|
| پروفایل کاربر | Document DB | MongoDB، DynamoDB |
| کاتالوگ محصول | Document/Search | Elasticsearch، MongoDB |
| سفارش‌ها | Relational | PostgreSQL، MySQL |
| داده session | Key-Value | Redis، Memcached |
| گراف اجتماعی | Graph DB | Neo4j، Amazon Neptune |
| متریک‌های time-series | Time-series DB | InfluxDB، TimescaleDB |
| لاگ رویداد | Append-only log | Kafka، EventStore |

### 6.2 چالش‌های سازگاری داده

الگوی database-per-service چالش‌های سازگاری را به دلیل [CAP Theorem](../fundamentals/cap-theorem.fa.md) معرفی می‌کند.

**مشکل:** چگونه سازگاری را در سرویس‌ها بدون تراکنش‌های توزیع‌شده حفظ کنید؟

**راه‌حل‌ها:**

#### گزینه 1: Two-Phase Commit (2PC)

پروتکل تراکنش توزیع‌شده سنتی. برای جزئیات ببینید [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md).

```
Coordinator         Service A         Service B
    │                   │                 │
    │───Prepare─────────▶│                 │
    │                   │                 │
    │                   │──Lock resources─┘
    │                   │                 │
    │───Prepare─────────┼────────────────▶│
    │                   │                 │
    │                   │                 │──Lock resources
    │◀──Vote Commit─────│                 │
    │◀──Vote Commit─────┼─────────────────│
    │                   │                 │
    │───Commit──────────▶│                 │
    │───Commit──────────┼────────────────▶│
    │                   │                 │
```

**مشکلات 2PC:**
- پروتکل مسدودکننده - عملکرد ضعیف
- نقطه شکست واحد (coordinator)
- مناسب برای microservices نیست
- استقلال سرویس را نقض می‌کند

#### گزینه 2: Saga Pattern (توصیه‌شده)

دنباله‌ای از تراکنش‌های محلی با تراکنش‌های جبرانی. برای جزئیات جامع ببینید [Saga Pattern](../distributed-transactions/saga.fa.md).

```
SAGA - Choreography Based

Order Service    Payment Service    Inventory Service
     │                  │                   │
     │──OrderCreated───▶│                   │
     │                  │                   │
     │                  │──PaymentProcessed─▶│
     │                  │                   │
     │                  │                   │──InventoryReserved
     │                  │                   │
     │◀─────────────────┴───────────────────┘
     │         OrderCompleted
     │
```

**مزایای Saga:**
- بدون قفل‌های توزیع‌شده
- عملکرد بهتر
- هر سرویس مستقل باقی می‌ماند
- برازش طبیعی برای سیستم‌های event-driven

**چالش‌های Saga:**
- سازگاری نهایی
- پیچیدگی منطق جبرانی
- فقدان ایزوله‌سازی (خوانش‌های کثیف ممکن)

### 6.3 کوئری در سرویس‌ها

**مشکل:** چگونه داده‌ای که چند سرویس را شامل می‌شود کوئری کنید؟

**راه‌حل‌ها:**

#### API Composition

```
┌─────────────────┐
│  API Gateway    │
│  /order/123     │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
┌─────┐   ┌──────┐   ┌───────────┐
│Order│   │User  │   │ Inventory │
│Svc  │   │Svc   │   │ Svc       │
└─────┘   └──────┘   └───────────┘
```

1. Gateway از Order Service کوئری می‌کند
2. Gateway از User Service با user ID کوئری می‌کند
3. Gateway از Inventory Service با product IDها کوئری می‌کند
4. Gateway نتایج را ترکیب می‌کند

**مزایا:** ساده، برای کوئری‌های کوچک کار می‌کند
**معایب:** چندین فراخوانی شبکه، مشکلات احتمالی عملکرد

#### CQRS (Command Query Responsibility Segregation)

جداسازی مدل‌های خواندن و نوشتن. برای الگوهای دقیق ببینید [CQRS](../data-patterns/cqrs.fa.md).

```
WRITE SIDE                          READ SIDE
┌─────────────┐                    ┌─────────────┐
│Order Service│                    │Query Service│
│  Write DB   │                    │  Read DB    │
└──────┬──────┘                    └──────▲──────┘
       │                                  │
       │──Events──▶│ Event Stream │──────┘
       │           └──────────────┘
       │                    │
       │                    │ (Projection)
       │                    ▼
       │           ┌──────────────────┐
       │           │ Denormalized     │
       │           │ Read-Optimized   │
       │           │ Views            │
       │           └──────────────────┘
```

**مزایا:**
- مدل‌های خواندن بهینه‌شده
- کوئری‌های مقیاس‌پذیر
- بدون تأثیر بر عملکرد نوشتن

**چالش‌ها:**
- سازگاری نهایی
- تکرار داده
- پیچیدگی

## 7. الگوهای کلیدی Microservices

### 7.1 الگوی API Gateway

نقطه ورودی واحد برای همه کلاینت‌ها. برای پوشش جامع ببینید [API Gateway](api-gateway.fa.md).

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│Mobile   │  │Web App  │  │3rd Party│
│Client   │  │Client   │  │Client   │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┴────────────┘
                  │
          ┌───────▼────────┐
          │  API Gateway   │
          │  • Routing     │
          │  • Auth        │
          │  • Rate Limit  │
          │  • Aggregation │
          └───────┬────────┘
                  │
     ┌────────────┼────────────┐
     │            │            │
┌────▼───┐   ┌───▼────┐   ┌───▼────┐
│Service │   │Service │   │Service │
│   A    │   │   B    │   │   C    │
└────────┘   └────────┘   └────────┘
```

**مسئولیت‌ها:**
- مسیریابی درخواست
- احراز هویت و مجوز
- محدودسازی نرخ و throttling
- تبدیل request/response
- ترجمه پروتکل (REST به gRPC)
- Caching
- مانیتورینگ و logging

**راه‌حل‌های محبوب:**
- Netflix Zuul
- Kong
- Amazon API Gateway
- Nginx
- Traefik

### 7.2 الگوی Circuit Breaker

جلوگیری از شکست‌های آبشاری. برای پیاده‌سازی دقیق ببینید [Circuit Breaker](../resilience/circuit-breaker.fa.md).

```
CIRCUIT BREAKER STATES

CLOSED (Normal Operation)          OPEN (Failing)
┌────────────────┐                ┌────────────────┐
│ Request        │                │ Request        │
│    ↓           │   Threshold    │    ↓           │
│ [Circuit]      │   Exceeded     │ [Circuit]      │
│    ↓           │   ────────▶    │    ↓           │
│ Service Call   │                │ Fail Fast      │
│    ↓           │                │ (No call)      │
│ Response       │                │    ↓           │
└────────────────┘                │ Fallback       │
                                  └────────────────┘
                                         │
                                    Timeout
                                         │
                                         ▼
                                  ┌────────────────┐
                                  │ HALF-OPEN      │
                                  │ (Testing)      │
                                  │ Limited calls  │
                                  │ to test health │
                                  └────────────────┘
```

**پارامترهای پیکربندی:**
- آستانه شکست (مثلاً 50% شکست در 10 درخواست)
- دوره timeout (مثلاً 30 ثانیه)
- آستانه موفقیت برای بستن (مثلاً 5 موفقیت متوالی)

### 7.3 الگوی Service Discovery

سرویس‌ها به طور پویا مکان‌های شبکه سرویس‌های دیگر را کشف می‌کنند.

```
SERVICE REGISTRY PATTERN

┌─────────────────────────────────────────┐
│         Service Registry                │
│  (Consul, Eureka, Zookeeper, etcd)     │
│                                         │
│  service-a: [10.0.1.5:8080,            │
│              10.0.1.6:8080]            │
│  service-b: [10.0.2.3:8081]            │
└────▲──────────────────────┬─────────────┘
     │                      │
     │ Register             │ Discover
     │ Heartbeat            │ Query
     │                      │
┌────┴──────┐          ┌────▼──────┐
│Service A  │          │Service B  │
│Instance 1 │          │           │
└───────────┘          └───────────┘
┌───────────┐
│Service A  │
│Instance 2 │
└───────────┘
```

**Client-Side Discovery:**
- کلاینت از registry کوئری می‌کند
- کلاینت load balancing را انجام می‌دهد
- مثال‌ها: Netflix Ribbon، Eureka

**Server-Side Discovery:**
- Load balancer از registry کوئری می‌کند
- کلاینت load balancer را فراخوانی می‌کند
- مثال‌ها: AWS ELB، Kubernetes Services

### 7.4 الگوی Saga

مدیریت تراکنش‌های توزیع‌شده. ببینید [Saga Pattern](../distributed-transactions/saga.fa.md).

**Choreography-Based Saga:**
```
Service A         Service B         Service C
    │                 │                 │
    │──Event1────────▶│                 │
    │                 │                 │
    │                 │──Event2────────▶│
    │                 │                 │
    │                 │                 │──Event3
    │◀────────────────┴─────────────────┘
```

**Orchestration-Based Saga:**
```
                Saga Orchestrator
                      │
        ┌─────────────┼─────────────┐
        │             │             │
        ▼             ▼             ▼
    Service A     Service B     Service C
        │             │             │
        │             │             │
        └─────────────┴─────────────┘
              (reports back)
```

### 7.5 الگوی CQRS

مدل‌های جداگانه برای خواندن و نوشتن. ببینید [CQRS](../data-patterns/cqrs.fa.md).

```
Commands                                Queries
(Writes)                               (Reads)
    │                                      │
    ▼                                      │
┌─────────┐         ┌──────────┐          │
│Command  │─Events─▶│ Event    │──────────┤
│Service  │         │ Store    │          │
└─────────┘         └──────────┘          │
    │                    │                 │
    ▼                    │ Projection      ▼
┌─────────┐              ▼           ┌─────────┐
│Write DB │                          │Read DB  │
└─────────┘                          │(Denorm) │
                                     └─────────┘
```

**مزایا:**
- مدل‌های خواندن و نوشتن بهینه‌شده
- مقیاس‌پذیری مستقل
- کوئری‌های ساده‌شده
- سازگاری با event sourcing

### 7.6 Event Sourcing

ذخیره state به عنوان دنباله‌ای از رویدادها به جای state فعلی.

```
TRADITIONAL STATE STORAGE    EVENT SOURCING

Current State:               Event Log:
┌──────────────┐            1. AccountCreated(id:123, balance:0)
│ Account      │            2. MoneyDeposited(id:123, amount:100)
│ id: 123      │            3. MoneyWithdrawn(id:123, amount:30)
│ balance: 70  │            4. MoneyDeposited(id:123, amount:50)
└──────────────┘
                            Current State = Replay all events
                            Balance: 0 + 100 - 30 + 50 = 120
```

**مزایا:**
- رد تمام audit
- کوئری‌های زمانی (state در هر نقطه از زمان)
- برازش طبیعی معماری event-driven
- دیباگ و تست آسان‌تر

**چالش‌ها:**
- تکامل schema رویداد
- مکانیسم snapshot برای عملکرد مورد نیاز
- ذخیره‌سازی افزایش‌یافته
- پیچیدگی کوئری

## 8. مبادلات و چالش‌ها

### 8.1 مزایای Microservices

| مزیت | توضیح | تأثیر |
|---------|-------------|--------|
| **استقرار مستقل** | استقرار جداگانه سرویس‌ها بدون تأثیر بر دیگران | انتشار سریع‌تر، کاهش ریسک استقرار |
| **تنوع تکنولوژی** | انتخاب بهترین ابزار برای هر کار | نوآوری، جذب استعدادهای متنوع |
| **مقیاس‌پذیری** | مقیاس مستقل سرویس‌ها بر اساس تقاضا | کارایی هزینه، عملکرد بهتر |
| **ایزوله‌سازی خطا** | شکست در یک سرویس کل سیستم را crash نمی‌کند | در دسترس بودن بالاتر |
| **استقلال تیم** | تیم‌ها مالک سرویس‌ها به صورت end-to-end هستند | توسعه سریع‌تر، مالکیت واضح |
| **نگهداری آسان‌تر** | codebaseهای کوچک‌تر برای درک آسان‌تر | بار شناختی کمتر، onboarding سریع‌تر |
| **قابلیت تعویض** | سرویس‌ها در صورت نیاز قابل بازنویسی | کاهش بدهی فنی |
| **توسعه موازی** | تیم‌ها به طور مستقل کار می‌کنند | زمان سریع‌تر به بازار |

### 8.2 معایب و چالش‌ها

| چالش | توضیح | کاهش |
|-----------|-------------|------------|
| **پیچیدگی سیستم توزیع‌شده** | فراخوانی‌های شبکه، تأخیر، شکست‌های جزئی | Circuit breakerها، timeoutها، retryها |
| **سازگاری داده** | بدون تراکنش‌های ACID در سرویس‌ها | الگوی Saga، سازگاری نهایی |
| **Overhead عملیاتی** | سرویس‌های بیشتر برای استقرار، مانیتور، نگهداری | اتوماسیون، Kubernetes، ابزارهای مانیتورینگ |
| **پیچیدگی تست** | تست integration سخت‌تر | تست contract، محیط‌های تست |
| **Distributed Tracing** | سخت برای ردیابی درخواست‌ها در سرویس‌ها | Zipkin، Jaeger، OpenTelemetry |
| **تأخیر شبکه** | فراخوانی‌های inter-service کندتر از in-process | Caching، ارتباط async، batching |
| **نسخه‌بندی سرویس** | چند نسخه به طور همزمان در حال اجرا | استراتژی versioning API، backward compatibility |
| **امنیت** | سطح حمله بیشتر، auth بین سرویس | Service mesh، mTLS، API gateway |
| **تکرار داده** | داده در سرویس‌ها تکرار شده | پذیرش به عنوان مبادله، همگام‌سازی داده denormalized |
| **هماهنگی تیم** | تیم‌های متعدد نیاز به هماهنگی دارند | قراردادهای واضح، مستندات، ارتباط |
| **دیباگ** | سخت‌تر برای دیباگ سیستم‌های توزیع‌شده | logging متمرکز، distributed tracing |
| **هزینه اولیه** | زیرساخت و ابزار گران | شروع با monolith مدولار، مهاجرت تدریجی |

### 8.3 مالیات Microservices

Martin Fowler overhead microservices را "مالیات microservices" می‌نامد. شما این مالیات را در موارد زیر پرداخت می‌کنید:

1. **هزینه زیرساخت** - سرورها، containerها، orchestration بیشتر
2. **پیچیدگی عملیاتی** - ابزارهای مانیتورینگ، logging، tracing
3. **Overhead توسعه** - قالب‌های سرویس، کتابخانه‌های مشترک
4. **پیچیدگی تست** - تست‌های contract، تست‌های integration
5. **هماهنگی تیم** - مستندات API، قراردادهای سرویس
6. **منحنی یادگیری** - دانش سیستم‌های توزیع‌شده مورد نیاز

**سوال حیاتی:** آیا مزایا ارزش مالیات را برای سازمان شما دارند؟

## 9. کی از Microservices استفاده کنیم

### 9.1 نامزدهای خوب برای Microservices

Microservices زمانی مناسب است که داشته باشید:

**عوامل سازمانی:**
- سازمان مهندسی بزرگ (50+ توسعه‌دهنده)
- تیم‌های مستقل متعدد
- فرهنگ DevOps و بلوغ اتوماسیون
- چشم‌انداز بلندمدت محصول

**عوامل فنی:**
- دامنه پیچیده با قابلیت‌های تجاری متمایز
- نیازمندی‌های مقیاس‌پذیری متفاوت برای ویژگی‌های مختلف
- نیاز به تنوع تکنولوژی
- استقرارهای مکرر مورد نیاز

**عوامل تجاری:**
- نیازمندی‌های در دسترس بودن بالا
- زمان سریع به بازار برای ویژگی‌ها
- بخش‌های مختلف سیستم SLAهای متفاوت دارند
- نیاز به آزمایش و شکست سریع

**شاخص‌های دنیای واقعی:**
- استقرار Monolith ساعت‌ها طول می‌کشد
- تیم‌ها مانع یکدیگر می‌شوند
- مقیاس کل برنامه وقتی فقط یک ویژگی به آن نیاز دارد
- stack تکنولوژی مانع نوآوری می‌شود

### 9.2 کی از Microservices اجتناب کنیم

Microservices ممکن است مناسب نباشد وقتی:

**پرچم‌های قرمز سازمانی:**
- تیم کوچک (< 10 توسعه‌دهنده)
- بلوغ محدود DevOps
- عدم فرهنگ اتوماسیون
- اولین محصول یا MVP استارتاپ

**پرچم‌های قرمز فنی:**
- دامنه ساده
- نیازمندی‌های coupling شدید داده
- عملکرد realtime حیاتی
- تخصص محدود سیستم‌های توزیع‌شده

**پرچم‌های قرمز تجاری:**
- نیازمندی‌های نامشخص
- نیاز به اعتبارسنجی مدل تجاری ابتدا
- بودجه محدود
- پروژه کوتاه‌مدت

### 9.3 جایگزین Modular Monolith

قبل از پرش به microservices، یک **modular monolith** را در نظر بگیرید:

```
MODULAR MONOLITH
┌─────────────────────────────────────────┐
│          Single Deployment Unit         │
│                                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐│
│  │ Order   │  │Payment  │  │Inventory││
│  │ Module  │  │Module   │  │Module   ││
│  │         │  │         │  │         ││
│  └────┬────┘  └────┬────┘  └────┬────┘│
│       │            │            │     │
│       └────────────┴────────────┘     │
│                    │                  │
│            ┌───────▼────────┐         │
│            │ Shared Database│         │
│            └────────────────┘         │
└─────────────────────────────────────────┘

Well-defined module boundaries
Clear interfaces between modules
Easier to extract to microservices later
```

**مزایا:**
- پیچیدگی عملیاتی کمتر
- تراکنش‌های ACID
- تست و دیباگ آسان‌تر
- می‌تواند بعداً به microservices تکامل یابد

**مسیر مهاجرت:**
1. شروع با modular monolith
2. اعتبارسنجی مدل تجاری
3. شناسایی مرزها
4. استخراج یک سرویس در یک زمان
5. ساخت اتوماسیون و مانیتورینگ
6. ادامه استخراج در صورت نیاز

## 10. مثال‌های دنیای واقعی

### 10.1 Netflix

**مقیاس:** 200+ میلیون مشترک، 15,000+ microservices

**تکامل معماری:**
```
2008: سیستم اجاره DVD monolithic
2009: شروع مهاجرت به AWS
2012: کاملاً روی AWS، معماری microservices
2020: 700+ microservices
2023: تکامل مداوم با 15,000+ microservices
```

**سرویس‌های کلیدی:**
- **Zuul** - API Gateway
- **Eureka** - Service discovery
- **Ribbon** - Client-side load balancing
- **Hystrix** - Circuit breaker (اکنون deprecated، از Resilience4j استفاده کنید)
- **Chaos Monkey** - تست انعطاف‌پذیری

**درس‌های آموخته‌شده:**
- طراحی برای شکست از روز اول
- خودکار کردن همه چیز
- سرمایه‌گذاری زیاد در ابزار و observability
- chaos engineering ضروری
- تغییر فرهنگ به اندازه تکنولوژی مهم است

### 10.2 Amazon

**نقل قول از Werner Vogels (CTO):** "شما آن را می‌سازید، شما آن را اجرا می‌کنید."

**معماری:**
- تحول microservices را در 2001 شروع کرد
- تیم‌های two-pizza (تیم‌های کوچک و مستقل)
- معماری service-oriented
- هر تیم مالک سرویس‌ها به صورت end-to-end است

**نوآوری‌های کلیدی:**
- AWS از پلتفرم سرویس داخلی رشد کرد
- فرهنگ API-first
- الگوهای سیستم توزیع‌شده در مقیاس

**مثال سرویس‌ها:**
- سرویس کاتالوگ محصول
- سرویس قیمت‌گذاری
- سرویس موجودی
- سرویس توصیه
- سرویس سبد خرید
- سرویس checkout
- سرویس پرداخت

### 10.3 Uber

**مقیاس:** 500+ میلیون مسافر، 2,200+ microservices

**تکامل:**
```
2012: برنامه Rails monolithic
2014: شروع مهاجرت microservices
2016: صدها microservices
2020: 2,200+ microservices
```

**نکات برجسته معماری:**
- پردازش داده realtime
- سرویس‌های توزیع‌شده جغرافیایی
- معماری event-driven
- Microservicesهای domain-oriented

**سرویس‌های دامنه:**
- مدیریت سفر
- Dispatch و matching
- قیمت‌گذاری و surge
- مدیریت راننده
- پردازش پرداخت
- Maps و مسیریابی

**چالش‌های پیش‌رو:**
- شکست‌های آبشاری در روزهای اولیه
- دیباگ سیستم‌های توزیع‌شده
- سازگاری داده در سرویس‌ها
- Service discovery در مقیاس

**راه‌حل‌ها:**
- ساخت فریم‌ورک TChannel RPC (بعداً gRPC را پذیرفت)
- توسعه Jaeger برای distributed tracing
- ایجاد معماری domain-oriented
- سرمایه‌گذاری در پلتفرم‌های observability

### 10.4 Spotify

**مقیاس:** 500+ میلیون کاربر، صدها microservices

**ساختار تیم:**
- **Squadها** - تیم‌های کوچک cross-functional (< 8 نفر)
- **Tribeها** - مجموعه squadها در حوزه‌های مرتبط
- **Chapterها** - افراد با مهارت‌های مشابه در squadها
- **Guildها** - جامعه علاقه در سازمان

**معماری:**
- سرویس‌های Backend در Java، Python، Go
- ارتباط event-driven
- Google Cloud Platform و AWS
- Kubernetes برای orchestration

**یادگیری‌های کلیدی:**
- قانون Conway واقعی است - ساختار تیم مهم است
- استقلال نیاز به مرزهای واضح دارد
- پلتفرم‌های داخلی تکرار را کاهش می‌دهند
- فرهنگ و معماری با هم تکامل می‌یابند

## 11. استراتژی مهاجرت

### 11.1 الگوی Strangler Fig

تعویض تدریجی monolith با قرار دادن سرویس‌های جدید در جلو.

```
PHASE 1: Monolith                PHASE 2: Partial Migration
┌────────────┐                   ┌────────────┐
│            │                   │  Proxy     │
│  Monolith  │                   └──────┬─────┘
│            │                          │
└────────────┘                    ┌─────┴─────┐
                                  │           │
                                  ▼           ▼
                             ┌──────┐   ┌──────────┐
                             │New   │   │ Monolith │
                             │Svc A │   │(reduced) │
                             └──────┘   └──────────┘

PHASE 3: Full Migration
┌────────────┐
│  Proxy     │
└──────┬─────┘
       │
   ┌───┴───┬────┬────┐
   ▼       ▼    ▼    ▼
┌────┐  ┌────┐┌────┐┌────┐
│SvcA│  │SvcB││SvcC││SvcD│
└────┘  └────┘└────┘└────┘
```

**مراحل:**
1. شناسایی bounded context برای استخراج
2. ساخت microservice جدید
3. مسیریابی ترافیک از طریق proxy/gateway
4. تغییر مسیر تدریجی ترافیک به سرویس جدید
5. حذف قابلیت از monolith
6. تکرار برای سرویس بعدی

### 11.2 Anti-Corruption Layer

ترجمه بین مدل‌های monolith و microservices.

```
┌──────────────┐         ┌────────────────┐         ┌──────────────┐
│  Monolith    │◀───────▶│ Anti-Corruption│◀───────▶│Microservice  │
│              │         │     Layer      │         │              │
│ Old model    │         │  Translation   │         │ New model    │
└──────────────┘         └────────────────┘         └──────────────┘
```

### 11.3 بهترین شیوه‌های مهاجرت

1. **شروع با مرزهای واضح** - Domain-driven design
2. **استخراج یک سرویس در یک زمان** - مهاجرت تدریجی
3. **ساخت اتوماسیون ابتدا** - CI/CD، مانیتورینگ
4. **حفظ سلامت monolith** - اجازه ندهید در طول مهاجرت فاسد شود
5. **اندازه‌گیری همه چیز** - متریک‌ها قبل و بعد
6. **برنامه‌ریزی برای rollback** - feature flagها، canary deployments
7. **آموزش تیم** - دانش سیستم‌های توزیع‌شده
8. **عجله نکنید** - مهاجرت می‌تواند سال‌ها طول بکشد

## 12. بهترین شیوه‌ها و اصول

### 12.1 اصول طراحی

1. **مسئولیت واحد** - یک سرویس، یک کار
2. **انسجام بالا** - قابلیت مرتبط با هم
3. **Coupling سست** - به حداقل رساندن وابستگی‌ها
4. **API First** - طراحی قرارداد قبل از پیاده‌سازی
5. **Idempotency** - درخواست یکسان، نتیجه یکسان (حیاتی برای retryها)
6. **سرویس‌های Stateless** - ذخیره state به صورت خارجی
7. **شکست سریع** - بی‌نهایت منتظر نمانید
8. **طراحی برای شکست** - فرض کنید چیزها خراب می‌شوند
9. **سازگاری با گذشته** - کلاینت‌های موجود را نشکنید
10. **Observability** - logging، metrics، tracing داخلی

### 12.2 بهترین شیوه‌های عملیاتی

**مانیتورینگ:**
- Logging متمرکز (ELK، Splunk، CloudWatch)
- Distributed tracing (Jaeger، Zipkin، AWS X-Ray)
- Metricsها و داشبوردها (Prometheus، Grafana، DataDog)
- Health checkها و readiness probeها
- Service Level Objectives (SLOs) و Indicators (SLIs)

**استقرار:**
- Blue-green deployments
- Canary releases
- Feature flags
- Rolling updates
- Rollback خودکار

**امنیت:**
- mTLS بین سرویس‌ها
- API gateway برای احراز هویت
- Service mesh برای شبکه zero-trust
- مدیریت Secretها (HashiCorp Vault، AWS Secrets Manager)
- ممیزی‌های امنیتی منظم

**تست:**
- تست‌های unit برای منطق تجاری
- تست‌های integration برای تعاملات سرویس
- تست‌های Contract (Pact، Spring Cloud Contract)
- تست‌های End-to-end (محدود، متمرکز بر مسیرهای حیاتی)
- Chaos engineering (Chaos Monkey، Gremlin)

### 12.3 راهنمای اندازه سرویس

**یک Microservice چقدر کوچک باید باشد؟**

**نه خیلی کوچک:**
- بیشتر از یک تابع واحد
- قابلیت تجاری واضح دارد
- توسط یک تیم قابل توسعه
- overhead عملیاتی را توجیه می‌کند

**نه خیلی بزرگ:**
- می‌تواند در 2-4 هفته بازنویسی شود
- < 1000-2000 خط کد (قاعده سرانگشتی)
- دیتابیس واحد
- Bounded context واضح

**راهنمایی Sam Newman:** "Microservicesها باید تا حد امکان کوچک باشند، اما نه کوچک‌تر."

## 13. Microservices در مقابل Serverless

برای معماری‌های serverless، ببینید [Serverless](serverless.fa.md).

**مقایسه سریع:**

| جنبه | Microservices | Serverless (FaaS) |
|--------|--------------|-------------------|
| **واحد استقرار** | سرویس (container) | تابع |
| **State** | می‌تواند stateful باشد | Stateless |
| **مقیاس‌پذیری** | Manual/auto-scaling | Auto-scales به صفر |
| **مدل هزینه** | پرداخت برای instanceهای در حال اجرا | پرداخت به ازای فراخوانی |
| **زمان راه‌اندازی** | همیشه در حال اجرا | تأخیر Cold start |
| **کنترل** | کنترل بیشتر | کنترل کمتر |
| **Vendor Lock-in** | کمتر (containerها قابل انتقال) | بیشتر (خاص پلتفرم) |

**کی ترکیب کنیم:**
- پردازش رویداد: توابع Serverless
- منطق تجاری اصلی: Microservices
- کارهای زمان‌بندی‌شده: Serverless
- فرآیندهای طولانی: Microservices

## 14. چارچوب مصاحبه

### 14.1 رویکرد مصاحبه طراحی سیستم

هنگام طراحی یک سیستم microservices در مصاحبه:

**مرحله 1: روشن‌سازی نیازمندی‌ها**
- چه چیزی می‌سازیم؟
- مقیاس مورد انتظار (کاربران، درخواست‌ها، داده)؟
- ویژگی‌های کلیدی؟
- نیازمندی‌های عملکرد؟
- نیازمندی‌های در دسترس بودن؟

**مرحله 2: شناسایی سرویس‌ها**
- قابلیت‌های تجاری اصلی چیست؟
- Bounded contextها چیست؟
- ترسیم مرزهای سرویس
- شروع با 5-10 سرویس، نه 50

**مرحله 3: تعریف APIها**
- هر سرویس چه عملیاتی را expose می‌کند؟
- RESTful؟ gRPC؟ رویدادها؟
- فرمت‌های request/response

**مرحله 4: استراتژی داده**
- هر سرویس چه داده‌ای را مالک است؟
- کدام سرویس‌ها نیاز به اشتراک داده دارند؟
- چگونه سازگاری را مدیریت کنیم؟
- کدام انواع دیتابیس؟

**مرحله 5: الگوهای ارتباطی**
- همزمان در مقابل ناهمزمان؟
- چه رویدادهایی منتشر می‌شوند؟
- کدام message broker؟

**مرحله 6: نگرانی‌های Cross-Cutting**
- کلاینت‌ها چگونه سرویس‌ها را کشف می‌کنند؟
- احراز هویت و مجوز؟
- چگونه از شکست‌های آبشاری جلوگیری کنیم؟
- مانیتورینگ و observability؟

**مرحله 7: بحث مبادلات**
- چرا microservices به جای monolith؟
- انتخاب‌های سازگاری در مقابل در دسترس بودن
- پیچیدگی استقرار
- Overhead عملیاتی

### 14.2 سوالات رایج مصاحبه

**س: کی از microservices استفاده نمی‌کنید؟**
- تیم کوچک
- دامنه ساده
- MVP/prototype
- بلوغ محدود DevOps
- نیازمندی‌های coupling شدید

**س: تراکنش‌های توزیع‌شده را چگونه مدیریت می‌کنید؟**
- در صورت امکان اجتناب کنید
- الگوی Saga (choreography یا orchestration)
- سازگاری نهایی
- تراکنش‌های جبرانی

**س: چگونه از شکست‌های آبشاری جلوگیری می‌کنید؟**
- Circuit breakerها
- Timeoutها
- Bulkheadها
- محدودسازی نرخ
- تخریب تدریجی

**س: یک سیستم باید چند سرویس داشته باشد؟**
- عدد جادویی وجود ندارد
- بر اساس قابلیت‌های تجاری
- اندازه تیم (تیم‌های 2-pizza)
- کوچک شروع کنید، در صورت نیاز تقسیم کنید
- معمولاً 5-20 برای اکثر سیستم‌ها، نه 100+

**س: چگونه APIها را نسخه‌بندی می‌کنید؟**
- نسخه‌بندی URL (/v1/resource)
- نسخه‌بندی Header (Accept: application/vnd.api+json; version=1)
- سازگاری با گذشته ترجیح داده می‌شود
- استراتژی Deprecation

**س: چگونه microservicesها را تست می‌کنید؟**
- تست‌های unit در هر سرویس
- تست‌های Contract (مرزهای سرویس)
- تست‌های Integration (محدود)
- تست‌های End-to-end (فقط مسیرهای حیاتی)
- Chaos engineering

**س: دیتابیس در هر سرویس یا دیتابیس مشترک؟**
- دیتابیس در هر سرویس (ترجیح داده می‌شود)
- استقلال سرویس را امکان‌پذیر می‌کند
- دیتابیس مناسب برای کار
- چالش‌ها با سازگاری و کوئری‌ها
- دیتابیس مشترک فقط برای فاز مهاجرت legacy

## 15. نکات کلیدی

### مفاهیم اصلی

1. **Microservicesها سرویس‌های قابل استقرار مستقل هستند** که حول قابلیت‌های تجاری سازماندهی شده‌اند
2. **گلوله نقره‌ای نیست** - پیچیدگی عملیاتی بالا، چالش‌های سیستم توزیع‌شده
3. **دیتابیس در هر سرویس** - استقلال داده با چالش‌های سازگاری
4. **الگوهای ارتباطی مهم است** - همزمان در مقابل ناهمزمان، با عقل انتخاب کنید
5. **طراحی برای شکست** - circuit breakerها، timeoutها، retryها ضروری
6. **تأثیر سازمانی** - قانون Conway، ساختار تیم مهم است
7. **اتوماسیون مورد نیاز** - CI/CD، infrastructure as code، مانیتورینگ
8. **سازگاری نهایی** - الگوی Saga به جای تراکنش‌های توزیع‌شده
9. **شروع با modular monolith** - به microservices تکامل یابید وقتی توجیه شود
10. **مهاجرت تدریجی است** - الگوی strangler fig، anti-corruption layer

### الگوهای حیاتی

- **API Gateway** - نقطه ورودی واحد برای کلاینت‌ها
- **Service Discovery** - مکان سرویس پویا
- **Circuit Breaker** - جلوگیری از شکست‌های آبشاری
- **Saga Pattern** - مدیریت تراکنش توزیع‌شده
- **CQRS** - جداسازی مدل‌های خواندن/نوشتن
- **Event Sourcing** - رد audit و کوئری‌های زمانی
- **Strangler Fig** - استراتژی مهاجرت تدریجی

### عوامل موفقیت

**فنی:**
- فرهنگ قوی DevOps
- اتوماسیون در همه جا
- Observability از روز اول
- مرزهای واضح سرویس

**سازمانی:**
- تیم‌های مستقل
- قابلیت‌های cross-functional
- مالکیت واضح
- پروتکل‌های ارتباطی

**تجاری:**
- تعهد بلندمدت
- سرمایه‌گذاری در ابزار
- پذیرش هزینه اولیه بالاتر
- تمرکز بر مزایای خاص

### پرچم‌های قرمز برای اجتناب

- Microservices به خاطر microservices
- سرویس‌های زیادی خیلی زود
- دیتابیس مشترک بین سرویس‌ها
- Monolith توزیع‌شده (coupling شدید)
- فقدان اتوماسیون
- مانیتورینگ ناکافی
- زنجیره‌های همزمان سرویس‌ها
- عدم مالکیت واضح

### یادگیری بیشتر

**خواندن ضروری:**
- "Building Microservices" توسط Sam Newman
- "Designing Data-Intensive Applications" توسط Martin Kleppmann
- راهنمای منابع microservices Martin Fowler
- وبلاگ فنی Netflix
- وبلاگ معماری AWS

**مفاهیم مرتبط:**
- Domain-Driven Design (DDD)
- [CAP Theorem](../fundamentals/cap-theorem.fa.md)
- [Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md)
- Service Mesh (Istio، Linkerd)
- Container Orchestration (Kubernetes)
- Observability (Logging، Metrics، Tracing)

---

به یاد داشته باشید: Microservices مشکلات سازمانی و مقیاس‌پذیری را حل می‌کنند، اما پیچیدگی عملیاتی را معرفی می‌کنند. آن‌ها را انتخاب کنید وقتی مزایا بر هزینه‌ها غلبه کنند، نه به این دلیل که مد روز هستند.
