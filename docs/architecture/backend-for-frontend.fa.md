# الگوی Backend for Frontend (BFF)

## ۱. مقدمه

الگوی **Backend for Frontend (BFF)** یک الگوی معماری است که در آن یک سرویس بک‌اند اختصاصی برای هر نوع اپلیکیشن فرانت‌اند (وب، موبایل، شرکای تجاری) ایجاد می‌شود. به جای ارائه یک API عمومی و همه‌منظوره به تمام کلاینت‌ها، رویکرد BFF APIهای سفارشی‌شده‌ای ارائه می‌دهد که با نیازها و محدودیت‌های خاص هر نوع کلاینت مطابقت دارد.

این اصطلاح توسط **Sam Newman** در مقاله‌ای در سال ۲۰۱۵ ابداع شد و بعداً در کتابش *"Building Microservices"* بسط داده شد. این الگو از الگوی [API Gateway](./api-gateway.fa.md) تکامل یافت، زمانی که تیم‌ها متوجه شدند یک Gateway واحد که سعی می‌کند تمام انواع کلاینت‌ها را سرویس‌دهی کند، اغلب متورم، سخت در نگهداری و پر از مصالحه می‌شود.

**تعریف اصلی:**
> BFF یک کامپوننت سمت سرور است که به عنوان واسطه بین یک فرانت‌اند خاص و [میکروسرویس‌های](./microservices.fa.md) پایین‌دستی عمل می‌کند و قرارداد API را منحصراً برای نیازهای آن فرانت‌اند شکل‌دهی و بهینه‌سازی می‌کند.

**ویژگی‌های کلیدی:**

- **یک BFF به ازای هر نوع فرانت‌اند**: هر نوع کلاینت (وب، موبایل، تلویزیون هوشمند، API شریک تجاری) بک‌اند خودش را دارد
- **مالکیت تیم فرانت‌اند**: تیمی که فرانت‌اند را می‌سازد، BFF را نیز مالک و نگهداری می‌کند
- **شکل داده سفارشی**: هر BFF دقیقاً داده‌ای را که کلاینتش نیاز دارد، در فرمت بهینه برمی‌گرداند
- **تکامل مستقل**: فرانت‌اندها و BFFهایشان می‌توانند بدون تأثیر بر سایر کلاینت‌ها تکامل یابند
- **لایه نازک**: یک BFF باید منطق ارائه (presentation logic) داشته باشد، نه منطق کسب‌وکار

## ۲. زمینه و مسئله

در یک [معماری میکروسرویس](./microservices.fa.md)، کلاینت‌های فرانت‌اند مختلف نیازهای اساساً متفاوتی دارند:

### ۲.۱ مشکل یک‌اندازه‌برای‌همه

وقتی یک [API Gateway](./api-gateway.fa.md) واحد تمام انواع کلاینت‌ها را سرویس‌دهی می‌کند، ناگزیر مصالحه‌هایی ایجاد می‌شود:

```
┌──────────────────────────────────────────────────────────────────┐
│                  Single API Gateway (Fat Gateway)                │
│                                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Endpoints:                                               │  │
│  │                                                           │  │
│  │  GET /api/users/123                                       │  │
│  │  → Returns FULL user object (50 fields)                   │  │
│  │  → Web needs all 50 fields                                │  │
│  │  → Mobile only needs 8 fields (wastes bandwidth)          │  │
│  │  → TV app needs 5 different fields                        │  │
│  │                                                           │  │
│  │  GET /api/dashboard                                       │  │
│  │  → Returns everything for all dashboards                  │  │
│  │  → Web shows 6 widgets, needs rich data                   │  │
│  │  → Mobile shows 3 widgets, needs minimal data             │  │
│  │  → Too much data for mobile, not enough for web           │  │
│  └───────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
```

### ۲.۲ نیازهای خاص هر کلاینت

| نیاز | اپلیکیشن وب | اپلیکیشن موبایل | تلویزیون هوشمند | API شریک تجاری |
|------|-------------|-----------------|----------------|----------------|
| **پهنای باند** | بالا (باند پهن) | محدود (سلولار) | متوسط (Wi-Fi) | متغیر |
| **اندازه پیلود** | بزرگ قابل‌قبول | باید حداقلی باشد | متوسط | اسکیمای مستند |
| **شکل پاسخ** | تودرتو، غنی | تخت، فشرده | ساده‌شده | نسخه‌بندی‌شده |
| **روش احراز هویت** | Session/Cookie | JWT / OAuth | توکن دستگاه | API key + OAuth |
| **تحمل تأخیر** | ~200ms | ~100ms | ~300ms | تعریف‌شده در SLA |
| **ویژگی‌ها** | مجموعه کامل | زیرمجموعه، آفلاین‌اول | مدیا-محور | دامنه قراردادی |
| **فرمت تصویر** | وضوح بالا | تصاویر بندانگشتی | فرمت بزرگ | ندارد |

### ۲.۳ چه زمانی یک API Gateway واحد مشکل‌ساز می‌شود

```
                    Problem: Fat Gateway
                    =====================

┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│   Web    │  │  Mobile  │  │ Smart TV │  │ Partner  │
│  Client  │  │   App    │  │   App    │  │   API    │
└────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │             │
     └──────┬──────┴──────┬──────┴──────┬──────┘
            │             │             │
            ▼             ▼             ▼
┌──────────────────────────────────────────────────┐
│             Single API Gateway                   │
│                                                  │
│  Problems:                                       │
│  • Bloated with client-specific logic            │
│  • if (mobile) { ... } else if (web) { ... }    │
│  • Deployment bottleneck (all teams share it)    │
│  • One team's change can break another client    │
│  • Impossible to optimize for everyone           │
│  • Becomes a monolith itself                     │
│  • Slow release cycles (coordination overhead)   │
└──────────────────────────────────────────────────┘
```

**نشانه‌های یک Gateway چاق:**

1. **منطق شرطی به ازای هر نوع کلاینت** در سراسر کد Gateway پراکنده شده
2. **هماهنگی استقرار** بین چندین تیم فرانت‌اند برای یک Gateway واحد
3. **دریافت بیش از حد** برای کلاینت‌های موبایل و **دریافت کمتر از حد** برای کلاینت‌های وب
4. **تکرار کُند** زیرا هر تغییر در Gateway نیاز به تست رگرسیون کامل دارد
5. **گلوگاه تک‌تیمی** که یک Gateway را مالک است و تمام تیم‌های فرانت‌اند به آن وابسته‌اند

## ۳. نیروها

الگوی BFF چندین نیروی رقابتی را مورد توجه قرار می‌دهد:

- **فرانت‌اندهای مختلف به شکل‌های داده‌ای متفاوت نیاز دارند** -- یک اپلیکیشن موبایل به پیلودهای فشرده نیاز دارد در حالی که یک داشبورد وب به داده‌های غنی و تودرتو نیاز دارد
- **تیم‌های فرانت‌اند خودمختاری می‌خواهند** -- آن‌ها می‌خواهند بدون هماهنگی با تیم‌های دیگر، قرارداد API خود را تکرار کنند
- **تیم‌های بک‌اند ثبات می‌خواهند** -- آن‌ها نمی‌خواهند APIهای سرویس اصلی را برای هر نیاز فرانت‌اند تغییر دهند
- **محدودیت‌های پهنای باند متفاوت است** -- شبکه‌های سلولار پیلودهای کوچکتری نسبت به اتصالات باند پهن نیاز دارند
- **مکانیزم‌های احراز هویت متفاوت است** -- وب از کوکی‌ها، موبایل از توکن‌ها و شرکا از کلیدهای API استفاده می‌کنند
- **مجموعه ویژگی‌ها واگرا می‌شوند** -- هر فرانت‌اندی به هر ویژگی نیاز ندارد و تحمیل یک API فراگیر هدررفت ایجاد می‌کند
- **ریتم‌های انتشار متفاوت است** -- اپلیکیشن‌های موبایل هفتگی، وب روزانه و شرکا به APIهای نسخه‌بندی‌شده پایدار نیاز دارند

## ۴. راه‌حل

یک سرویس بک‌اند اختصاصی برای هر نوع فرانت‌اند ایجاد کنید. هر BFF بین فرانت‌اند خود و [میکروسرویس‌های](./microservices.fa.md) پایین‌دستی قرار می‌گیرد و به عنوان یک لایه ترجمه سفارشی عمل می‌کند.

### ۴.۱ معماری BFF

```
┌──────────────┐    ┌──────────────────────────────┐
│              │    │         Web BFF               │
│  Web Browser │───▶│  • Rich, nested responses     │
│              │    │  • Server-side rendering data  │
└──────────────┘    │  • Full feature set            │
                    └──────────────┬─────────────────┘
                                   │
┌──────────────┐    ┌──────────────┼─────────────────┐
│              │    │       Mobile BFF              │
│ Mobile App   │───▶│  • Compact payloads            │
│ (iOS/Android)│    │  • Aggregated responses        │
│              │    │  • Offline-friendly data        │
└──────────────┘    └──────────────┬─────────────────┘
                                   │
┌──────────────┐    ┌──────────────┼─────────────────┐
│              │    │      Partner BFF              │
│ 3rd Party    │───▶│  • Versioned, documented API   │
│ Integration  │    │  • Strict rate limiting         │
│              │    │  • SLA enforcement              │
└──────────────┘    └──────────────┬─────────────────┘
                                   │
                    ┌──────────────┴─────────────────┐
                    │                                │
                    ▼                                ▼
             ┌────────────┐                  ┌────────────┐
             │   User     │                  │   Order    │
             │  Service   │                  │  Service   │
             └────────────┘                  └────────────┘
                    ▲                                ▲
                    │                                │
             ┌────────────┐                  ┌────────────┐
             │  Product   │                  │  Payment   │
             │  Service   │                  │  Service   │
             └────────────┘                  └────────────┘
```

### ۴.۲ مقایسه API Gateway سنتی با رویکرد BFF

```
  Traditional: Single API Gateway          BFF: Dedicated Backends
  ================================         ==========================

  ┌─────┐ ┌─────┐ ┌─────┐                ┌─────┐ ┌─────┐ ┌─────┐
  │ Web │ │Mob. │ │ TV  │                │ Web │ │Mob. │ │ TV  │
  └──┬──┘ └──┬──┘ └──┬──┘                └──┬──┘ └──┬──┘ └──┬──┘
     │       │       │                      │       │       │
     └───┬───┴───┬───┘                      ▼       ▼       ▼
         │       │                     ┌────────┐┌────────┐┌────────┐
         ▼       ▼                     │Web BFF ││Mob BFF ││TV BFF  │
    ┌─────────────────┐                └───┬────┘└───┬────┘└───┬────┘
    │  Single Gateway │                    │         │         │
    │  (one-size-     │                    └────┬────┴────┬────┘
    │   fits-all)     │                         │         │
    └────────┬────────┘                         ▼         ▼
             │                            ┌──────────┐┌──────────┐
     ┌───────┼───────┐                    │ Service  ││ Service  │
     ▼       ▼       ▼                    │    A     ││    B     │
  ┌─────┐┌─────┐┌─────┐                  └──────────┘└──────────┘
  │Svc A││Svc B││Svc C│
  └─────┘└─────┘└─────┘

  مشکلات:                                 مزایا:
  • API مصالحه‌ای برای همه               • API بهینه‌شده برای هر کلاینت
  • چرخه‌های انتشار وابسته              • استقرار مستقل
  • گلوگاه تک‌تیمی                      • خودمختاری تیم
```

### ۴.۳ تفاوت‌های کلیدی BFF و API Gateway عمومی

| جنبه | API Gateway | BFF |
|------|-------------|-----|
| **دامنه** | تمام انواع کلاینت‌ها را سرویس‌دهی می‌کند | یک نوع کلاینت خاص را سرویس‌دهی می‌کند |
| **مالکیت** | تیم پلتفرم/زیرساخت | تیم فرانت‌اند |
| **منطق** | مسیریابی عمومی، احراز هویت، محدودیت نرخ | شکل‌دهی داده خاص کلاینت |
| **تعداد** | معمولاً یک (یا چند تا) | یک به ازای هر نوع فرانت‌اند |
| **منطق کسب‌وکار** | ندارد (فقط نگرانی‌های مشترک) | منطق ارائه، تجمیع |
| **جفت‌شدگی** | جفت‌شدگی سست با فرانت‌اندها | جفت‌شدگی محکم با یک فرانت‌اند |
| **تکامل** | تغییرات بر تمام کلاینت‌ها تأثیر می‌گذارد | تغییرات فقط بر یک کلاینت تأثیر می‌گذارد |
| **استقرار** | هماهنگ بین تیم‌ها | مستقل به ازای هر تیم |

> **نکته:** BFF و [API Gateway](./api-gateway.fa.md) متقابلاً انحصاری نیستند. بسیاری از معماری‌ها از یک API Gateway در جلوی چندین BFF استفاده می‌کنند، جایی که Gateway نگرانی‌های مشترک (SSL، محدودیت نرخ سراسری، اعتبارسنجی توکن احراز هویت) را مدیریت می‌کند و هر BFF منطق خاص کلاینت را مدیریت می‌کند.

### ۴.۴ معماری ترکیبی: API Gateway + BFFها

```
┌──────────┐  ┌──────────┐  ┌──────────┐
│   Web    │  │  Mobile  │  │ Partner  │
│  Client  │  │   App    │  │   API    │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     └──────┬──────┴──────┬──────┘
            │             │
            ▼             ▼
┌──────────────────────────────────────────┐
│         API Gateway (shared)             │
│  • SSL termination                       │
│  • Authentication token validation       │
│  • Global rate limiting                  │
│  • Logging & monitoring                  │
│  • Request routing to correct BFF        │
└────┬─────────────┬─────────────┬─────────┘
     │             │             │
     ▼             ▼             ▼
┌──────────┐ ┌──────────┐ ┌──────────┐
│ Web BFF  │ │Mobile BFF│ │Partner   │
│          │ │          │ │  BFF     │
└────┬─────┘ └────┬─────┘ └────┬─────┘
     │             │             │
     └──────┬──────┴──────┬──────┘
            │             │
     ┌──────┴──────┬──────┴──────┐
     ▼             ▼             ▼
┌──────────┐ ┌──────────┐ ┌──────────┐
│  User    │ │  Order   │ │ Product  │
│ Service  │ │ Service  │ │ Service  │
└──────────┘ └──────────┘ └──────────┘
```

## ۵. مثال

### ۵.۱ سناریو: صفحه محصول تجارت الکترونیک

کلاینت‌های مختلف به داده‌های متفاوتی از یک محصول نیاز دارند:

**Web BFF** -- داده‌های غنی محصول را برای تجربه صفحه کامل برمی‌گرداند:

```json
{
  "product": {
    "id": "P-1001",
    "title": "Wireless Headphones Pro",
    "description": "Premium noise-cancelling headphones with 40-hour battery...",
    "brand": "AudioTech",
    "price": {
      "amount": 249.99,
      "currency": "USD",
      "discount": { "percentage": 15, "validUntil": "2026-03-01" }
    },
    "images": [
      { "url": "/img/headphones-1-full.jpg", "width": 1200, "height": 1200 },
      { "url": "/img/headphones-2-full.jpg", "width": 1200, "height": 1200 },
      { "url": "/img/headphones-3-full.jpg", "width": 1200, "height": 1200 }
    ],
    "specifications": {
      "weight": "250g",
      "battery": "40 hours",
      "connectivity": "Bluetooth 5.3",
      "driver": "40mm"
    },
    "reviews": {
      "average": 4.7,
      "count": 1842,
      "distribution": { "5": 1200, "4": 400, "3": 150, "2": 60, "1": 32 },
      "featured": [ { "author": "Jane D.", "rating": 5, "text": "Best headphones I..." } ]
    },
    "relatedProducts": [ { "id": "P-1002", "title": "...", "price": 199.99 } ],
    "breadcrumbs": ["Electronics", "Audio", "Headphones", "Over-Ear"]
  }
}
```

**Mobile BFF** -- داده‌های فشرده بهینه‌شده برای پهنای باند و اندازه صفحه را برمی‌گرداند:

```json
{
  "id": "P-1001",
  "title": "Wireless Headphones Pro",
  "price": 249.99,
  "discountedPrice": 212.49,
  "thumbnail": "/img/headphones-1-thumb.jpg",
  "rating": 4.7,
  "reviewCount": 1842,
  "inStock": true
}
```

**Partner BFF** -- داده‌های مستند و نسخه‌بندی‌شده طبق قرارداد API برمی‌گرداند:

```json
{
  "data": {
    "type": "product",
    "id": "P-1001",
    "attributes": {
      "name": "Wireless Headphones Pro",
      "sku": "AT-WHP-001",
      "price_cents": 24999,
      "currency": "USD",
      "availability": "in_stock",
      "category_id": "CAT-AUDIO-003"
    }
  },
  "meta": { "api_version": "2.1", "request_id": "req-abc-123" }
}
```

### ۵.۲ نحوه تجمیع داده‌ها توسط BFF

```
Mobile BFF: GET /products/P-1001
                │
                ├──────────────────────────────────────┐
                │  1. Fetch product basics             │
                │     GET product-service/P-1001       │
                │                                      │
                │  2. Fetch price (with discount)       │
                │     GET pricing-service/P-1001       │
                │                                      │
                │  3. Fetch stock status               │
                │     GET inventory-service/P-1001     │
                │                                      │
                │  4. Fetch review summary (not full)   │
                │     GET review-service/P-1001/summary│
                └──────────────────────────────────────┘
                │
                ▼
        ┌───────────────────────────────┐
        │  Mobile BFF combines and      │
        │  transforms:                  │
        │  • Select only needed fields  │
        │  • Calculate discounted price │
        │  • Use thumbnail URL          │
        │  • Flatten nested structures  │
        │  • Add offline cache headers  │
        └───────────────────────────────┘
                │
                ▼
         Compact JSON response
         (< 500 bytes vs 5KB from web)
```

## ۶. مزایا و معایب

### ۶.۱ مزایا

| مزیت | توضیح |
|------|-------|
| **API بهینه‌شده برای هر کلاینت** | هر فرانت‌اند دقیقاً داده‌ای که نیاز دارد در شکلی که انتظار دارد دریافت می‌کند |
| **تکامل مستقل** | Mobile BFF می‌تواند بدون تأثیر بر وب یا APIهای شریک تغییر کند |
| **کاهش دریافت بیش از حد** | کلاینت‌های موبایل دیگر داده‌هایی که هرگز نمایش نمی‌دهند دانلود نمی‌کنند |
| **مالکیت تیم فرانت‌اند** | تیمی که فرانت‌اند را بهتر می‌شناسد، قرارداد API آن را کنترل می‌کند |
| **کد فرانت‌اند ساده‌تر** | فرانت‌اندها داده‌های از‌پیش‌شکل‌دهی‌شده دریافت می‌کنند به جای تبدیل پاسخ‌های عمومی |
| **استقرار مستقل** | هر BFF طبق زمان‌بندی خودش استقرار می‌یابد بدون هماهنگی بین‌تیمی |
| **مدیریت خطای بهتر** | هر BFF می‌تواند خطاها را در فرمتی که کلاینتش می‌فهمد برگرداند |
| **تنظیم عملکرد** | هر BFF می‌تواند به طور مستقل برای الگوی ترافیکش مقیاس‌پذیر و بهینه شود |

### ۶.۲ معایب

| عیب | توضیح | کاهش‌دهنده |
|-----|-------|------------|
| **تکرار کد** | منطق مشابه (احراز هویت، اعتبارسنجی، دریافت داده) در چندین BFF ظاهر می‌شود | کتابخانه‌های مشترک، SDKهای داخلی |
| **سرویس‌های بیشتر برای نگهداری** | هر BFF یک سرویس دیگر برای استقرار، نظارت و نگهداری است | اتوماسیون، قالب‌ها، پشتیبانی تیم پلتفرم |
| **سربار استقرار** | خطوط CI/CD بیشتر، زیرساخت بیشتر | ارکستراسیون کانتینر (Kubernetes)، IaC |
| **چالش‌های سازگاری** | BFFهای مختلف ممکن است داده‌های ناسازگار برای یک موجودیت برگردانند | مدل‌های دامنه مشترک، تست قرارداد |
| **افزایش تأخیر** | هاپ اضافی بین کلاینت و میکروسرویس‌ها | BFFها را نزدیک سرویس‌ها نگه دارید (همان کلاستر) |
| **هماهنگی تیم** | وقتی سرویس‌های پایین‌دستی تغییر می‌کنند، ممکن است تمام BFFها نیاز به به‌روزرسانی داشته باشند | نسخه‌بندی API، سازگاری عقب‌گرد، تست‌های قرارداد |
| **پیچیدگی عملیاتی** | سرویس‌های بیشتر یعنی نظارت، هشدار و دیباگ بیشتر | مشاهده‌پذیری متمرکز (ردیابی توزیع‌شده) |

### ۶.۳ چه زمانی از BFF استفاده کنیم

**از BFF استفاده کنید وقتی:**

- **چندین نوع کلاینت** با نیازهای اساساً متفاوت دارید (وب، موبایل، تلویزیون، شریک تجاری)
- تیم‌های فرانت‌اند **خودمختاری کامل** بر قرارداد API خود می‌خواهند
- یک [API Gateway](./api-gateway.fa.md) واحد به **گلوگاه استقرار** تبدیل شده
- کلاینت‌های موبایل از **دریافت بیش از حد** در یک API همه‌منظوره رنج می‌برند
- به **استراتژی‌های احراز هویت متفاوت** برای هر نوع کلاینت نیاز دارید

**از BFF اجتناب کنید وقتی:**

- فقط **یک فرانت‌اند** دارید (فقط از API Gateway استفاده کنید)
- تمام کلاینت‌ها به **داده‌های یکسان** نیاز دارند (تمایزی لازم نیست)
- تیم شما **کوچک** است و توانایی نگهداری چندین بک‌اند را ندارد
- سیستم یک **اپلیکیشن CRUD ساده** بدون تجمیع داده پیچیده است

## ۷. الگوهای مرتبط

### ۷.۱ API Gateway

[API Gateway](./api-gateway.fa.md) الگوی والدی است که BFF از آن تکامل یافته. در حالی که یک API Gateway یک نقطه ورود واحد برای تمام کلاینت‌ها با نگرانی‌های مشترک ارائه می‌دهد، BFF این ایده را به بک‌اندهای خاص هر کلاینت تخصصی می‌کند. در عمل، این دو الگو اغلب ترکیب می‌شوند: یک API Gateway مشترک SSL، محدودیت نرخ سراسری و احراز هویت را مدیریت می‌کند، در حالی که BFFهای پشت آن منطق خاص کلاینت را مدیریت می‌کنند.

### ۷.۲ معماری Microservices

BFF به دلیل [میکروسرویس‌ها](./microservices.fa.md) وجود دارد. وقتی یک سیستم توزیع‌شده با سرویس‌های زیاد دارید، کلاینت‌ها به راهی نیاز دارند تا بدون سروکار داشتن با پیچیدگی ارتباطات بین‌سرویسی به آن‌ها دسترسی پیدا کنند. BFF به عنوان لایه تجمیع و ترجمه بین فرانت‌اند و اکوسیستم میکروسرویس عمل می‌کند.

### ۷.۳ GraphQL به عنوان BFF

GraphQL می‌تواند به عنوان جایگزین یا مکمل BFF عمل کند. با GraphQL، کلاینت‌ها دقیقاً اعلام می‌کنند به چه داده‌ای نیاز دارند و سرور آن را حل می‌کند. این دریافت بیش از حد را بدون نیاز به BFFهای جداگانه کاهش می‌دهد. با این حال، GraphQL پیچیدگی‌های خاص خود را دارد (تحلیل هزینه پرس‌وجو، مشکلات N+1، چالش‌های کش) و ممکن است همچنان از اسکیماهای GraphQL خاص هر کلاینت بهره‌مند شود.

### ۷.۴ الگوی Aggregator

الگوی Aggregator ارتباط نزدیکی با BFF دارد. در حالی که BFF خاص نوع کلاینت است، الگوی Aggregator بر ترکیب داده‌ها از چندین سرویس در یک پاسخ واحد تمرکز دارد. هر BFF معمولاً الگوی Aggregator را به صورت داخلی پیاده‌سازی می‌کند.

### ۷.۵ Circuit Breaker

هر BFF باید الگوی [Circuit Breaker](../resilience/circuit-breaker.fa.md) را هنگام فراخوانی [میکروسرویس‌های](./microservices.fa.md) پایین‌دستی پیاده‌سازی کند. اگر یک سرویس از کار بیفتد، BFF می‌تواند داده‌های کش‌شده، مقادیر پیش‌فرض یا تخریب ملایم را به جای شکست کامل برگرداند.

## ۸. استفاده در دنیای واقعی

### ۸.۱ Netflix

Netflix مثال متعارف BFF است. آن‌ها تجربه‌های اساساً متفاوتی در هر دستگاه ارائه می‌دهند:

```
┌────────────────────────────────────────────────────────┐
│                   Netflix BFF Architecture              │
│                                                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐│
│  │   Web    │  │   iOS    │  │ Android  │  │ Smart  ││
│  │ Browser  │  │   App    │  │   App    │  │   TV   ││
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └───┬────┘│
│       │             │             │             │     │
│       ▼             ▼             ▼             ▼     │
│  ┌──────────────────────────────────────────────────┐│
│  │        Zuul (Edge Gateway)                       ││
│  │  • Auth, rate limiting, routing                  ││
│  └──────┬──────────┬──────────┬──────────┬──────────┘│
│         │          │          │          │           │
│         ▼          ▼          ▼          ▼           │
│    ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐     │
│    │Web BFF │ │iOS BFF │ │Android │ │TV BFF  │     │
│    │(Node)  │ │(Falcor)│ │  BFF   │ │        │     │
│    └───┬────┘ └───┬────┘ └───┬────┘ └───┬────┘     │
│        │          │          │          │           │
│        └──────────┴──────────┴──────────┘           │
│                        │                             │
│                        ▼                             │
│  ┌──────────────────────────────────────────────┐   │
│  │         Backend Microservices                │   │
│  │  Catalog | Recommendations | User | Billing  │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
│  چرا: تلویزیون 10 عنوان در هر ردیف نمایش می‌دهد،  │
│  موبایل 3 تا، وب متغیر. اندازه تصاویر، حجم داده‌ها │
│  و الگوهای تعامل در هر دستگاه متفاوت است.           │
└────────────────────────────────────────────────────────┘
```

**تصمیمات کلیدی:**
- هر تیم دستگاه مالک BFF خود است
- BFFها از کتابخانه Falcor نتفلیکس برای دریافت کارآمد داده استفاده می‌کنند
- TV BFF دستورالعمل‌های چیدمان UI از‌پیش‌محاسبه‌شده برمی‌گرداند
- Mobile BFF به شکل تهاجمی کش می‌کند و اندازه پیلود را به حداقل می‌رساند

### ۸.۲ SoundCloud

SoundCloud الگوی BFF را زمانی پذیرفت که API واحدشان دیگر نمی‌توانست تعداد رو به رشد پلتفرم‌های کلاینت را سرویس‌دهی کند:

- **Web BFF**: داده‌های غنی برای تجربه مرورگر برمی‌گرداند (شکل‌موج‌ها، نظرات، لیست‌های پخش)
- **Mobile BFF**: داده‌های فشرده با URLهای جریان صوتی از‌پیش‌دریافت‌شده برمی‌گرداند
- **Embedded Player BFF**: داده‌های حداقلی برای ویجت قابل تعبیه برمی‌گرداند
- هر BFF توسط تیمی که آن کلاینت را می‌سازد مدیریت می‌شود

### ۸.۳ Spotify

Spotify از رویکرد BFF مبتنی بر GraphQL استفاده می‌کند:

```
┌──────────────────────────────────────────────┐
│          Spotify Architecture                │
│                                              │
│  Mobile App ──▶ Mobile BFF (GraphQL)         │
│  Web Player ──▶ Web BFF (GraphQL)            │
│  Desktop   ──▶ Desktop BFF (GraphQL)         │
│                                              │
│  Each BFF exposes a GraphQL schema           │
│  tailored to that client's UI needs.         │
│                                              │
│  GraphQL resolvers call:                     │
│    • Track Service                           │
│    • Playlist Service                        │
│    • User Service                            │
│    • Recommendation Engine                   │
│    • Social Service                          │
│                                              │
│  Benefits:                                   │
│  • Clients request exactly what they need    │
│  • Schema per client avoids over-fetching    │
│  • Type safety between frontend and BFF      │
└──────────────────────────────────────────────┘
```

### ۸.۴ رویکردهای پیاده‌سازی

| رویکرد | توضیح | بهترین برای |
|--------|-------|-------------|
| **REST BFF** | هر BFF نقاط پایانی RESTful سفارشی برای کلاینتش ارائه می‌دهد | APIهای ساده، تیم‌های آشنا با REST |
| **GraphQL BFF** | هر BFF یک اسکیمای GraphQL برای کلاینتش ارائه می‌دهد | رابط‌های کاربری پیچیده نیازمند پرس‌وجوهای انعطاف‌پذیر |
| **gRPC BFF** | هر BFF با سرویس‌ها از طریق gRPC ارتباط برقرار می‌کند، REST/GraphQL به کلاینت ارائه می‌دهد | عملکرد بالا، سرویس‌به‌سرویس داخلی |
| **Hybrid BFF** | REST برای نقاط پایانی ساده، GraphQL برای نیازهای داده پیچیده | نیازهای مختلط |

### ۸.۵ احراز هویت و مجوز در لایه BFF

```
┌──────────────────────────────────────────────────────┐
│             Authentication Flow per BFF              │
│                                                      │
│  Web Client                                          │
│  ┌────────┐    Cookie/Session     ┌──────────┐      │
│  │Browser │ ──────────────────▶  │ Web BFF  │      │
│  └────────┘                       │ Validates │      │
│                                   │ session   │      │
│  Mobile Client                    └──────────┘      │
│  ┌────────┐    Bearer JWT Token   ┌──────────┐      │
│  │  App   │ ──────────────────▶  │Mobile BFF│      │
│  └────────┘                       │ Validates │      │
│                                   │ JWT       │      │
│  Partner Client                   └──────────┘      │
│  ┌────────┐    API Key + OAuth    ┌──────────┐      │
│  │Partner │ ──────────────────▶  │Partner   │      │
│  └────────┘                       │  BFF     │      │
│                                   │ Validates │      │
│                                   │ key+scope │      │
│                                   └──────────┘      │
│                                                      │
│  هر BFF روش احراز هویت مناسب نوع کلاینتش           │
│  را اعمال می‌کند و یک زمینه احراز هویت داخلی       │
│  یکپارچه به سرویس‌های پایین‌دستی ارسال می‌کند.     │
└──────────────────────────────────────────────────────┘
```

### ۸.۶ مدل مالکیت BFF

```
┌──────────────────────────────────────────────────────┐
│                  Team Ownership                      │
│                                                      │
│  ┌──────────────────────────────────────────┐       │
│  │  Web Team                                │       │
│  │  Owns: React Frontend + Web BFF          │       │
│  │  Deploys: Independently, daily           │       │
│  │  Stack: TypeScript / Node.js             │       │
│  └──────────────────────────────────────────┘       │
│                                                      │
│  ┌──────────────────────────────────────────┐       │
│  │  Mobile Team                             │       │
│  │  Owns: iOS/Android Apps + Mobile BFF     │       │
│  │  Deploys: BFF independently, app weekly  │       │
│  │  Stack: Kotlin / Spring Boot             │       │
│  └──────────────────────────────────────────┘       │
│                                                      │
│  ┌──────────────────────────────────────────┐       │
│  │  Partner Team                            │       │
│  │  Owns: Partner Portal + Partner BFF      │       │
│  │  Deploys: Versioned releases, monthly    │       │
│  │  Stack: Go                               │       │
│  └──────────────────────────────────────────┘       │
│                                                      │
│  اصل کلیدی: تیمی که فرانت‌اند را می‌سازد           │
│  همچنین BFF را می‌سازد، استقرار می‌دهد و            │
│  عملیات آن را مدیریت می‌کند.                         │
│  این سربار هماهنگی بین‌تیمی را حذف می‌کند.          │
└──────────────────────────────────────────────────────┘
```

## ۹. خلاصه

الگوی Backend for Frontend (BFF) یک مشکل اساسی در [معماری‌های میکروسرویس](./microservices.fa.md) را حل می‌کند: کلاینت‌های مختلف به APIهای متفاوت نیاز دارند. به جای مجبور کردن تمام کلاینت‌ها به استفاده از یک [API Gateway](./api-gateway.fa.md) واحد و مصالحه‌ای، BFF سرویس‌های بک‌اند اختصاصی برای هر نوع فرانت‌اند ایجاد می‌کند.

**نکات کلیدی:**

1. **یک BFF به ازای هر نوع فرانت‌اند** -- کلاینت‌های وب، موبایل، تلویزیون و شریک تجاری هر کدام بک‌اند سفارشی خود را دارند
2. **مالکیت تیم فرانت‌اند** -- تیمی که فرانت‌اند را می‌سازد BFF آن را نیز مالک است و خودمختاری کامل دارد
3. **جایگزین API Gateway نیست** -- BFF و API Gateway مکمل یکدیگرند؛ Gateway نگرانی‌های مشترک را مدیریت می‌کند در حالی که BFF منطق خاص کلاینت را مدیریت می‌کند
4. **مصالحه: بهینه‌سازی در مقابل تکرار** -- APIهای بهینه‌شده به قیمت نگهداری چندین سرویس بک‌اند به دست می‌آید
5. **از عمل تکامل یافته** -- Netflix، SoundCloud و Spotify همه BFF را برای حل مشکلات واقعی با APIهای یک‌اندازه‌برای‌همه پذیرفتند
6. **BFFها را نازک نگه دارید** -- BFFها باید منطق ارائه و تجمیع داشته باشند، نه منطق کسب‌وکار. منطق کسب‌وکار متعلق به [میکروسرویس‌های](./microservices.fa.md) پایین‌دستی است
7. **کاهش تکرار** -- از کتابخانه‌های مشترک، SDKهای داخلی و تست قرارداد برای کاهش تکرار کد بین BFFها استفاده کنید
8. **GraphQL را در نظر بگیرید** -- GraphQL گاهی می‌تواند جایگزین یا نیاز به BFFهای جداگانه را کاهش دهد با اجازه دادن به کلاینت‌ها برای اعلام نیازهای داده‌ای‌شان

**چارچوب تصمیم‌گیری:**

| سؤال | اگر بله | اگر نه |
|------|---------|--------|
| آیا چندین نوع فرانت‌اند دارید؟ | BFF را در نظر بگیرید | از API Gateway واحد استفاده کنید |
| آیا کلاینت‌ها به شکل‌های داده‌ای خیلی متفاوت نیاز دارند؟ | BFF گزینه مناسبی است | یک API مشترک کافی است |
| آیا API Gateway شما به گلوگاه تبدیل شده؟ | BFF فشار را کاهش می‌دهد | تنظیمات فعلی را حفظ کنید |
| آیا تیمتان می‌تواند چندین سرویس بک‌اند را نگهداری کند؟ | با BFF ادامه دهید | با یک Gateway واحد شروع کنید |
| آیا تیم‌های فرانت‌اند خودمختاری API می‌خواهند؟ | BFF این را فراهم می‌کند | Gateway متمرکز کار می‌کند |

---

**موضوعات مرتبط:**

- [الگوی API Gateway](./api-gateway.fa.md) -- الگوی والدی که BFF از آن تکامل یافته
- [معماری Microservices](./microservices.fa.md) -- سبک معماری که BFF بیشترین ارتباط را با آن دارد
- [الگوی Circuit Breaker](../resilience/circuit-breaker.fa.md) -- الگوی تاب‌آوری ضروری برای فراخوانی‌های BFF به سرویس
- [CQRS](../data-patterns/cqrs.fa.md) -- الگوی مکمل برای بهینه‌سازی خواندن/نوشتن
- [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) -- BFFها می‌توانند رویدادها را برای به‌روزرسانی‌های بلادرنگ مصرف کنند

**منابع:**

- "Building Microservices" by Sam Newman (فصل الگوی BFF)
- پست وبلاگ Sam Newman: "Backends for Frontends" (2015)
- وبلاگ فنی Netflix: لایه‌های API خاص دستگاه
- وبلاگ فنی SoundCloud: پذیرش BFF
- Phil Calcado: "Pattern: Backends for Frontends"
- "System Design Interview" by Alex Xu
