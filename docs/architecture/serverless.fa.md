# معماری Serverless

## 1. مقدمه

**معماری Serverless** یک مدل اجرایی رایانش ابری است که در آن ارائه‌دهنده ابر به صورت پویا تخصیص و مدیریت سرورها را برعهده می‌گیرد. با وجود نامش، Serverless به معنای عدم وجود سرور نیست. بلکه به این معناست که توسعه‌دهندگان نیازی به فکر کردن درباره سرورها، مدیریت، مقیاس‌پذیری یا نگهداری آن‌ها ندارند.

اصطلاح "Serverless" تا حدودی گمراه‌کننده است چون:
- سرورها همچنان وجود دارند و کد شما را اجرا می‌کنند
- شخصی (ارائه‌دهنده ابر) همچنان زیرساخت را مدیریت می‌کند
- تفاوت در این است که شما نیازی به مدیریت یا تامین آن‌ها ندارید

Serverless دو جنبه اصلی را شامل می‌شود:

1. **Backend as a Service (BaaS)** - سرویس‌های شخص ثالثی که اجزای سمت سرور را جایگزین می‌کنند
2. **Function as a Service (FaaS)** - اجرای محاسباتی رویداد محور و موقت

### وعده Serverless

ارزش پیشنهادی اساسی Serverless:
- **بدون مدیریت سرور** - تمرکز خالص بر منطق کسب‌وکار
- **مقیاس‌پذیری خودکار** - از صفر تا میلیون‌ها درخواست
- **پرداخت به ازای اجرا** - فقط هنگام اجرای کد هزینه پرداخت کنید
- **قابلیت دسترسی بالای داخلی** - ارائه‌دهنده افزونگی را مدیریت می‌کند

## 2. Backend as a Service (BaaS)

**BaaS** به سرویس‌های شخص ثالثی اشاره دارد که قابلیت‌های Backend را فراهم می‌کنند و نیاز به نوشتن و نگهداری کد سمت سرور برای ویژگی‌های متداول را حذف می‌کنند.

### سرویس‌های BaaS متداول

```
معماری سنتی:
┌─────────────┐
│   کلاینت   │
└──────┬──────┘
       │
┌──────▼──────────────────────────┐
│   سرور Backend شما              │
│  ┌────────────────────────────┐ │
│  │ منطق احراز هویت            │ │
│  │ کوئری‌های پایگاه داده       │ │
│  │ مدیریت ذخیره‌سازی فایل     │ │
│  │ اعلان‌های Push              │ │
│  │ سرویس ایمیل                │ │
│  └────────────────────────────┘ │
└─────────────────────────────────┘

معماری BaaS:
┌─────────────┐
│   کلاینت   │
└──────┬──────┘
       │
       ├────────────┬────────────┬────────────┬────────────┐
       │            │            │            │            │
   ┌───▼───┐   ┌───▼───┐   ┌───▼───┐   ┌───▼───┐   ┌───▼───┐
   │ Auth0 │   │Firebase│   │  S3   │   │  SNS  │   │SendGrid│
   │(Auth) │   │ (DB)   │   │(Files)│   │(Push) │   │(Email)│
   └───────┘   └────────┘   └───────┘   └───────┘   └────────┘
```

### نمونه‌هایی از سرویس‌های BaaS

| دسته‌بندی | نمونه سرویس‌ها | هدف |
|----------|-----------------|---------|
| احراز هویت | Auth0, AWS Cognito, Firebase Auth | مدیریت کاربر، SSO، OAuth |
| پایگاه داده | Firebase Firestore, AWS DynamoDB, Supabase | پایگاه داده NoSQL/SQL با API |
| ذخیره‌سازی فایل | AWS S3, Google Cloud Storage, Cloudinary | ذخیره‌سازی Object و CDN |
| پیام‌رسانی | SendGrid, Twilio, AWS SNS | ایمیل، SMS، اعلان Push |
| جستجو | Algolia, Elasticsearch Service | جستجوی متن کامل |
| تحلیل | Google Analytics, Mixpanel | ردیابی رفتار کاربر |

### مزایا و معایب BaaS

**مزایا:**
- توسعه سریع - قابلیت‌های از پیش ساخته شده
- بار نگهداری کاهش یافته
- پیاده‌سازی‌های اثبات شده و امن
- اغلب شامل سطح رایگان

**معایب:**
- قفل شدن در ارائه‌دهنده (vendor lock-in)
- سفارشی‌سازی کمتر
- هزینه احتمالی در مقیاس
- نگرانی‌های محل اقامت داده

## 3. Function as a Service (FaaS)

**FaaS** بخش محاسباتی Serverless است که در آن توابع فردی را deploy می‌کنید که در پاسخ به رویدادها اجرا می‌شوند. ارائه‌دهنده ابر همه چیز را مدیریت می‌کند: سرورها، کانتینرها، مقیاس‌پذیری و چرخه حیات.

### ویژگی‌های کلیدی FaaS

1. **اجرای رویداد محور** - توابع در پاسخ به محرک‌ها اجرا می‌شوند
2. **موقت (Ephemeral)** - نمونه‌ها کوتاه‌مدت هستند
3. **بدون حالت (Stateless)** - هر فراخوانی مستقل است
4. **مقیاس‌پذیری خودکار** - به صورت خودکار با تقاضا مقیاس می‌یابد
5. **پرداخت به ازای اجرا** - بر اساس هر فراخوانی و زمان محاسبات صورتحساب می‌شود

### ارائه‌دهندگان اصلی FaaS

```
┌─────────────────────────────────────────────────────────┐
│                    چشم‌انداز ارائه‌دهندگان FaaS         │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ AWS Lambda   │  │Azure Functions│ │Google Cloud  │  │
│  │              │  │              │  │  Functions   │  │
│  │ - راه‌اندازی │  │ - C#, Java   │  │              │  │
│  │   2014       │  │ - تمرکز .NET │  │ - یکپارچگی   │  │
│  │ - پیشرو      │  │ - Durable    │  │   GCP        │  │
│  │   بازار      │  │   Functions  │  │ - بهبود      │  │
│  │ - حداکثر      │  │ - حداکثر      │  │   نسل 2     │  │
│  │   15 دقیقه   │  │   10 دقیقه   │  │ - حداکثر      │  │
│  └──────────────┘  └──────────────┘  │   60 دقیقه   │  │
│                                       └──────────────┘  │
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Cloudflare   │  │ Vercel Edge  │  │ Netlify      │  │
│  │ Workers      │  │ Functions    │  │ Functions    │  │
│  │              │  │              │  │              │  │
│  │ - محاسبات    │  │ - بهینه‌سازی │  │ - wrapper    │  │
│  │   Edge       │  │   Next.js    │  │   AWS Lambda │  │
│  │ - ایزوله‌های │  │ - زمان اجرا  │  │ - Deploy از  │  │
│  │   V8         │  │   Edge       │  │   Git        │  │
│  │ - بدون Cold  │  │ - TypeScript │  │              │  │
│  │   start      │  │              │  │              │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### زبان‌های پشتیبانی شده

بیشتر پلتفرم‌های FaaS از زبان‌های متعددی پشتیبانی می‌کنند:
- Node.js (JavaScript/TypeScript)
- Python
- Java
- Go
- C# (.NET)
- Ruby
- Runtime‌های سفارشی (کانتینرهای Docker)

## 4. نحوه کار FaaS

بیایید چرخه حیات اجرای یک تابع را بررسی کنیم:

```
چرخه حیات تابع:

1. رویداد رخ می‌دهد              2. پلتفرم رویداد را دریافت می‌کند
   ┌─────────────┐                   ┌──────────────────┐
   │ درخواست HTTP│                   │   AWS Lambda     │
   │ آپلود فایل  │──────Event───────▶│   API Gateway    │
   │ تغییر DB    │                   │   EventBridge    │
   │ زمان‌بندی   │                   └────────┬─────────┘
   └─────────────┘                            │
                                               │
3. بررسی برای نمونه Warm                       │
   ┌───────────────────────────────────────────▼──┐
   │ آیا کانتینر Warm در دسترس است?             │
   │  بله ─────────────────────────┐              │
   │  خیر (COLD START) ─┐           │              │
   └───────────────────┼───────────┼──────────────┘
                       │           │
   4a. Cold Start      │           │  4b. استفاده از نمونه Warm
   ┌──────────────────▼┐          │   ┌──────────────────┐
   │ - دانلود کد      │          │   │ - اجرای فوری     │
   │ - شروع Runtime   │          │   │ - استفاده مجدد   │
   │ - مقداردهی اولیه│          │   │   از state       │
   │ - بارگذاری deps │          │   └────────┬─────────┘
   │ (100ms-5s)        │          │            │
   └──────────┬────────┘          │            │
              │                   │            │
              └───────────────────┴────────────┘
                                  │
5. اجرای تابع                      │
   ┌───────────────────────────────▼──────────┐
   │  function handler(event, context) {      │
   │    // منطق کسب‌وکار شما اینجا           │
   │    const result = processEvent(event);   │
   │    return result;                        │
   │  }                                       │
   └───────────────────┬──────────────────────┘
                       │
6. بازگشت پاسخ         │
   ┌───────────────────▼──────────────────────┐
   │  موفقیت: بازگشت داده به فراخوان‌کننده  │
   │  خطا: بازگشت خطا، فعال‌سازی تلاش مجدد   │
   └───────────────────┬──────────────────────┘
                       │
7. تصمیم کانتینر       │
   ┌───────────────────▼──────────────────────┐
   │  نگه داشتن warm برای ~5-15 دقیقه        │
   │  پس از timeout بلاتکلیفی → Scale to zero│
   └──────────────────────────────────────────┘
```

### جزئیات جریان اجرا

**فرآیند Cold Start:**
1. ارائه‌دهنده یک micro-VM یا کانتینر فراهم می‌کند
2. کد تابع شما را دانلود می‌کند
3. Runtime زبان را شروع می‌کند (Node.js، Python و غیره)
4. کد مقداردهی اولیه را اجرا می‌کند (imports، اتصالات)
5. سرانجام تابع handler شما را اجرا می‌کند

**اجرای Warm:**
1. از کانتینر موجود استفاده مجدد می‌کند
2. مستقیماً به اجرای handler می‌پرد
3. بسیار سریع‌تر (چند میلی‌ثانیه)

**Scale to Zero:**
- پس از دوره بلاتکلیفی (متفاوت بر اساس ارائه‌دهنده)
- کانتینر خاتمه می‌یابد
- در زمان بلاتکلیفی هزینه‌ای وجود ندارد
- فراخوانی بعدی باعث Cold Start می‌شود

## 5. مقایسه Serverless با سرور سنتی و کانتینرها

درک تفاوت‌ها به انتخاب رویکرد مناسب کمک می‌کند:

| جنبه | سرور سنتی | کانتینرها ([Microservices](microservices.fa.md)) | Serverless (FaaS) |
|--------|-------------------|------------------------|------------------|
| **مدیریت زیرساخت** | کنترل کامل، راه‌اندازی دستی | Orchestration کانتینر (Kubernetes) | کاملاً توسط ارائه‌دهنده مدیریت می‌شود |
| **مقیاس‌پذیری** | دستی یا گروه‌های auto-scaling | Horizontal pod autoscaling | خودکار، فوری |
| **مدل هزینه** | پرداخت برای ظرفیت رزرو شده | پرداخت برای کانتینرهای در حال اجرا | پرداخت به ازای اجرا |
| **هزینه بلاتکلیفی** | هزینه کامل حتی در حالت بلاتکلیفی | هزینه برای حداقل replicaها | هزینه صفر هنگام بلاتکلیفی |
| **Cold Start** | هیچ | حداقل (اگر به صفر برسد) | 100ms - 5s |
| **محدودیت زمان اجرا** | نامحدود | نامحدود | 15 دقیقه (AWS)، متفاوت بر اساس ارائه‌دهنده |
| **مدیریت State** | می‌تواند state را نگه دارد | می‌تواند state را نگه دارد | طراحی بدون state |
| **استقرار** | دستی یا CI/CD | تصاویر کانتینر، manifestهای K8s | آپلود کد تابع |
| **نظارت** | راه‌اندازی سفارشی | Prometheus، Grafana | CloudWatch داخلی و غیره |
| **مناسب برای** | برنامه‌های طولانی‌مدت، stateful | Microserviceها، برنامه‌های پیچیده | بارهای کاری رویداد محور، پرتغییر |
| **منحنی یادگیری** | بالا | بسیار بالا | کم تا متوسط |
| **قفل شدن در ارائه‌دهنده** | کم (self-hosted) | متوسط | بالا |

### نمونه مقایسه هزینه

برای سرویسی که 1 میلیون درخواست/ماه را مدیریت می‌کند، با میانگین 200 میلی‌ثانیه اجرا و 512MB حافظه:

```
سرور سنتی (t3.medium):
- $30/ماه (24/7 در حال اجرا)
- بار متغیر را مدیریت می‌کند
- هزینه: $30/ماه ثابت

کانتینر (ECS/Fargate):
- 2 task، 0.5 vCPU، هر کدام 1GB
- $0.04048/ساعت به ازای هر task
- هزینه: ~$60/ماه

Serverless (Lambda):
- 1M درخواست × $0.20 به ازای 1M = $0.20
- 1M × 0.2s × 512MB محاسبه = $1.67
- مجموع: ~$1.87/ماه

اما در 100 میلیون درخواست/ماه:
- سنتی: $30 (همان)
- کانتینر: $60-120 (افزایش مقیاس)
- Serverless: $187 (به صورت خطی مقیاس می‌یابد)
```

**نتیجه‌گیری:** Serverless برای بارهای کاری پراکنده یا کم‌حجم بسیار مقرون به صرفه است، اما هزینه‌ها می‌توانند در حجم‌های بالا و ثابت از سرورهای سنتی بیشتر شوند.

## 6. الگوهای معماری Serverless

### الگوی 1: Backend API ساده

رایج‌ترین الگو - استفاده از FaaS با [API Gateway](api-gateway.fa.md) برای ساخت APIهای RESTful.

```
Backend API ساده:

┌──────────────┐
│  کلاینت‌ها   │
│  (وب/موبایل) │
└──────┬───────┘
       │ HTTPS
       │
┌──────▼────────────────────────────────────────────┐
│             API Gateway                            │
│  - احراز هویت                                      │
│  - محدودسازی نرخ                                   │
│  - اعتبارسنجی درخواست                              │
│  - CORS                                            │
└───────┬────────────────────────────────────────────┘
        │
        │ مسیریابی درخواست‌ها به توابع
        │
        ├─────────────┬─────────────┬─────────────┐
        │             │             │             │
   ┌────▼────┐   ┌───▼────┐   ┌────▼────┐   ┌───▼────┐
   │ Lambda  │   │ Lambda │   │ Lambda  │   │ Lambda │
   │ GET     │   │ POST   │   │ PUT     │   │ DELETE │
   │ /users  │   │ /users │   │ /users  │   │ /users │
   └────┬────┘   └───┬────┘   └────┬────┘   └───┬────┘
        │            │             │            │
        └────────────┴─────────────┴────────────┘
                     │
            ┌────────▼─────────┐
            │   DynamoDB       │
            │  (NoSQL DB)      │
            │  - جدول Users    │
            └──────────────────┘
```

**مورد استفاده:** ساخت یک CRUD API برای یک برنامه موبایل
**مزایا:** پرداخت فقط برای فراخوانی‌های واقعی API، مقیاس‌پذیری خودکار
**معاوضه:** Cold startها در اولین درخواست پس از دوره بلاتکلیفی

### الگوی 2: خط لوله پردازش رویداد

پردازش فایل‌ها یا داده‌ها به محض ورود، بدون نگهداری سرور.

```
خط لوله پردازش رویداد:

┌─────────────────┐
│  منبع داده      │
│   (S3 Bucket)   │
└────────┬────────┘
         │ رویداد ایجاد Object
         │
    ┌────▼────────────────────────────────┐
    │   اعلان رویداد (S3 Event)           │
    └────┬────────────────────────────────┘
         │
    ┌────▼─────────┐
    │   Lambda 1   │
    │  اعتبارسنج   │
    │  - بررسی فایل│
    │  - اعتبارسنجی│
    └────┬─────────┘
         │
         ├──────────┬──────────┐
         │          │          │
    ┌────▼─────┐ ┌─▼────────┐ ┌▼──────────┐
    │ Lambda 2 │ │ Lambda 3 │ │ Lambda 4  │
    │ پردازش  │ │ تبدیل    │ │ ذخیره     │
    │ تصویر   │ │ داده     │ │ نتایج    │
    └──────────┘ └──────────┘ └───────────┘
                                    │
                            ┌───────▼────────┐
                            │  RDS/DynamoDB  │
                            │  ذخیره نتایج  │
                            └────────────────┘
```

**مورد استفاده:** سرویس پردازش تصویر که عکس‌های آپلود شده را تغییر اندازه می‌دهد
**مزایا:** کاملاً رویداد محور، بدون polling، پردازش موازی
**نمونه:** Coca-Cola از Lambda برای پردازش داده‌های دستگاه فروش استفاده می‌کند

### الگوی 3: وظایف زمان‌بندی شده (Cron Jobs)

اجرای وظایف دوره‌ای بدون نگهداری سرور.

```
وظایف زمان‌بندی شده:

┌──────────────────────────────────────────┐
│      CloudWatch Events / EventBridge     │
│                                          │
│  Rule: cron(0 2 * * ? *)  [روزانه 2 صبح]│
└───────────────┬──────────────────────────┘
                │
                │ Trigger بر اساس زمان‌بندی
                │
        ┌───────▼────────┐
        │  Lambda        │
        │  تولیدکننده   │
        │  گزارش روزانه  │
        └───────┬────────┘
                │
        ┌───────▼────────────────────────┐
        │  1. کوئری پایگاه داده          │
        │  2. تولید گزارش                │
        │  3. ارسال ایمیل از طریق SES    │
        │  4. بایگانی در S3              │
        └────────────────────────────────┘
```

**مورد استفاده:** پشتیبان‌گیری شبانه پایگاه داده، تولید گزارش روزانه
**مزایا:** بدون سرور در حال اجرای 24/7 برای وظایف دوره‌ای
**جایگزین:** Step Functions برای گردش کارهای پیچیده

### الگوی 4: پردازش Stream

پردازش جریان‌های داده در زمان واقعی با مفاهیم مشابه [Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md).

```
پردازش Stream:

┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   موبایل    │     │     IoT     │     │  وب‌اپ‌ها   │
│   اپلیکیشن  │     │   دستگاه‌ها │     │             │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │
       │ رویدادها          │ داده سنسور        │ کلیک‌ها
       │                   │                   │
       └───────────────────┴───────────────────┘
                           │
                  ┌────────▼──────────┐
                  │  Kinesis Stream   │
                  │  یا Kafka Topic   │
                  │  (بافر شده)      │
                  └────────┬──────────┘
                           │
          ┌────────────────┼────────────────┐
          │                │                │
     ┌────▼─────┐    ┌────▼─────┐    ┌────▼─────┐
     │ Lambda 1 │    │ Lambda 2 │    │ Lambda 3 │
     │ تجمیع    │    │ غنی‌سازی │    │ فیلتر    │
     │ Metricها │    │ داده     │    │ ناهنجاری│
     └────┬─────┘    └────┬─────┘    └────┬─────┘
          │               │               │
          ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │ElasticSearch  │ DynamoDB │    │   SNS    │
    │ (تحلیل)  │    │(ذخیره)  │    │ (هشدار)  │
    └──────────┘    └──────────┘    └──────────┘
```

**مورد استفاده:** پردازش داده‌های سنسور IoT، تحلیل جریان کلیک
**مزایا:** مقیاس خودکار به throughput جریان، پردازش موازی
**یکپارچگی:** با [RabbitMQ vs Kafka](../messaging/rabbitmq-vs-kafka.fa.md) برای پیام‌رسانی کار می‌کند

### الگوی 5: پردازش Fan-out

توزیع یک رویداد به چندین پردازشگر downstream.

```
پردازش Fan-out:

┌──────────────┐
│  API Gateway │
│  POST /order │
└──────┬───────┘
       │
  ┌────▼────┐
  │ Lambda  │
  │ دریافت‌  │
  │  سفارش  │
  └────┬────┘
       │ انتشار به SNS
       │
  ┌────▼──────────┐
  │   SNS Topic   │
  │  OrderCreated │
  └────┬──────────┘
       │
       ├───────────┬───────────┬───────────┐
       │           │           │           │
  ┌────▼────┐ ┌───▼────┐ ┌────▼────┐ ┌───▼─────┐
  │ Lambda  │ │ Lambda │ │ Lambda  │ │ Lambda  │
  │ پردازش │ │به‌روزرسانی│اعلان  │ │تحلیل    │
  │ پرداخت │ │موجودی  │ ایمیل  │ │         │
  └─────────┘ └────────┘ └─────────┘ └─────────┘
```

**مورد استفاده:** پردازش سفارش تجارت الکترونیک با عوارض جانبی متعدد
**مزایا:** جدا شده، اجرای موازی، آسان برای افزودن مشترکین جدید
**الگو:** مشابه مدیریت دستور [CQRS](../data-patterns/cqrs.fa.md)

## 7. مشکل Cold Start

**Cold Start** مهم‌ترین چالش با FaaS است. این تاخیری است که هنگام فراخوانی یک تابع پس از بلاتکلیفی معرفی می‌شود.

### درک Cold Startها

```
جدول زمانی Cold Start:

بدون Cold Start (Warm):
درخواست ─────▶ اجرای کد ─────▶ پاسخ
               (5-10ms)

با Cold Start:
                سربار Cold Start
درخواست ─────▶ ┌──────────────────────────┐ ─────▶ اجرای ─────▶ پاسخ
               │ 1. فراهم کردن کانتینر   │        کد
               │ 2. دانلود کد            │        (5-10ms)
               │ 3. شروع Runtime          │
               │ 4. مقداردهی/importsها   │
               │ (100ms - 5 ثانیه)       │
               └──────────────────────────┘

تاخیر کل: Cold Start + زمان اجرا
```

### عوامل تأثیرگذار بر مدت Cold Start

| عامل | تأثیر بر Cold Start | نمونه |
|--------|---------------------|---------|
| **Runtime زبان** | بالا | Java: 1-5s، Python: 200-500ms، Node: 100-300ms، Go: 50-200ms |
| **اندازه بسته** | متوسط | استقرارهای بزرگ‌تر زمان بیشتری برای دانلود می‌برند |
| **تخصیص حافظه** | متوسط | حافظه بیشتر = CPU سریع‌تر = مقداردهی سریع‌تر |
| **پیکربندی VPC** | بالا | توابع فعال VPC 10+ ثانیه اضافه می‌کنند (اکنون با Hyperplane ENIs بهبود یافته) |
| **وابستگی‌ها** | بالا | Importهای بیشتر = مقداردهی طولانی‌تر |
| **ارائه‌دهنده** | متوسط | AWS در مقابل Azure در مقابل GCP سربارهای متفاوتی دارند |

### استراتژی‌های کاهش Cold Start

**1. Provisioned Concurrency (AWS Lambda)**
```
Lambda سنتی:
┌─────────────────────────────────────────┐
│ درخواست می‌رسد → Cold start → اجرا     │
└─────────────────────────────────────────┘

با Provisioned Concurrency:
┌─────────────────────────────────────────┐
│ نمونه‌ها همیشه warm و آماده هستند      │
│ درخواست می‌رسد → اجرای فوری            │
│ (شما برای ظرفیت provisioned پرداخت می‌کنید) │
└─────────────────────────────────────────┘
```

**معاوضه هزینه:** حتی هنگام بلاتکلیفی برای نمونه‌های provisioned پرداخت کنید، مشابه سرورهای سنتی.

**2. استراتژی Keep-Warm**
```
┌──────────────────────┐
│  رویداد CloudWatch   │
│  (هر 5 دقیقه)        │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│  Ping Lambda         │
│  (فراخوانی ساختگی)  │
│  آن را Warm نگه می‌دارد│
└──────────────────────┘
```

**نقص:** همچنان هزینه‌های فراخوانی را متحمل می‌شود، واقعاً "Serverless" نیست.

**3. بهینه‌سازی تابع**
- کمینه کردن اندازه بسته
- کاهش وابستگی‌ها (tree-shaking، bundling)
- جابجایی مقداردهی به خارج از handler
- استفاده از زبان‌های کامپایل شده (Go، Rust)

**4. پردازش Async**
- برای توابع غیرکاربری، Cold Start مهم نیست
- استفاده از SQS، SNS برای فراخوانی async
- کاربر منتظر Cold Start نمی‌ماند

**5. توابع Edge**
- Cloudflare Workers از ایزوله‌های V8 استفاده می‌کند (بدون Cold Start)
- Vercel Edge Functions رویکرد مشابه
- معاوضه: محیط Runtime محدودتر

## 8. مدیریت State در Serverless

توابع FaaS به صورت **بدون state** طراحی شده‌اند - هر فراخوانی مستقل است. با این حال، برنامه‌های واقعی به state نیاز دارند.

### چالش بدون State

```
مشکل: نگهداری State در میان فراخوانی‌ها

┌──────────┐      ┌──────────┐      ┌──────────┐
│ درخواست 1│      │ درخواست 2│      │ درخواست 3│
└─────┬────┘      └─────┬────┘      └─────┬────┘
      │                 │                 │
      ▼                 ▼                 ▼
┌──────────┐      ┌──────────┐      ┌──────────┐
│ Lambda   │      │ Lambda   │      │ Lambda   │
│ نمونه    │      │ نمونه    │      │ نمونه    │
│    A     │      │    B     │      │    C     │
└──────────┘      └──────────┘      └──────────┘
     ❌ نمی‌توان متغیرها را بین نمونه‌ها به اشتراک گذاشت
```

### راه‌حل‌های مدیریت State

**1. ذخیره‌گاه‌های State خارجی**
```
┌──────────────────────────────────────────────┐
│             تابع Lambda                       │
│                                              │
│  handler(event):                             │
│    // خواندن state از ذخیره‌گاه خارجی      │
│    state = await dynamoDB.get(key)          │
│                                              │
│    // پردازش                                │
│    newState = process(state, event)         │
│                                              │
│    // نوشتن state به عقب                    │
│    await dynamoDB.put(key, newState)        │
└──────────────────────────────────────────────┘
         │                          ▲
         │                          │
         ▼                          │
┌────────────────────────────────────────────┐
│        ذخیره‌گاه State خارجی               │
│  - DynamoDB (key-value، سریع)              │
│  - ElastiCache Redis (in-memory، سریع‌ترین)│
│  - S3 (Objectهای بزرگ)                     │
│  - RDS (داده رابطه‌ای)                     │
└────────────────────────────────────────────┘
```

**انتخاب ذخیره‌گاه State:**

| مورد استفاده | ذخیره‌گاه توصیه شده | تاخیر |
|----------|------------------|---------|
| داده‌های جلسه، شمارنده‌ها | DynamoDB، Redis | 1-10ms |
| فایل‌های بزرگ، اسناد | S3 | 50-200ms |
| کوئری‌های رابطه‌ای | Aurora Serverless | 10-50ms |
| State جهانی، قفل کردن | Redis، Memcached | <1ms |

**2. استفاده مجدد کانتینر برای State موقت**
```javascript
// حوزه جهانی - بین فراخوانی‌ها باقی می‌ماند اگر کانتینر Warm باشد
let cachedData = null;
let cacheExpiry = 0;

exports.handler = async (event) => {
  // بررسی کنید آیا کش هنوز معتبر است
  if (cachedData && Date.now() < cacheExpiry) {
    console.log('استفاده از داده‌های کش شده');
    return cachedData;
  }

  // Cache miss - دریافت از DB
  cachedData = await database.query();
  cacheExpiry = Date.now() + 60000; // 1 دقیقه

  return cachedData;
};
```

**هشدار:** این بهینه‌سازی فقط برای warm startها کار می‌کند و نباید برای صحت به آن تکیه شود.

**3. Step Functions برای State گردش کار**

برای گردش کارهای چند مرحله‌ای، AWS Step Functions گردش کارهای Serverless را با مدیریت state داخلی ارکستر می‌کند:

```
گردش کار Step Functions:

شروع
  │
  ▼
┌─────────────────┐
│ Lambda:         │
│ ValidateOrder   │
└────────┬────────┘
         │
    ┌────▼────┐
    │  قبول؟  │
    └────┬────┘
         │
    بله──┴──خیر──────────────┐
    │                       │
    ▼                       ▼
┌─────────────────┐   ┌──────────────┐
│ Lambda:         │   │ Lambda:      │
│ ProcessPayment  │   │ SendError    │
└────────┬────────┘   └──────────────┘
         │
         ▼
┌─────────────────┐
│ Lambda:         │
│ UpdateInventory │
└────────┬────────┘
         │
         ▼
       پایان
```

Step Functions state گردش کار، منطق تلاش مجدد و مدیریت خطا را حفظ می‌کند. هر Lambda بدون state باقی می‌ماند.

**4. Event Sourcing**
ذخیره state به عنوان توالی رویدادها به جای state فعلی:
- اضافه کردن رویدادها به جریان (Kinesis، EventBridge)
- بازسازی state با پخش مجدد رویدادها
- مطابقت طبیعی برای Serverless
- مرتبط با [Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md)

## 9. قفل شدن در ارائه‌دهنده و قابلیت حمل

بزرگترین نگرانی استراتژیک با Serverless، **قفل شدن در ارائه‌دهنده** است. برنامه شما به شدت به سرویس‌های اختصاصی ارائه‌دهنده ابر متصل می‌شود.

### منابع قفل شدن

```
لایه‌های قفل شدن:

┌─────────────────────────────────────────────┐
│ کد برنامه (قابل حمل)                        │
│  - منطق کسب‌وکار                            │
│  - الگوریتم‌ها                              │
└─────────────────────────────────────────────┘
         │ می‌تواند جابجا شود
         ▼
┌─────────────────────────────────────────────┐
│ APIهای خاص ارائه‌دهنده (قفل شده)           │
│  - فراخوانی‌های AWS SDK                     │
│  - فرمت‌های رویداد خاص Lambda               │
│  - APIهای DynamoDB                          │
└─────────────────────────────────────────────┘
         │ سخت برای تغییر
         ▼
┌─────────────────────────────────────────────┐
│ زیرساخت ارائه‌دهنده (قفل شده)             │
│  - Runtime Lambda                           │
│  - API Gateway                              │
│  - CloudWatch                               │
│  - IAM                                      │
└─────────────────────────────────────────────┘
```

### پیچیدگی چندابری

```
تابع AWS Lambda:
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

exports.handler = async (event) => {
  await dynamodb.put({
    TableName: 'Users',
    Item: event.body
  }).promise();
};

معادل تابع Azure:
const { CosmosClient } = require('@azure/cosmos');
const client = new CosmosClient(process.env.COSMOS_CONNECTION);

module.exports = async function (context, req) {
  const { resource } = await client
    .database('db')
    .container('Users')
    .items.create(req.body);
};

معادل تابع Google Cloud:
const { Firestore } = require('@google-cloud/firestore');
const firestore = new Firestore();

exports.handler = async (req, res) => {
  await firestore.collection('Users').add(req.body);
  res.status(200).send('OK');
};
```

هر ارائه‌دهنده APIها، مدل‌های استقرار، فرمت‌های رویداد و قابلیت‌های متفاوتی دارد.

### استراتژی‌های کاهش

**1. لایه انتزاع**
```javascript
// رابط پایگاه داده انتزاعی
class DatabaseService {
  async saveUser(user) {
    // پیاده‌سازی بر اساس ارائه‌دهنده تزریق شده
  }
}

// پیاده‌سازی AWS
class DynamoDBService extends DatabaseService {
  async saveUser(user) {
    return dynamodb.put({ /* خاص AWS */ });
  }
}

// پیاده‌سازی Azure
class CosmosDBService extends DatabaseService {
  async saveUser(user) {
    return cosmosClient.create({ /* خاص Azure */ });
  }
}

// تابع از انتزاع استفاده می‌کند
exports.handler = async (event) => {
  const db = createDatabaseService(); // Factory
  await db.saveUser(event.body);
};
```

**2. Serverless Framework**

[Serverless Framework](https://www.serverless.com/) پیکربندی مستقل از ارائه‌دهنده را فراهم می‌کند:

```yaml
# serverless.yml
service: user-service

provider:
  name: aws    # می‌تواند به azure، google و غیره تغییر کند
  runtime: nodejs18.x

functions:
  createUser:
    handler: handler.createUser
    events:
      - http:
          path: users
          method: post

resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      # منابع خاص ارائه‌دهنده هنوز اینجا هستند
```

**مزایا:**
- استقرار ساده شده
- اکوسیستم افزونه
- پشتیبانی از توسعه محلی

**محدودیت‌ها:**
- هنوز به ویژگی‌های خاص ارائه‌دهنده متصل است
- رویکرد کمترین مخرج مشترک

**3. توابع کانتینری شده**

استفاده از کانتینرها (AWS Lambda Container Images، Google Cloud Run) قابلیت حمل بیشتری فراهم می‌کند:

```
تصویر Docker → می‌تواند به اینجا deploy شود:
  - AWS Lambda
  - Google Cloud Run
  - Azure Container Instances
  - Kubernetes (Knative)
  - سرورهای خودتان
```

**4. پذیرش قفل شدن**

برای بسیاری از سازمان‌ها، رویکرد عملی این است:
- **پذیرش** قفل شدن در ارائه‌دهنده به عنوان یک معاوضه
- تمرکز بر ارزش کسب‌وکار، نه قابلیت حمل
- برآورد هزینه تغییر در مقابل مزیت به دست آمده
- استفاده از Serverless برای بارهای کاری مناسب

**چارچوب تصمیم:**
```
آیا باید نگران قفل شدن باشم؟

نگرانی بالا اگر:
  - سیستم چند ساله، حیاتی
  - الزامات نظارتی برای قابلیت حمل
  - نیاز به اهرم مذاکره با ارائه‌دهنده

نگرانی پایین اگر:
  - استارتاپ سریع‌الحرکت (سرعت > قابلیت حمل)
  - ابزارهای داخلی با عمر کوتاه
  - ویژگی‌های خاص ارائه‌دهنده برای موفقیت حیاتی
```

## 10. معاوضه‌ها: مزایا و معایب

### مزایای Serverless

**1. بدون مدیریت سرور**
- بدون وصله OS، به‌روزرسانی‌های امنیتی یا نگهداری
- ارائه‌دهنده زیرساخت را مدیریت می‌کند
- تمرکز خالص بر منطق کسب‌وکار

**2. مقیاس‌پذیری خودکار**
- از صفر تا هزاران اجرای همزمان مقیاس می‌یابد
- نیازی به برنامه‌ریزی ظرفیت نیست
- به صورت خودکار اوج ترافیک را مدیریت می‌کند

**3. مدل هزینه پرداخت به ازای اجرا**
```
مقایسه هزینه: API کم‌ترافیک (10,000 درخواست/روز)

سرور سنتی:
  - EC2 t3.small: $15/ماه
  - 24/7 در حال اجرا حتی با 99% زمان بلاتکلیفی
  - مجموع: $15/ماه

Serverless:
  - 10,000 درخواست × $0.20/1M = $0.002
  - 10,000 × 100ms × 128MB = $0.02
  - مجموع: $0.022/ماه (700 برابر ارزان‌تر!)
```

**4. کاهش زمان ورود به بازار**
- بدون راه‌اندازی زیرساخت
- سرویس‌های یکپارچه (احراز هویت، ذخیره‌سازی و غیره)
- تکرار و استقرار سریع

**5. قابلیت دسترسی بالای داخلی**
- Multi-AZ به صورت پیش‌فرض
- Failover خودکار
- بدون نقاط تک شکست

**6. بار عملیاتی آسان‌تر**
- ارائه‌دهنده ظرفیت، وصله‌گذاری، نظارت بر زیرساخت را مدیریت می‌کند
- ثبت وقایع داخلی (CloudWatch و غیره)
- امنیت یکپارچه (IAM، VPC و غیره)

### معایب Serverless

**1. تاخیر Cold Start**
- 100 میلی‌ثانیه تا 5+ ثانیه برای فراخوانی اولیه
- تجربه کاربری غیرقابل پیش‌بینی
- کاهش‌دهنده‌ها (provisioned concurrency) هزینه را افزایش می‌دهند

**2. محدودیت‌های زمان اجرا**
```
محدودیت‌های ارائه‌دهنده:

AWS Lambda:        حداکثر 15 دقیقه
Azure Functions:   10 دقیقه (مصرف)، 30 دقیقه (premium)
Google Cloud:      60 دقیقه (نسل 2)
Cloudflare Workers: 30 ثانیه

❌ مناسب نیست برای:
  - کارهای Batch طولانی‌مدت
  - رمزگذاری ویدیو (مگر اینکه تکه تکه شود)
  - پردازش داده‌های بزرگ
  - اتصالات WebSocket > محدودیت
```

**3. قفل شدن در ارائه‌دهنده**
- APIها و سرویس‌های اختصاصی
- مهاجرت دشوار و پرهزینه
- قدرت مذاکره محدود

**4. چالش‌های اشکال‌زدایی و قابلیت مشاهده**
- ماهیت توزیع شده و موقت اشکال‌زدایی را سخت می‌کند
- تجربه توسعه محلی محدود
- نیاز به ثبت وقایع ساختاریافته و ردیابی توزیع شده
- مرتبط با چالش‌ها در الگوهای [Circuit Breaker](../resilience/circuit-breaker.fa.md)

**5. کنترل محدود**
- نمی‌توان زیرساخت را بهینه کرد
- ارائه‌دهنده سخت‌افزار، شبکه و غیره را تعیین می‌کند
- سفارشی‌سازی Runtime محدود

**6. هزینه در مقیاس بالا**
```
نمونه تقاطع هزینه:

سرویس: 100 میلیون درخواست/ماه، میانگین 500 میلی‌ثانیه، 512MB

Serverless:
  - 100M × $0.20/1M = $20
  - 100M × 0.5s × 512MB = $834
  - مجموع: $854/ماه

سرور اختصاصی (c5.xlarge):
  - 4 vCPU، 8GB RAM
  - می‌تواند بار را مدیریت کند
  - $122/ماه

در حجم بالا و ثابت، اختصاصی ارزان‌تر است!
```

**7. پیچیدگی مدیریت State**
- طراحی بدون state مورد نیاز
- ذخیره‌گاه‌های State خارجی تاخیر اضافه می‌کنند
- Orchestration گردش کار برای جریان‌های پیچیده مورد نیاز است

**8. چالش‌های تست**
- سخت برای تکرار محیط ارائه‌دهنده به صورت محلی
- تست‌های یکپارچگی نیاز به منابع واقعی ابری دارند
- Mock کردن سرویس‌های ارائه‌دهنده پیچیده است

### جدول خلاصه معاوضه‌ها

| عامل | مزیت Serverless | مزیت سنتی |
|--------|---------------------|----------------------|
| **سربار عملیاتی** | ✅ حداقل | ❌ بالا |
| **هزینه اولیه** | ✅ بسیار کم | ❌ پیش‌پرداخت بالا |
| **هزینه در مقیاس بالا** | ❌ می‌تواند گران باشد | ✅ قابل پیش‌بینی‌تر |
| **تاخیر Cold Start** | ❌ 100ms-5s | ✅ هیچ |
| **زمان اجرا** | ❌ محدود (15 دقیقه) | ✅ نامحدود |
| **قفل شدن در ارائه‌دهنده** | ❌ بالا | ✅ کم/متوسط |
| **سرعت مقیاس‌پذیری** | ✅ فوری | ⚠️ دقیقه‌ها |
| **مدیریت State** | ❌ پیچیده | ✅ ساده |
| **سرعت توسعه** | ✅ سریع (سرویس‌های یکپارچه) | ⚠️ کندتر |
| **کنترل/سفارشی‌سازی** | ❌ محدود | ✅ کنترل کامل |

## 11. چه زمانی از Serverless استفاده کنیم / چه زمانی اجتناب کنیم

### چه زمانی از Serverless استفاده کنیم

**✅ موارد استفاده ایده‌آل:**

**1. بارهای کاری پراکنده و غیرقابل پیش‌بینی**
```
الگوی ترافیک:
درخواست‌ها
   │
   │    ████
   │    ████         ██
   │  ████████      ████
   │  ████████  ██  ████      ████
   │  ████████  ██  ████  ██  ████
   └────────────────────────────────▶ زمان

Serverless برتری دارد: به هر اوج مقیاس می‌یابد، هزینه صفر در بلاتکلیفی
```

**2. پردازش رویداد محور**
- آپلودهای فایل که پردازش را فعال می‌کنند
- ورود داده‌های IoT
- Webhookها از سرویس‌های شخص ثالث
- پردازش صف پیام

**3. وظایف زمان‌بندی شده**
- گزارش‌های روزانه
- کارهای پاکسازی دوره‌ای
- پشتیبان‌گیری پایگاه داده
- پردازش Batch (تکه‌های < 15 دقیقه)

**4. نمونه‌سازی سریع و MVPها**
- زمان سریع ورود به بازار
- تعویق نگرانی‌های مقیاس‌پذیری
- تمرکز بر ویژگی‌ها

**5. Backend برای برنامه‌های موبایل/وب**
- نقاط پایانی API با [API Gateway](api-gateway.fa.md)
- احراز هویت از طریق BaaS (Auth0، Cognito)
- عملیات CRUD ساده

**6. خطوط لوله تبدیل داده**
- گردش کارهای ETL
- پردازش تصویر/ویدیو (تکه شده)
- پردازش Log

**7. Microserviceها با بار متغیر**
- APIهای داخلی با استفاده پراکنده
- داشبوردهای مدیر
- سرویس‌های گزارش‌دهی

### چه زمانی از Serverless اجتناب کنیم

**❌ موارد استفاده نامناسب:**

**1. فرآیندهای طولانی‌مدت**
```
زمان اجرا:
  0s ──────────────────── 15min ──────────────▶ ساعت‌ها

  │←──── Lambda مناسب ──→│❌ محدودیت Lambda فراتر رفته

نمونه‌ها:
  - رمزگذاری ویدیو (فیلم کامل)
  - مهاجرت‌های داده بزرگ
  - آموزش مدل ML
  - شبیه‌سازی‌های پیچیده
```

**راه‌حل:** استفاده از ECS، Batch یا سرورهای سنتی.

**2. ترافیک بالا و ثابت**
```
الگوی ترافیک:
درخواست‌ها
   │  ████████████████████████████████████
   │  ████████████████████████████████████
   │  ████████████████████████████████████
   │  ████████████████████████████████████
   └────────────────────────────────────────▶ زمان

سرور سنتی در بار بالای ثابت مقرون به صرفه‌تر است
```

**3. برنامه‌های حساس به تاخیر**
- مناقصه در زمان واقعی (نیاز به پاسخ <10ms)
- معاملات با فرکانس بالا
- بازی (الزامات تاخیر پایین)
- پخش ویدیوی زنده

Cold Startها Serverless را نامناسب می‌کنند.

**4. برنامه‌های Stateful**
- سرورهای WebSocket که اتصالات را حفظ می‌کنند
- سرورهای بازی با state جلسه
- برنامه‌هایی که نیاز به جلسات چسبنده دارند
- کش حافظه که برای عملکرد حیاتی است

**5. وابستگی‌های بزرگ یا کد Monolithic**
- بسته‌های استقرار > 250MB
- کتابخانه‌های مشترک در میان توابع زیاد
- Monolithهای موجود (نیاز به بازآرایی)

**6. تراکنش‌های پیچیده**
- تراکنش‌های چند مرحله‌ای که نیاز به ضمانت‌های ACID دارند
- عملیاتی که چندین پایگاه داده را شامل می‌شود
- گردش کارهایی که نیاز به قفل توزیع شده دارند

**7. محدودیت‌های نظارتی یا انطباق**
- الزامات محل اقامت داده که ارائه‌دهنده نمی‌تواند برآورده کند
- نیاز به کنترل کامل زیرساخت
- محیط‌های جدا شده از هوا

### چارچوب تصمیم

```
درخت تصمیم Serverless:

شروع: آیا به برنامه نیاز دارید?
  │
  ├─▶ آیا بار کاری رویداد محور یا پراکنده است?
  │     بله ─▶ ✅ مناسب برای Serverless
  │     خیر ──┐
  │          │
  └──────────┤
             ▼
       آیا زمان اجرا < 15 دقیقه است?
             │
             ├─▶ خیر ──▶ ❌ استفاده از کانتینر/سرور
             │
             ▼ بله
       آیا تحمل تاخیر > 1 ثانیه است?
             │
             ├─▶ خیر (نیاز <100ms) ──▶ ❌ استفاده provisioned یا سنتی
             │
             ▼ بله
       آیا هزینه در مقیاس قابل قبول است?
             │
             ├─▶ محاسبه: Serverless در مقابل اختصاصی
             │
             ▼
       آیا قفل شدن در ارائه‌دهنده قابل قبول است?
             │
             ├─▶ خیر ──▶ ⚠️ استفاده از انتزاع یا کانتینر
             │
             ▼ بله
       ✅ Serverless انتخاب خوبی است
```

## 12. نمونه‌های دنیای واقعی

### نمونه 1: دستگاه‌های فروش Coca-Cola

**چالش:**
- میلیون‌ها دستگاه فروش در سراسر جهان که داده‌های تله‌متری ارسال می‌کنند
- الگوهای ترافیک پراکنده و غیرقابل پیش‌بینی
- نیاز به پردازش پرداخت، موجودی و داده‌های تشخیصی

**راه‌حل Serverless:**
```
معماری دستگاه فروش:

┌──────────────────┐
│  دستگاه فروش     │
│  (دستگاه IoT)    │
└────────┬─────────┘
         │ IoT Core (MQTT)
         │
    ┌────▼──────────┐
    │  AWS IoT Core │
    └────┬──────────┘
         │ فعال‌سازها
         │
    ┌────▼───────────┐
    │ Lambda          │
    │ Parse telemetry│
    └────┬───────────┘
         │
    ┌────▼──────────────────┬────────────┐
    │                       │            │
┌───▼────┐         ┌────────▼──┐   ┌────▼──────┐
│ Lambda │         │  Lambda   │   │  Lambda   │
│موجودی  │         │  پرداخت   │   │تشخیص      │
└───┬────┘         └────┬──────┘   └────┬──────┘
    │                   │               │
    ▼                   ▼               ▼
┌──────────┐      ┌──────────┐    ┌──────────┐
│ DynamoDB │      │   RDS    │    │CloudWatch│
└──────────┘      └──────────┘    └──────────┘
```

**نتایج:**
- **صرفه‌جویی در هزینه:** ~$13,000/ماه در مقابل جایگزین EC2
- **مقیاس‌پذیری:** میلیون‌ها درخواست را در زمان‌های اوج مدیریت می‌کند
- **بدون نگهداری:** بدون مدیریت سرور

**مرجع:** [مطالعه موردی AWS](https://aws.amazon.com/solutions/case-studies/coca-cola-freestyle/)

### نمونه 2: iRobot (Roomba)

**چالش:**
- میلیون‌ها دستگاه Roomba متصل
- نقشه‌برداری، زمان‌بندی و تشخیص در زمان واقعی
- مقیاس جهانی، الگوهای استفاده غیرقابل پیش‌بینی

**راه‌حل Serverless:**
- توابع Lambda درخواست‌های API را از برنامه‌های موبایل مدیریت می‌کنند
- IoT Core برای ارتباط دستگاه
- DynamoDB برای state دستگاه و داده‌های نقشه‌برداری
- S3 برای ذخیره نقشه‌های طبقه

**نتایج:**
- پشتیبانی از 6+ میلیون دستگاه متصل
- استقرار سریع ویژگی
- هزینه با استفاده واقعی مقیاس می‌یابد

### نمونه 3: Netflix

**مورد استفاده:** رمزگذاری و پردازش ویدیو

در حالی که جریان اصلی Netflix از [Microservices](microservices.fa.md) استفاده می‌کند، آن‌ها از Serverless برای موارد زیر استفاده می‌کنند:
- پشتیبان‌گیری خودکار
- پاکسازی داده‌های زمان‌بندی شده
- اعتبارسنجی فایل رسانه
- پردازش Log

**الگوی معماری:**
```
┌──────────────┐
│  ویدیوی جدید │
│  آپلود شد    │
└──────┬───────┘
       │
   ┌───▼───────────┐
   │  رویداد S3    │
   └───┬───────────┘
       │
   ┌───▼────────────────┐
   │ Lambda اعتبارسنج   │
   │ بررسی فرمت و غیره  │
   └───┬────────────────┘
       │
       ├────────────┬─────────────┐
       │            │             │
   ┌───▼────┐  ┌───▼─────┐  ┌───▼─────┐
   │رمزگذاری│ │استخراج  │  │تولید    │
   │ Job    │  │ Metadata│  │Thumbnail│
   └────────┘  └─────────┘  └─────────┘
```

### نمونه 4: Thomson Reuters

**چالش:** پردازش مقالات خبری از 5000+ منبع در زمان واقعی

**راه‌حل Serverless:**
- API Gateway ارسال‌های مقاله را دریافت می‌کند
- توابع Lambda:
  - اعتبارسنجی محتوا
  - استخراج موجودیت‌ها (NLP)
  - دسته‌بندی و برچسب‌زدن
  - ترجمه به زبان‌های متعدد
  - انتشار به CDN

**نتایج:**
- پردازش 10,000+ مقاله در ثانیه در اوج
- کاهش 90% هزینه در مقابل زیرساخت قبلی
- تاخیر پردازش کمتر از یک ثانیه

### نمونه 5: Bustle Digital Group

**چالش:** وب‌سایت رسانه‌ای با ترافیک بسیار متغیر (چرخه‌های خبری)

**راه‌حل:**
- تمام APIهای Backend سرورلس (Lambda + API Gateway)
- بیش از 100 تابع Lambda
- مدیریت محتوا، نظرات، پروفایل‌های کاربر

**نتایج:**
- **مدیریت ترافیک:** از 0 تا 4 میلیون درخواست/ساعت به طور یکپارچه
- **کارایی هزینه:** پرداخت فقط برای ترافیک واقعی
- **بهره‌وری توسعه‌دهنده:** تیم کوچک مقیاس عظیم را مدیریت می‌کند

## 13. Serverless و Microservices

Serverless و [Microservices](microservices.fa.md) الگوهای مکملی هستند که اغلب با هم کار می‌کنند.

### رابطه بین Serverless و Microservices

```
Microservices: الگوی معماری
  └─ چگونه برنامه خود را ساختار دهید

Serverless: الگوی استقرار/زیرساخت
  └─ چگونه برنامه خود را اجرا کنید

می‌توانند ترکیب شوند:
  Microservice = تابع(های) Serverless
```

### معماری Microservices Serverless

```
Microservices Serverless:

┌────────────────────────────────────────────────────────┐
│                    API Gateway                          │
│  - مسیریابی                                             │
│  - احراز هویت                                           │
└───┬──────────────┬─────────────────┬──────────────────┘
    │              │                 │
    │              │                 │
┌───▼─────────┐ ┌──▼──────────┐ ┌───▼─────────────┐
│سرویس کاربر  │ │سرویس سفارش  │ │سرویس پرداخت     │
│             │ │             │ │                 │
│ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────┐   │
│ │Lambda   │ │ │ │Lambda   │ │ │ │Lambda   │   │
│ │GET user │ │ │ │POST order│ │ │ │POST pay │   │
│ └────┬────┘ │ │ └────┬────┘ │ │ └────┬────┘   │
│      │      │ │      │      │ │      │        │
│ ┌────▼────┐ │ │ ┌────▼────┐ │ │ ┌────▼─────┐  │
│ │DynamoDB │ │ │ │DynamoDB │ │ │ │Stripe API│  │
│ │Users    │ │ │ │Orders   │ │ │ │(خارجی)   │  │
│ └─────────┘ │ │ └─────────┘ │ │ └──────────┘  │
└─────────────┘ └─────────────┘ └───────────────┘

هر Microservice = مجموعه‌ای از توابع Lambda + پایگاه داده
```

### مزایای ترکیب Serverless + Microservices

**1. مقیاس‌پذیری مستقل**
- هر Microservice بر اساس ترافیک خود مقیاس می‌یابد
- نیازی به مقیاس‌پذیری کل Monolith نیست

**2. استقرار مستقل**
- استقرار سرویس کاربر بدون تأثیر بر سرویس سفارش
- شعاع انفجار تغییرات کاهش یافته

**3. تنوع تکنولوژی**
- سرویس کاربر در Node.js
- سرویس پرداخت در Python
- سرویس سفارش در Go

**4. کارایی هزینه**
- پرداخت به ازای استفاده Microservice
- سرویس‌های بلاتکلیف هزینه‌ای ندارند

**5. هم‌راستایی سازمانی**
- تیم‌ها سرویس‌های خود را به صورت end-to-end مالک هستند
- مرزها و APIهای واضح

### چالش‌ها

**1. تراکنش‌های توزیع شده**
- بدون ضمانت‌های ACID در میان سرویس‌ها
- نیاز به الگوی Saga، سازگاری نهایی
- پیچیدگی افزایش می‌یابد

**2. ارتباط سرویس**
- همزمان (HTTP) تاخیر اضافه می‌کند
- ناهمزمان (رویدادها) پیچیدگی اضافه می‌کند
- نیاز به [Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md)

**3. اشکال‌زدایی و قابلیت مشاهده**
- درخواست چندین تابع را شامل می‌شود
- نیاز به ردیابی توزیع شده (X-Ray، Jaeger)
- IDهای همبستگی ضروری

**4. Cold Startهای ترکیب شده**
```
جریان درخواست با Cold Startها:

کلاینت → API Gateway → سرویس کاربر (Cold: 500ms)
                            ↓
                       سرویس سفارش (Cold: 500ms)
                            ↓
                       سرویس پرداخت (Cold: 500ms)

تاخیر کل: 1500ms + زمان پردازش واقعی!
```

**کاهش:**
- ارتباط ناهمزمان در جایی که ممکن است
- Provisioned concurrency برای مسیرهای حیاتی
- پاسخ‌های کش

### مقایسه: Microservices Serverless در مقابل Microservices سنتی

| جنبه | Microservices Serverless | Microservices مبتنی بر کانتینر |
|--------|-------------------------|-------------------------------|
| **زیرساخت** | کاملاً مدیریت شده | Kubernetes، ECS و غیره |
| **مقیاس‌پذیری** | خودکار، فوری | Auto-scaling (دقیقه‌ها) |
| **حداقل نمونه‌ها** | صفر (scale to zero) | حداقل 1 به ازای هر سرویس |
| **Cold Startها** | بله (100ms-5s) | حداقل اگر همیشه در حال اجرا باشد |
| **محدودیت‌های اجرا** | 15 دقیقه | نامحدود |
| **هزینه در ترافیک کم** | بسیار کم | بالاتر (حداقل replicaها) |
| **هزینه در ترافیک بالا** | می‌تواند گران باشد | قابل پیش‌بینی‌تر |
| **State** | فقط خارجی | می‌تواند محلی استفاده کند |
| **پیچیدگی** | کمتر (مدیریت شده) | بالاتر (Orchestration) |

### بهترین روش: رویکرد هیبرید

```
معماری هیبرید:

┌────────────────────────────────────────────┐
│   ترافیک بالا، حساس به تاخیر              │
│              ↓                             │
│      ┌────────────────┐                    │
│      │  کانتینر ECS  │                    │
│      │  Core API      │                    │
│      └────────────────┘                    │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│        ترافیک کم، رویداد محور              │
│              ↓                             │
│      ┌──────────┐  ┌──────────┐           │
│      │ Lambda   │  │ Lambda   │           │
│      │ گزارش‌ها │  │ Webhooks │           │
│      └──────────┘  └──────────┘           │
└────────────────────────────────────────────┘
```

استفاده از کانتینرها برای سرویس‌های پرترافیک، stateful و حیاتی به تاخیر. استفاده از Serverless برای وظایف پراکنده، رویداد محور و پس‌زمینه.

## 14. نظارت و قابلیت مشاهده

نظارت مؤثر برای برنامه‌های Serverless به دلیل ماهیت توزیع شده و موقت آن‌ها حیاتی است.

### سه ستون قابلیت مشاهده

**1. Metricها**
```
Metricهای کلیدی Serverless:

┌─────────────────────────────────────┐
│ فراخوانی‌ها   - تعداد، نرخ         │
│ مدت زمان      - میانگین، p99، max  │
│ خطاها         - تعداد، نرخ         │
│ Throttleها    - محدودیت همزمانی   │
│ Cold Startها  - تعداد، مدت زمان   │
│ هزینه         - به ازای هر تابع    │
└─────────────────────────────────────┘
```

**2. Logها**
```javascript
// نمونه ثبت وقایع ساختاریافته
console.log(JSON.stringify({
  timestamp: Date.now(),
  level: 'INFO',
  requestId: context.requestId,
  userId: event.userId,
  action: 'process_order',
  duration: 150,
  status: 'success'
}));
```

**3. Traceها**

ردیابی توزیع شده درخواست‌ها را در میان توابع متعدد دنبال می‌کند:

```
Trace ID: abc-123-def

API Gateway (10ms)
  └─> Lambda سرویس کاربر (150ms)
        └─> کوئری DynamoDB (50ms)
  └─> Lambda سرویس سفارش (200ms)
        └─> ارسال پیام SQS (20ms)
        └─> نوشتن DynamoDB (30ms)

مجموع: 460ms
```

ابزارها: AWS X-Ray، Jaeger، Zipkin، Datadog APM

### بهترین روش‌های نظارت

**1. IDهای همبستگی**
```javascript
exports.handler = async (event, context) => {
  const correlationId = event.headers['x-correlation-id'] || context.requestId;

  // ارسال به تمام فراخوانی‌های downstream
  await callAnotherService({
    headers: { 'x-correlation-id': correlationId }
  });

  // گنجاندن در تمام Logها
  console.log({ correlationId, message: 'پردازش شروع شد' });
};
```

**2. Metricهای سفارشی**
```javascript
const AWS = require('aws-sdk');
const cloudwatch = new AWS.CloudWatch();

async function publishMetric(metricName, value) {
  await cloudwatch.putMetricData({
    Namespace: 'MyApp',
    MetricData: [{
      MetricName: metricName,
      Value: value,
      Unit: 'Count',
      Timestamp: new Date()
    }]
  }).promise();
}

// استفاده
await publishMetric('OrdersProcessed', 1);
```

**3. هشدارها**
- Cold Start > آستانه
- نرخ خطا > 1%
- مدت زمان > آستانه p99
- ناهنجاری‌های هزینه

**4. داشبوردها**
ایجاد داشبوردهایی که نشان می‌دهند:
- حجم درخواست به ازای هر تابع
- نرخ خطا
- صدک‌های تاخیر (p50، p95، p99)
- فرکانس Cold Start
- هزینه به ازای هر تابع

### الگوهای مرتبط

نظارت بر معماری‌های Serverless اغلب نیاز به پیاده‌سازی الگوهای [Circuit Breaker](../resilience/circuit-breaker.fa.md) برای مدیریت شکست‌های graceful دارد.

## 15. ملاحظات امنیتی

امنیت Serverless از مدل مسئولیت مشترک پیروی می‌کند اما با ملاحظات منحصربه‌فرد.

### مسئولیت‌های امنیتی

```
مسئولیت ارائه‌دهنده:
┌─────────────────────────────────┐
│ زیرساخت فیزیکی                 │
│ Hypervisor و ایزوله‌سازی       │
│ وصله‌گذاری محیط Runtime         │
│ قابلیت دسترسی زیرساخت           │
└─────────────────────────────────┘

مسئولیت شما:
┌─────────────────────────────────┐
│ امنیت کد برنامه                 │
│ نقش‌ها و سیاست‌های IAM          │
│ رمزگذاری داده                   │
│ مدیریت اسرار                    │
│ آسیب‌پذیری‌های وابستگی         │
│ پیکربندی API Gateway            │
└─────────────────────────────────┘
```

### روش‌های امنیتی کلیدی

**1. اصل کمترین امتیاز (IAM)**
```yaml
# بد: مجوز بیش از حد
{
  "Effect": "Allow",
  "Action": "*",
  "Resource": "*"
}

# خوب: مجوزهای خاص
{
  "Effect": "Allow",
  "Action": [
    "dynamodb:GetItem",
    "dynamodb:PutItem"
  ],
  "Resource": "arn:aws:dynamodb:region:account:table/Users"
}
```

**2. مدیریت اسرار**
```javascript
// ❌ بد: اسرار هاردکد شده
const API_KEY = 'sk_live_abc123...';

// ✅ خوب: استفاده از مدیر اسرار
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();

async function getSecret(secretName) {
  const data = await secretsManager.getSecretValue({ SecretId: secretName }).promise();
  return JSON.parse(data.SecretString);
}

const secrets = await getSecret('prod/api-keys');
const API_KEY = secrets.stripeKey;
```

**3. اعتبارسنجی ورودی**
```javascript
exports.handler = async (event) => {
  // اعتبارسنجی تمام ورودی‌ها
  if (!event.body) {
    return { statusCode: 400, body: 'بدنه گم شده' };
  }

  const data = JSON.parse(event.body);

  // پاکسازی
  const email = validator.isEmail(data.email) ? data.email : null;
  if (!email) {
    return { statusCode: 400, body: 'ایمیل نامعتبر' };
  }

  // ادامه با داده‌های اعتبارسنجی شده
};
```

**4. وابستگی‌ها**
- ممیزی منظم وابستگی‌ها (`npm audit`، Snyk)
- کمینه کردن وابستگی‌ها برای کاهش سطح حمله
- استفاده از اسکن وابستگی در CI/CD

**5. امنیت API Gateway**
- کلیدهای API برای احراز هویت ساده
- مجوز AWS IAM
- مجوزدهنده‌های JWT (مجوزدهنده‌های Lambda)
- محدودسازی نرخ و Throttling
- اعتبارسنجی درخواست

## 16. بهینه‌سازی هزینه

در حالی که Serverless می‌تواند مقرون به صرفه باشد، توابع بهینه‌نشده می‌توانند گران شوند.

### اجزای هزینه

```
قیمت‌گذاری AWS Lambda (از 2024):

هزینه‌های درخواست:
  $0.20 به ازای 1 میلیون درخواست

هزینه‌های محاسباتی:
  $0.0000166667 به ازای GB-ثانیه

نمونه:
  تابع: 1GB حافظه، 200ms اجرا
  1M فراخوانی:
    - درخواست‌ها: $0.20
    - محاسبه: 1M × 0.2s × 1GB × $0.0000166667 = $3.33
    - مجموع: $3.53
```

### استراتژی‌های بهینه‌سازی هزینه

**1. اندازه صحیح تخصیص حافظه**
```
حافظه در مقابل هزینه:

حافظه بیشتر = CPU بیشتر = اجرای سریع‌تر = هزینه کمتر به ازای هر فراخوانی

┌──────────┬──────────┬──────────┬──────────┐
│  حافظه   │ مدت زمان │ GB-sec   │   هزینه  │
├──────────┼──────────┼──────────┼──────────┤
│  128 MB  │  1000ms  │  0.125   │ $0.0021  │
│  512 MB  │  250ms   │  0.125   │ $0.0021  │ ✅ هزینه یکسان!
│ 1024 MB  │  150ms   │  0.150   │ $0.0025  │
│ 2048 MB  │  100ms   │  0.200   │ $0.0033  │
└──────────┴──────────┴──────────┴──────────┘
```

**استراتژی:** افزایش حافظه برای کاهش مدت زمان. یافتن نقطه شیرین از طریق تست.

**2. کاهش اندازه بسته**
- حذف وابستگی‌های استفاده نشده
- استفاده از webpack/esbuild برای tree-shaking
- بسته‌های کوچک‌تر = Cold Startهای سریع‌تر = عملکرد بهتر

**3. بهینه‌سازی کد**
```javascript
// ❌ بد: مقداردهی در handler
exports.handler = async (event) => {
  const AWS = require('aws-sdk');
  const dynamodb = new AWS.DynamoDB.DocumentClient();
  // هر فراخوانی اجرا می‌شود!

  return dynamodb.get(params).promise();
};

// ✅ خوب: مقداردهی خارج از handler
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient(); // یک بار به ازای هر کانتینر اجرا می‌شود

exports.handler = async (event) => {
  return dynamodb.get(params).promise();
};
```

**4. استفاده از کش**
- کش پاسخ‌های API خارجی
- کش کوئری‌های پایگاه داده
- استفاده از ElastiCache/DynamoDB DAX

**5. انتخاب سرویس مناسب**
```
تصمیم: Lambda در مقابل Fargate در مقابل EC2

برای ترافیک ثابت و بالا:
  Lambda:  $500/ماه
  Fargate: $100/ماه ✅ انتخاب بهتر
  EC2:     $50/ماه  ✅ بهترین برای بار ثابت
```

**6. نظارت و هشدار بر هزینه**
- راه‌اندازی هشدارهای صورتحساب CloudWatch
- برچسب‌زنی منابع بر اساس محیط/تیم
- استفاده از AWS Cost Explorer

## 17. نکات کلیدی

### مفاهیم اصلی

1. **Serverless یک طیف است** - از BaaS (سرویس‌های شخص ثالث) تا FaaS (اجرای تابع)

2. **نام گمراه‌کننده است** - سرورها وجود دارند، فقط شما آن‌ها را مدیریت نمی‌کنید

3. **طراحی رویداد محور** - توابع در پاسخ به محرک‌ها اجرا می‌شوند

4. **مقیاس‌پذیری خودکار** - از صفر تا هزاران اجرای همزمان

5. **پرداخت به ازای اجرا** - فقط هنگام اجرای کد پرداخت کنید، هزینه صفر در بلاتکلیفی

### زمانی که Serverless برتری دارد

```
✅ کامل برای:
  - بارهای کاری پراکنده و غیرقابل پیش‌بینی
  - پردازش رویداد محور (آپلود فایل، webhooks)
  - وظایف زمان‌بندی شده (گزارش‌ها، پاکسازی)
  - نمونه‌سازی سریع و MVPها
  - APIهای کم‌ترافیک
  - کارهای پس‌زمینه
```

### چه زمانی از Serverless اجتناب کنیم

```
❌ مناسب نیست برای:
  - فرآیندهای طولانی‌مدت (> 15 دقیقه)
  - ترافیک بالا و ثابت (ناکارآمد از نظر هزینه)
  - برنامه‌های حساس به تاخیر (الزام < 100ms)
  - برنامه‌های Stateful (WebSockets، بازی)
  - وابستگی‌های بزرگ یا Monolithها
```

### معاوضه‌های حیاتی

| مزیت | نقص |
|---------|----------|
| بدون مدیریت زیرساخت | قفل شدن در ارائه‌دهنده |
| مقیاس‌پذیری خودکار | تاخیر Cold Start |
| هزینه پرداخت به ازای اجرا | هزینه در مقیاس بالا |
| توسعه سریع | محدودیت‌های زمان اجرا |
| HA داخلی | طراحی بدون state مورد نیاز |
| کاهش زمان ورود به بازار | پیچیدگی اشکال‌زدایی |

### الگوهای معماری برای به خاطر سپردن

1. **Backend API:** API Gateway + Lambda + DynamoDB
2. **پردازش رویداد:** S3/SNS/SQS → Lambda → ذخیره
3. **پردازش Stream:** Kinesis/Kafka → Lambda → تحلیل
4. **Fan-out:** رویداد واحد → پردازشگرهای Lambda متعدد
5. **وظایف زمان‌بندی شده:** رویدادهای CloudWatch → Lambda

### بهترین روش‌ها

1. **طراحی برای بدون state** - استفاده از ذخیره‌گاه‌های State خارجی
2. **توابع کوچک نگه دارید** - مسئولیت واحد، اجرای سریع
3. **مقداردهی خارج از handler** - استفاده مجدد از اتصالات و کلاینت‌ها
4. **استفاده از ثبت وقایع ساختاریافته** - شامل IDهای همبستگی
5. **پیاده‌سازی idempotency** - مدیریت تلاش‌های مجدد به شکل مناسب
6. **نظارت بر Cold Startها** - بهینه‌سازی یا استفاده از provisioned concurrency
7. **اندازه صحیح حافظه** - حافظه بیشتر = CPU بیشتر = اجرای سریع‌تر
8. **کمینه کردن وابستگی‌ها** - بسته‌های کوچک‌تر = Cold Startهای سریع‌تر
9. **برنامه‌ریزی برای قفل شدن در ارائه‌دهنده** - انتزاع APIهای خاص ارائه‌دهنده یا پذیرش آن
10. **تنظیم هشدارهای هزینه** - نظارت بر هزینه برای جلوگیری از غافلگیری

### الگوهای مرتبط

- ترکیب با **[Microservices](microservices.fa.md)** برای معماری‌های توزیع شده
- استفاده از **[API Gateway](api-gateway.fa.md)** برای مسیریابی و امنیت HTTP
- پیاده‌سازی **[Event-Driven Architecture](../event-driven/event-driven-architecture.fa.md)** برای ارتباط ناهمزمان
- اعمال **[CQRS](../data-patterns/cqrs.fa.md)** برای جداسازی خواندن/نوشتن
- بهره‌برداری از **[RabbitMQ vs Kafka](../messaging/rabbitmq-vs-kafka.fa.md)** برای پیام‌رسانی
- پیاده‌سازی **[Circuit Breaker](../resilience/circuit-breaker.fa.md)** برای انعطاف‌پذیری
- در نظر گرفتن **[CAP Theorem](../fundamentals/cap-theorem.fa.md)** برای State توزیع شده

## 18. چارچوب مصاحبه

هنگام بحث درباره Serverless در مصاحبه‌های طراحی سیستم:

### مرحله 1: روشن کردن الزامات

سؤال کنید:
- الگوی ترافیک چیست؟ (پراکنده در مقابل ثابت)
- مقیاس مورد انتظار چیست؟ (درخواست/ثانیه)
- الزامات تاخیر چیست؟ (می‌تواند Cold Startها را تحمل کند؟)
- عملیات چقدر طول می‌کشد؟ (< 15 دقیقه؟)
- این یک سیستم جدید است یا مهاجرت؟

### مرحله 2: بحث درباره معاوضه‌ها

همیشه به اینها بپردازید:
- **مدل هزینه:** پرداخت به ازای اجرا در مقابل سرورهای همیشه روشن
- **Cold Startها:** تأثیر بر تجربه کاربر
- **قفل شدن در ارائه‌دهنده:** استراتژی و پذیرش
- **محدودیت‌های اجرا:** محدودیت‌های زمان و حافظه
- **مدیریت State:** چگونه عملیات Stateful را مدیریت کنیم

### مرحله 3: پیشنهاد معماری

نمودار رسم کنید که نشان دهد:
```
┌─────────┐
│ محرک    │ (API Gateway، S3، زمان‌بندی و غیره)
└────┬────┘
     │
┌────▼─────────┐
│ تابع Lambda  │ (منطق تابع)
│              │
└────┬─────────┘
     │
┌────▼─────────┐
│ ذخیره State  │ (DynamoDB، RDS، S3 و غیره)
└──────────────┘
```

### مرحله 4: پرداختن به مقیاس‌پذیری و قابلیت اطمینان

توضیح دهید:
- چگونه سیستم به صورت خودکار مقیاس می‌یابد
- چگونه شکست‌ها را مدیریت کنیم (تلاش‌های مجدد، DLQ)
- استراتژی نظارت و هشدار
- هزینه در مقیاس مورد انتظار

### مرحله 5: بحث درباره جایگزین‌ها

مقایسه کنید:
- Serverless در مقابل کانتینرها در مقابل سرورهای سنتی
- چرا Serverless بهترین انتخاب است (یا نیست)

### الگوی پاسخ نمونه

"برای این مورد استفاده، Serverless را توصیه می‌کنم چون [الگوی ترافیک/مقیاس/زمان-به-بازار]. معماری از [محرک] برای فراخوانی توابع Lambda که [منطق کسب‌وکار] استفاده می‌کند، state را در [پایگاه داده] ذخیره می‌کند.

مزایای اصلی [مقیاس‌پذیری خودکار/کارایی هزینه/عملیات کاهش یافته] هستند. معاوضه‌هایی که باید در نظر بگیریم [Cold Startها/قفل شدن در ارائه‌دهنده/محدودیت‌های اجرا] هستند. برای کاهش Cold Startها، می‌توانیم [provisioned concurrency/پردازش async/بهینه‌سازی اندازه بسته].

در مقیاس مورد انتظار [X درخواست]، هزینه تقریباً [محاسبه] خواهد بود. اگر ترافیک به [Y درخواست] برسد، ممکن است بخواهیم بازنگری کنیم و احتمالاً به [کانتینرها/سرورهای اختصاصی] برای بهینه‌سازی هزینه منتقل شویم.

برای انعطاف‌پذیری، [تلاش‌های مجدد، DLQ، Circuit Breaker] را پیاده‌سازی می‌کنیم. برای قابلیت مشاهده، از [CloudWatch/X-Ray] با ثبت وقایع ساختاریافته و ردیابی توزیع شده استفاده می‌کنیم."

---

**مطالعه بیشتر:**
- [معماری Microservices](microservices.fa.md)
- [الگوی API Gateway](api-gateway.fa.md)
- [معماری رویداد محور](../event-driven/event-driven-architecture.fa.md)
- [قضیه CAP](../fundamentals/cap-theorem.fa.md)
- [الگوی Circuit Breaker](../resilience/circuit-breaker.fa.md)
- [الگوی CQRS](../data-patterns/cqrs.fa.md)
- [مقایسه صف پیام](../messaging/rabbitmq-vs-kafka.fa.md)
