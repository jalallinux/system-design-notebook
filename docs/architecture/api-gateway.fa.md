# الگوی API Gateway

## 1. مقدمه

**API Gateway** یک سرور واسط است که بین کلاینت‌ها و سرویس‌های backend در یک معماری microservices قرار می‌گیرد. این component به عنوان نقطه ورود واحد برای تمام درخواست‌های کلاینت عمل می‌کند و یک رابط یکپارچه به سرویس‌های متعدد backend ارائه می‌دهد، در حالی که مسئولیت‌های مشترک مانند احراز هویت، rate limiting، load balancing و تبدیل پروتکل را مدیریت می‌کند.

الگوی API Gateway در سیستم‌های توزیع‌شده مدرن، به ویژه در [معماری‌های microservices](microservices.fa.md)، نقشی بنیادی دارد. این الگو کلاینت‌ها را از توپولوژی داخلی سرویس‌ها جدا می‌کند و به سرویس‌های backend اجازه می‌دهد به صورت مستقل تکامل یابند بدون اینکه بر برنامه‌های کلاینت تأثیر بگذارند.

**ویژگی‌های کلیدی:**

- **نقطه ورود واحد**: تمام درخواست‌های کلاینت از gateway عبور می‌کنند
- **مسیریابی درخواست**: درخواست‌ها را به طور هوشمند به سرویس‌های مناسب backend هدایت می‌کند
- **تبدیل پروتکل**: تبدیل بین پروتکل‌های کلاینت و سرویس (HTTP، gRPC، WebSocket)
- **مسئولیت‌های مشترک**: متمرکز کردن احراز هویت، نظارت، rate limiting و caching
- **ترکیب سرویس**: ادغام پاسخ‌های چندین سرویس در یک پاسخ واحد

## 2. بیان مسئله

در یک معماری microservices بدون API Gateway، کلاینت‌ها با چندین چالش مواجه می‌شوند:

### 2.1 درخواست‌های چندگانه

```
┌─────────────┐
│   Client    │
│  (Mobile)   │
└──────┬──────┘
       │
       │ GET /user/123
       ├──────────────────────────────────────┐
       │                                      │
       │ GET /orders/user/123                 │
       ├────────────────────────┐             │
       │                        │             │
       │ GET /recommendations   │             │
       ├──────────────┐         │             │
       │              │         │             │
       ▼              ▼         ▼             ▼
┌────────────┐  ┌──────────┐ ┌──────────┐ ┌──────────┐
│   User     │  │  Order   │ │Recommend │ │ Inventory│
│  Service   │  │ Service  │ │ Service  │ │ Service  │
└────────────┘  └──────────┘ └──────────┘ └──────────┘
```

**مشکلات:**

- **تأخیر بالا**: چندین فراخوانی متوالی زمان کل پاسخ را افزایش می‌دهند
- **بار شبکه**: هر فراخوانی هزینه تأخیر و پهنای باند شبکه دارد
- **مصرف باتری موبایل**: درخواست‌های شبکه زیاد باتری دستگاه‌های موبایل را تخلیه می‌کند
- **منطق پیچیده کلاینت**: کلاینت‌ها باید چندین فراخوانی سرویس را هماهنگ کنند

### 2.2 عدم تطابق پروتکل

- **تنوع Backend**: سرویس‌ها ممکن است از پروتکل‌های مختلف استفاده کنند (REST، gRPC، SOAP، WebSocket)
- **محدودیت‌های کلاینت**: کلاینت‌های موبایل ممکن است از همه پروتکل‌ها به طور کارآمد پشتیبانی نکنند
- **سربار پروتکل**: gRPC کارآمد است اما بدون transcoding برای مرورگرها مناسب نیست

### 2.3 جفت شدگی محکم

- **Service Discovery**: کلاینت‌ها باید مکان هر سرویس را بدانند
- **تکامل سرویس**: تغییرات backend نیاز به به‌روزرسانی کلاینت دارد
- **مدیریت نسخه**: چندین نسخه API باید در تمام کلاینت‌ها مدیریت شود
- **افشای امنیتی**: URL‌ها و توپولوژی سرویس‌های داخلی به کلاینت‌ها افشا می‌شود

### 2.4 تکرار مسئولیت‌های مشترک

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Service A │     │   Service B │     │   Service C │
│             │     │             │     │             │
│ • Auth      │     │ • Auth      │     │ • Auth      │
│ • Logging   │     │ • Logging   │     │ • Logging   │
│ • Rate Limit│     │ • Rate Limit│     │ • Rate Limit│
│ • SSL       │     │ • SSL       │     │ • SSL       │
│ • Caching   │     │ • Caching   │     │ • Caching   │
└─────────────┘     └─────────────┘     └─────────────┘
```

**مشکلات:**

- **تکرار کد**: همان منطق در هر سرویس پیاده‌سازی می‌شود
- **عدم سازگاری**: پیاده‌سازی‌های مختلف منجر به رفتارهای متفاوت می‌شوند
- **بار نگهداری**: به‌روزرسانی‌ها باید به همه سرویس‌ها اعمال شود
- **تأثیر عملکرد**: هر سرویس عملیات‌های تکراری را انجام می‌دهد

## 3. نحوه کار API Gateway

### 3.1 معماری پایه

```
                          ┌─────────────────────────────────────────┐
                          │          API Gateway                    │
                          │                                         │
┌──────────┐              │  ┌────────────────────────────────┐   │
│          │              │  │    Request Processing Layer    │   │
│  Web     │──────┐       │  │  • Authentication              │   │
│  Client  │      │       │  │  • Authorization               │   │
└──────────┘      │       │  │  • Rate Limiting               │   │
                  │       │  │  • Request Validation          │   │
┌──────────┐      ├──────▶│  │  • Protocol Translation        │   │
│          │      │       │  │  • SSL Termination             │   │
│  Mobile  │──────┤       │  └────────────────────────────────┘   │
│  Client  │      │       │                                         │
└──────────┘      │       │  ┌────────────────────────────────┐   │
                  │       │  │    Routing & Composition       │   │
┌──────────┐      │       │  │  • Service Discovery           │   │
│          │      │       │  │  • Load Balancing              │   │
│ 3rd Party│──────┘       │  │  • Request Routing             │   │
│   API    │              │  │  • Response Aggregation        │   │
└──────────┘              │  │  • Circuit Breaking            │   │
                          │  └────────────────────────────────┘   │
                          │                                         │
                          │  ┌────────────────────────────────┐   │
                          │  │    Monitoring & Analytics      │   │
                          │  │  • Logging                     │   │
                          │  │  • Metrics Collection          │   │
                          │  │  • Request Tracing             │   │
                          │  └────────────────────────────────┘   │
                          └───────────────┬─────────────────────────┘
                                          │
                          ┌───────────────┼───────────────┐
                          │               │               │
                          ▼               ▼               ▼
                    ┌──────────┐    ┌──────────┐    ┌──────────┐
                    │  User    │    │  Order   │    │ Payment  │
                    │ Service  │    │ Service  │    │ Service  │
                    └──────────┘    └──────────┘    └──────────┘
```

### 3.2 جریان درخواست

```
مرحله 1: درخواست کلاینت
Client ────[HTTPS Request]────▶ API Gateway
        (https://api.example.com/user/profile)

مرحله 2: پردازش Gateway
API Gateway:
  ├─ خاتمه SSL
  ├─ اعتبارسنجی JWT Token
  ├─ بررسی Rate Limit (100 req/min)
  ├─ بررسی Cache (Cache Miss)
  ├─ تصمیم مسیریابی: /user/* → User Service
  └─ تبدیل درخواست (افزودن Headers)

مرحله 3: ارتباط با Backend
API Gateway ────[HTTP/gRPC]────▶ User Service
             (http://user-service:8080/profile)

مرحله 4: پردازش پاسخ
User Service ────[Response]────▶ API Gateway
API Gateway:
  ├─ تبدیل پاسخ (حذف فیلدهای داخلی)
  ├─ افزودن CORS Headers
  ├─ Cache پاسخ (TTL: 5min)
  ├─ ثبت درخواست (Latency: 45ms)
  └─ فشرده‌سازی پاسخ (gzip)

مرحله 5: پاسخ کلاینت
API Gateway ────[HTTPS Response]────▶ Client
```

### 3.3 ادغام درخواست

```
Client Request: GET /dashboard
       │
       ▼
┌──────────────────────────────────────┐
│         API Gateway                  │
│  Parallel Requests:                  │
│    ┌───────────────────────┐         │
│    │ GET /user/profile     │         │
│    │ GET /orders/recent    │         │
│    │ GET /notifications    │         │
│    └───────────────────────┘         │
└──────┬────────┬────────┬─────────────┘
       │        │        │
       ▼        ▼        ▼
   ┌────────┐ ┌────────┐ ┌────────────┐
   │  User  │ │ Order  │ │Notification│
   │Service │ │Service │ │  Service   │
   └───┬────┘ └───┬────┘ └─────┬──────┘
       │          │            │
       │ 50ms     │ 120ms      │ 80ms
       │          │            │
       └──────────┴────────────┘
                  │
                  ▼
       ┌──────────────────────┐
       │   API Gateway        │
       │   Aggregate:         │
       │   {                  │
       │     user: {...},     │
       │     orders: [...],   │
       │     notifications:[..]│
       │   }                  │
       │   Total: 120ms       │
       └──────────────────────┘
                  │
                  ▼
              Client
```

## 4. ویژگی‌های اصلی

### 4.1 احراز هویت و مجوزدهی

```
┌─────────────┐
│   Client    │
│ (JWT Token) │
└──────┬──────┘
       │ Authorization: Bearer eyJhbGc...
       ▼
┌─────────────────────────────────────┐
│      API Gateway                    │
│                                     │
│  1. استخراج JWT Token               │
│  2. اعتبارسنجی امضا                 │
│  3. بررسی انقضا                     │
│  4. استخراج Claims (user_id, role)  │
│  5. بررسی دسترسی‌ها                 │
│     • آیا کاربر مجاز است؟           │
│     • آیا نقش دسترسی دارد؟          │
│  6. افزودن User Context به درخواست │
│     X-User-ID: 12345                │
│     X-User-Role: admin              │
└──────────┬──────────────────────────┘
           │ Authenticated Request
           ▼
    ┌──────────────┐
    │   Backend    │
    │   Service    │
    │ (Trust Gateway)│
    └──────────────┘
```

**روش‌های احراز هویت:**

- **JWT Tokens**: توکن‌های بدون وضعیت و خودکفا
- **OAuth 2.0**: مجوزدهی تفویض‌شده
- **API Keys**: احراز هویت ساده مبتنی بر کلید
- **mTLS**: احراز هویت مبتنی بر گواهی TLS دوطرفه
- **Session Cookies**: مدیریت سنتی session

### 4.2 محدودسازی نرخ (Rate Limiting)

```
الگوریتم: Token Bucket

┌─────────────────────────────────┐
│  Rate Limiter (per user)        │
│                                 │
│  Bucket Capacity: 100 tokens    │
│  Refill Rate: 10 tokens/second  │
│                                 │
│  Current State:                 │
│  ┌─────────────────────────┐   │
│  │ ▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░░░ │   │
│  │ 45 tokens available      │   │
│  └─────────────────────────┘   │
│                                 │
│  Request: Cost 1 token          │
│  Result: ✓ Allow (44 remaining) │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│  اگر bucket خالی است:           │
│  ┌─────────────────────────┐   │
│  │ ░░░░░░░░░░░░░░░░░░░░░░░░ │   │
│  │ 0 tokens available       │   │
│  └─────────────────────────┘   │
│                                 │
│  Result: ✗ Reject               │
│  Response: 429 Too Many Requests│
│  Headers:                       │
│    X-RateLimit-Limit: 100       │
│    X-RateLimit-Remaining: 0     │
│    X-RateLimit-Reset: 1609459200│
└─────────────────────────────────┘
```

**استراتژی‌های Rate Limiting:**

| استراتژی | محدوده | مورد استفاده |
|----------|-------|----------|
| Per User | شناسه کاربر | استفاده منصفانه به ازای هر حساب |
| Per IP | آدرس IP مبدأ | حفاظت از DDoS |
| Per API Key | شناسه API key | محدودیت API شخص ثالث |
| Per Endpoint | مسیر خاص | حفاظت از عملیات پرهزینه |
| Global | کل gateway | حفاظت از زیرساخت |

### 4.3 توزیع بار (Load Balancing)

```
┌─────────────────────────────────────┐
│         API Gateway                 │
│      Load Balancer Module           │
└──────────┬──────────────────────────┘
           │
    ┌──────┴───────┐
    │ Routing      │
    │ Algorithm:   │
    │ Round Robin  │
    └──────┬───────┘
           │
    ┌──────┴──────────────────────┐
    │                             │
    ▼                             ▼
┌─────────┐  Healthy          ┌─────────┐  Healthy
│Instance │  ✓ 200 OK         │Instance │  ✓ 200 OK
│   #1    │  Latency: 45ms    │   #2    │  Latency: 52ms
│ 75% CPU │  Connections: 150 │ 60% CPU │  Connections: 120
└─────────┘                   └─────────┘

    ▼                             ▼
┌─────────┐  Unhealthy        ┌─────────┐  Healthy
│Instance │  ✗ Timeout        │Instance │  ✓ 200 OK
│   #3    │  Circuit: OPEN    │   #4    │  Latency: 48ms
│    -    │  (Excluded)       │ 65% CPU │  Connections: 135
└─────────┘                   └─────────┘
```

**الگوریتم‌های توزیع بار:**

| الگوریتم | توضیحات | مناسب برای |
|-----------|-------------|----------|
| Round Robin | توزیع درخواست‌ها به صورت متوالی | ظرفیت یکنواخت backend |
| Weighted Round Robin | تخصیص وزن بر اساس ظرفیت | نمونه‌های ناهمگن |
| Least Connections | مسیریابی به نمونه با کمترین اتصال | اتصالات طولانی |
| Least Response Time | مسیریابی به سریع‌ترین نمونه | پیچیدگی متغیر workload |
| IP Hash | مسیریابی سازگار بر اساس IP کلاینت | session affinity |
| Random | انتخاب تصادفی | سرویس‌های ساده و بدون وضعیت |

### 4.4 تبدیل درخواست/پاسخ

```
┌──────────────────────────────────────────────────────┐
│  Client Request                                       │
│  GET /api/v2/users/12345                             │
│  Accept: application/json                            │
│  Authorization: Bearer token123                       │
└──────────┬───────────────────────────────────────────┘
           │
           ▼
┌──────────────────────────────────────────────────────┐
│  API Gateway Transformations                         │
│  ┌────────────────────────────────────────────────┐ │
│  │ Request Transformation                         │ │
│  │ • حذف پیشوند /api/v2                          │ │
│  │ • تبدیل /users → /internal/user-service       │ │
│  │ • افزودن correlation ID                       │ │
│  │ • افزودن metadata gateway                     │ │
│  │ • تبدیل REST → gRPC (در صورت نیاز)            │ │
│  └────────────────────────────────────────────────┘ │
└──────────┬───────────────────────────────────────────┘
           │
           ▼
┌──────────────────────────────────────────────────────┐
│  Backend Request                                      │
│  POST /internal/user-service/get-user                │
│  Content-Type: application/grpc                      │
│  X-User-ID: 12345                                    │
│  X-Correlation-ID: abc-123-def                       │
│  X-Gateway-Version: 2.1.0                            │
└──────────┬───────────────────────────────────────────┘
           │
           ▼
    [Backend Service]
           │
           ▼
┌──────────────────────────────────────────────────────┐
│  Backend Response                                     │
│  {                                                    │
│    "userId": 12345,                                  │
│    "internalFields": {...},      ← حذف              │
│    "debugInfo": {...},           ← حذف              │
│    "name": "John Doe",                               │
│    "email": "john@example.com"                       │
│  }                                                    │
└──────────┬───────────────────────────────────────────┘
           │
           ▼
┌──────────────────────────────────────────────────────┐
│  API Gateway Transformations                         │
│  ┌────────────────────────────────────────────────┐ │
│  │ Response Transformation                        │ │
│  │ • حذف فیلدهای داخلی                           │ │
│  │ • افزودن لینک‌های HATEOAS                     │ │
│  │ • فرمت کردن تاریخ‌ها (ISO 8601)               │ │
│  │ • افزودن cache headers                        │ │
│  │ • افزودن CORS headers                         │ │
│  └────────────────────────────────────────────────┘ │
└──────────┬───────────────────────────────────────────┘
           │
           ▼
┌──────────────────────────────────────────────────────┐
│  Client Response                                      │
│  200 OK                                              │
│  Cache-Control: max-age=300                          │
│  Access-Control-Allow-Origin: *                      │
│  {                                                    │
│    "id": 12345,                                      │
│    "name": "John Doe",                               │
│    "email": "john@example.com",                      │
│    "_links": {                                       │
│      "self": "/api/v2/users/12345",                 │
│      "orders": "/api/v2/users/12345/orders"         │
│    }                                                 │
│  }                                                    │
└──────────────────────────────────────────────────────┘
```

### 4.5 ذخیره‌سازی موقت (Caching)

```
┌─────────────────────────────────────────────────────┐
│              API Gateway Cache                      │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │         Cache Layer (Redis/Memcached)       │  │
│  │                                             │  │
│  │  Key: GET:/users/123                        │  │
│  │  Value: {"id":123,"name":"John"}            │  │
│  │  TTL: 300 seconds                           │  │
│  │  Hits: 1,542 | Misses: 23                   │  │
│  └─────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘

جریان درخواست با Cache:

1. Cache Hit:
   Client ──▶ Gateway ──▶ Cache ──▶ بازگشت Cached
                          (5ms)

2. Cache Miss:
   Client ──▶ Gateway ──▶ Cache (Miss) ──▶ Backend (50ms)
                                            │
                                            ▼
              Gateway ◀──── ذخیره در Cache ◀─┘
                │
                ▼
              Client
```

**استراتژی‌های Cache:**

| استراتژی | توضیحات | Invalidation | مورد استفاده |
|----------|-------------|--------------|----------|
| Time-based (TTL) | انقضای cache بعد از مدت زمان | خودکار | داده‌های استاتیک/نیمه‌استاتیک |
| Event-based | ابطال در رویدادهای خاص | دستی/رویداد | داده با به‌روزرسانی‌های شناخته‌شده |
| Cache-Aside | بارگذاری در miss، cache صریح | TTL + دستی | بارکاری read-heavy |
| Write-Through | نوشتن همزمان در cache و DB | همزمان | عملیات Write + Read |
| Write-Behind | نوشتن در cache، async به DB | ناهمزمان | بارکاری write-heavy |

### 4.6 خاتمه SSL/TLS

```
┌──────────┐
│  Client  │
└─────┬────┘
      │ HTTPS (TLS 1.3)
      │ ترافیک رمزشده
      ▼
┌──────────────────────────────────────┐
│      API Gateway                     │
│                                      │
│  ┌────────────────────────────────┐ │
│  │   SSL/TLS Termination          │ │
│  │   • رمزگشایی ترافیک ورودی      │ │
│  │   • اعتبارسنجی گواهی‌ها        │ │
│  │   • مدیریت TLS handshake       │ │
│  │   • کاهش بار CPU رمزنگاری      │ │
│  └────────────────────────────────┘ │
└──────────┬───────────────────────────┘
           │ HTTP (Plain)
           │ شبکه داخلی (قابل اعتماد)
           ▼
    ┌──────────────┐
    │   Backend    │
    │   Services   │
    │ (No SSL)     │
    └──────────────┘
```

**مزایا:**

- **عملکرد**: سرویس‌های backend سربار رمزنگاری را مدیریت نمی‌کنند
- **مدیریت متمرکز**: نقطه واحد برای مدیریت گواهی
- **ساده‌سازی Backend**: سرویس‌ها روی منطق کسب‌وکار تمرکز می‌کنند
- **انعطاف پروتکل**: می‌توان از پروتکل‌های مختلف به صورت داخلی استفاده کرد

### 4.7 نظارت و لاگ‌گیری

```
┌─────────────────────────────────────────────────────┐
│         API Gateway Observability                   │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │            Request Logging                  │  │
│  │  • Request ID: abc-123                      │  │
│  │  • Method: GET                              │  │
│  │  • Path: /users/123                         │  │
│  │  • Client IP: 203.0.113.42                  │  │
│  │  • User Agent: Mobile/iOS                   │  │
│  │  • Response Status: 200                     │  │
│  │  • Latency: 45ms                            │  │
│  │  • Upstream: user-service-2                 │  │
│  └─────────────────────────────────────────────┘  │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │            Metrics Collection               │  │
│  │  • Request Rate: 10,000 req/sec             │  │
│  │  • Error Rate: 0.05%                        │  │
│  │  • P50 Latency: 35ms                        │  │
│  │  • P95 Latency: 120ms                       │  │
│  │  • P99 Latency: 250ms                       │  │
│  │  • Cache Hit Rate: 75%                      │  │
│  └─────────────────────────────────────────────┘  │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │         Distributed Tracing                 │  │
│  │  Trace ID: xyz-789                          │  │
│  │  ├─ API Gateway: 5ms                        │  │
│  │  ├─ User Service: 25ms                      │  │
│  │  │  ├─ Cache Check: 2ms                     │  │
│  │  │  └─ DB Query: 20ms                       │  │
│  │  └─ Order Service: 15ms                     │  │
│  │     └─ DB Query: 12ms                       │  │
│  └─────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

## 5. الگوهای API Gateway

### 5.1 الگوی مسیریابی Gateway

مسیریابی ساده درخواست بر اساس مسیر URL یا headerها.

```
┌─────────────────────────────────────┐
│         API Gateway                 │
│                                     │
│  قوانین مسیریابی:                  │
│  /users/*     → User Service        │
│  /orders/*    → Order Service       │
│  /products/*  → Product Service     │
│  /payments/*  → Payment Service     │
└──────────┬──────────────────────────┘
           │
    ┌──────┴──────┬──────────┬────────────┐
    │             │          │            │
    ▼             ▼          ▼            ▼
┌────────┐  ┌─────────┐ ┌────────┐  ┌─────────┐
│  User  │  │  Order  │ │Product │  │ Payment │
│Service │  │ Service │ │Service │  │ Service │
└────────┘  └─────────┘ └────────┘  └─────────┘
```

**مورد استفاده**: Microservices با مرزهای دامنه واضح

### 5.2 الگوی ادغام Gateway

ادغام چندین فراخوانی backend در یک پاسخ واحد.

```
Client: GET /user/123/dashboard
           │
           ▼
┌──────────────────────────────────────┐
│      API Gateway                     │
│   منطق ادغام                         │
└───┬────────┬────────┬────────────────┘
    │        │        │
    │ (1)    │ (2)    │ (3)
    │        │        │
    ▼        ▼        ▼
┌────────┐ ┌─────┐ ┌──────────┐
│  User  │ │Order│ │Recommend │
│Service │ │Svc  │ │ Service  │
└───┬────┘ └──┬──┘ └────┬─────┘
    │         │         │
    │ {user}  │{orders} │{items}
    └─────────┴─────────┘
              │
              ▼
    ┌──────────────────┐
    │   Combined:      │
    │   {              │
    │     user: {...}, │
    │     orders:[...],│
    │     items: [...] │
    │   }              │
    └──────────────────┘
              │
              ▼
          Client
```

**مورد استفاده**: صفحات داشبورد، برنامه‌های موبایل نیازمند چندین منبع داده

### 5.3 الگوی Offloading Gateway

انتقال مسئولیت‌های مشترک از سرویس‌های backend به gateway.

```
┌─────────────────────────────────────────────────┐
│            API Gateway                          │
│  ┌───────────────────────────────────────────┐ │
│  │     مسئولیت‌های منتقل شده                │ │
│  │  • احراز هویت و مجوزدهی                  │ │
│  │  • خاتمه SSL/TLS                          │ │
│  │  • Rate Limiting و Throttling             │ │
│  │  • Request/Response Caching               │ │
│  │  • Logging و Monitoring                   │ │
│  │  • تبدیل Request/Response                 │ │
│  │  • مدیریت CORS                            │ │
│  │  │  • Whitelisting/Blacklisting IP       │ │
│  └───────────────────────────────────────────┘ │
└──────────────┬──────────────────────────────────┘
               │ درخواست ساده‌شده
               ▼
        ┌──────────────┐
        │   Backend    │
        │   Services   │
        │              │
        │ تمرکز بر:    │
        │ • Business   │
        │   Logic      │
        │ • Data       │
        │   Processing │
        └──────────────┘
```

**مورد استفاده**: ساده‌سازی سرویس‌های backend، اجرای سیاست‌های سازگار

## 6. الگوی Backend for Frontend (BFF)

الگوی BFF شامل ایجاد API Gateway های جداگانه متناسب با انواع مختلف کلاینت است. هر BFF برای نیازهای خاص کلاینت بهینه‌سازی شده است.

### 6.1 معماری

```
┌──────────────┐         ┌─────────────────────────────┐
│              │         │      Web BFF Gateway        │
│ Web Browser  │────────▶│  • پاسخ‌های کامل HTML      │
│              │         │  • payloadهای بزرگ OK       │
│              │         │  • ساختارهای داده غنی       │
└──────────────┘         └───────────┬─────────────────┘
                                     │
┌──────────────┐         ┌───────────┼─────────────────┐
│              │         │    Mobile BFF Gateway       │
│ Mobile App   │────────▶│  • payloadهای حداقلی        │
│ (iOS/Android)│         │  • بهینه برای پهنای باند   │
│              │         │  • پاسخ‌های ادغام‌شده       │
└──────────────┘         └───────────┬─────────────────┘
                                     │
┌──────────────┐         ┌───────────┼─────────────────┐
│              │         │   Partner BFF Gateway       │
│ 3rd Party    │────────▶│  • نسخه‌بندی API            │
│ Integration  │         │  • Rate limiting per key    │
│              │         │  • اعتبارسنجی سخت‌گیرانه    │
└──────────────┘         └───────────┬─────────────────┘
                                     │
                         ┌───────────┴─────────────────┐
                         │                             │
                         ▼                             ▼
                  ┌────────────┐              ┌────────────┐
                  │  Shared    │              │   Domain   │
                  │  Services  │              │  Services  │
                  │            │              │            │
                  │ • User     │              │ • Orders   │
                  │ • Auth     │              │ • Products │
                  │ • Catalog  │              │ • Payments │
                  └────────────┘              └────────────┘
```

### 6.2 مقایسه BFF

| جنبه | Web BFF | Mobile BFF | Partner BFF |
|--------|---------|------------|-------------|
| **اندازه Payload** | بزرگ (پرجزئیات) | کوچک (حداقلی) | متوسط (مستندسازی‌شده) |
| **فرمت پاسخ** | اشیا تو در تو | ساختارهای مسطح | schemaهای نسخه‌بندی‌شده |
| **ادغام** | متوسط | سنگین | حداقلی |
| **Caching** | سازگار با مرورگر | تهاجمی | محافظه‌کارانه |
| **احراز هویت** | Session cookies | JWT tokens | API keys + OAuth |
| **Rate Limiting** | ملایم | متوسط | سخت‌گیرانه per partner |
| **مستندات** | داخلی | داخلی | OpenAPI/Swagger |
| **نسخه‌بندی** | انعطاف‌پذیر | انعطاف‌پذیر | SLA سخت‌گیرانه |

### 6.3 مثال: پاسخ موبایل در مقابل وب

**پاسخ Web BFF** (پرجزئیات، غنی):

```json
{
  "user": {
    "id": 123,
    "firstName": "John",
    "lastName": "Doe",
    "email": "john@example.com",
    "address": {
      "street": "123 Main St",
      "city": "Springfield",
      "state": "IL",
      "zip": "62701",
      "country": "USA"
    },
    "preferences": {
      "theme": "dark",
      "language": "en",
      "notifications": true
    }
  },
  "orders": [
    {
      "id": 456,
      "date": "2024-01-15T10:30:00Z",
      "items": [...],
      "shipping": {...},
      "billing": {...}
    }
  ],
  "_links": {...}
}
```

**پاسخ Mobile BFF** (حداقلی، بهینه):

```json
{
  "userId": 123,
  "name": "John Doe",
  "orders": [
    {
      "id": 456,
      "date": "2024-01-15",
      "total": 99.99,
      "status": "shipped"
    }
  ]
}
```

### 6.4 مزایای BFF

- **بهینه‌سازی کلاینت**: هر BFF برای محدودیت‌های خاص کلاینت بهینه شده است
- **توسعه موازی**: تیم‌های frontend و BFF می‌توانند به صورت مستقل iterate کنند
- **کاهش جفت‌شدگی**: تغییرات یک کلاینت بر دیگران تأثیر نمی‌گذارد
- **تست آسان‌تر**: هر BFF را می‌توان به صورت جداگانه تست کرد
- **عملکرد**: پاسخ‌های متناسب over-fetching و under-fetching را کاهش می‌دهند

### 6.5 معایب BFF

- **تکرار کد**: منطق مشابه در BFFهای متعدد
- **سربار عملیاتی**: سرویس‌های بیشتری برای deploy و monitor
- **چالش‌های سازگاری**: اطمینان از رفتار سازگار در BFFها
- **هزینه منابع**: نمونه‌های gateway متعدد هزینه زیرساخت را افزایش می‌دهند

## 7. API Gateway در مقابل Load Balancer در مقابل Reverse Proxy

| ویژگی | API Gateway | Load Balancer | Reverse Proxy |
|---------|-------------|---------------|---------------|
| **هدف اصلی** | مدیریت و مسیریابی API | توزیع ترافیک | forward کردن درخواست |
| **لایه OSI** | لایه 7 (Application) | لایه 4 (Transport) یا لایه 7 | لایه 7 (Application) |
| **منطق مسیریابی** | پیچیده (path, header, method) | ساده (IP, port) | متوسط (host, path) |
| **تبدیل پروتکل** | ✓ (HTTP↔gRPC, REST↔SOAP) | ✗ | محدود |
| **احراز هویت** | ✓ (JWT, OAuth, API keys) | ✗ | محدود |
| **Rate Limiting** | ✓ (per user/key/IP) | پایه (per connection) | پایه |
| **ادغام درخواست** | ✓ | ✗ | ✗ |
| **تبدیل پاسخ** | ✓ | ✗ | ✗ |
| **Caching** | ✓ (سطح application) | ✗ | ✓ (HTTP caching) |
| **نسخه‌بندی API** | ✓ | ✗ | محدود |
| **Analytics و Monitoring** | پیشرفته (API metrics) | پایه (health checks) | متوسط (access logs) |
| **Circuit Breaking** | ✓ | ✗ | محدود |
| **Service Discovery** | ✓ | محدود | محدود |
| **خاتمه SSL** | ✓ | ✓ | ✓ |
| **تأخیر** | بالاتر (پردازش بیشتر) | کمترین | کم |
| **مورد استفاده** | Microservices، APIهای عمومی | وب‌سایت‌های پرترافیک | وب سرورها، CDN origin |
| **مثال‌ها** | Kong, AWS API Gateway, Apigee | AWS ELB, NGINX, HAProxy | NGINX, Apache, Envoy |

### 7.1 چه زمانی از چه استفاده کنیم

```
┌─────────────────────────────────────────────────────────┐
│  Client Request                                         │
└───────────────────┬─────────────────────────────────────┘
                    │
                    ▼
          ┌─────────────────────┐
          │   Load Balancer     │  ← توزیع ترافیک
          │   (Layer 4)         │    در gatewayها
          └─────────┬───────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
┌────────────────┐      ┌────────────────┐
│  API Gateway   │      │  API Gateway   │  ← مدیریت API،
│   Instance 1   │      │   Instance 2   │    احراز هویت،
└───────┬────────┘      └───────┬────────┘    مسیریابی
        │                       │
        └───────────┬───────────┘
                    │
            ┌───────┴────────┐
            │                │
            ▼                ▼
    ┌──────────────┐  ┌──────────────┐
    │Service Pool A│  │Service Pool B│
    └──────┬───────┘  └──────┬───────┘
           │                 │
    ┌──────┴──┐       ┌──────┴──┐
    ▼         ▼       ▼         ▼
  ┌───┐     ┌───┐   ┌───┐     ┌───┐
  │S1 │     │S2 │   │S3 │     │S4 │  ← سرویس‌های Backend
  └───┘     └───┘   └───┘     └───┘
```

**ماتریس تصمیم:**

- **استفاده از Load Balancer**: زمانی که نیاز به توزیع ترافیک در نمونه‌های یکسان متعدد دارید
- **استفاده از Reverse Proxy**: زمانی که نیاز به forward کردن پایه درخواست و خاتمه SSL دارید
- **استفاده از API Gateway**: زمانی که نیاز به مدیریت API، احراز هویت، rate limiting و ترکیب درخواست دارید
- **استفاده از هر سه**: معماری‌های مقیاس بزرگ اغلب هر سه را در ترکیب استفاده می‌کنند

## 8. رویکردهای پیاده‌سازی

### 8.1 راه‌حل‌های Self-Hosted

#### 8.1.1 Kong

```
┌─────────────────────────────────────────────────────┐
│                Kong API Gateway                     │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │            اجزای اصلی                       │  │
│  │  • پراکسی مبتنی بر NGINX                    │  │
│  │  • سیستم plugin Lua                         │  │
│  │  • ذخیره‌سازی PostgreSQL/Cassandra          │  │
│  └─────────────────────────────────────────────┘  │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │            Pluginهای محبوب                  │  │
│  │  • Authentication (JWT, OAuth2, Basic)      │  │
│  │  • Rate Limiting (استراتژی‌های متعدد)      │  │
│  │  • Request/Response Transformation          │  │
│  │  • CORS, ACL, IP Restriction                │  │
│  │  • Logging (file, syslog, HTTP)             │  │
│  │  • Monitoring (Prometheus, Datadog)         │  │
│  └─────────────────────────────────────────────┘  │
│                                                     │
│  Admin API: localhost:8001                         │
│  Proxy: localhost:8000                             │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- Open-source با پشتیبانی تجاری
- اکوسیستم plugin غنی (50+ plugin رسمی)
- عملکرد بالا (مبتنی بر NGINX)
- بومی Kubernetes (Kong Ingress Controller)
- پیکربندی اعلانی (Declarative)

**نقاط ضعف:**

- وابستگی دیتابیس پیچیدگی اضافه می‌کند
- منحنی یادگیری Lua برای pluginهای سفارشی
- analytics داخلی محدود

#### 8.1.2 NGINX Plus

```
┌─────────────────────────────────────────────────────┐
│              NGINX Plus API Gateway                 │
│                                                     │
│  ویژگی‌های اصلی:                                   │
│  • reverse proxy با عملکرد بالا                    │
│  • load balancing پیشرفته                          │
│  • خاتمه SSL/TLS                                   │
│  • پشتیبانی HTTP/2، gRPC                           │
│  • پیکربندی مجدد پویا                              │
│  • بررسی سلامت فعال                                │
│  • احراز هویت JWT                                  │
│  • Rate limiting                                    │
│  • Content caching                                  │
│                                                     │
│  پیکربندی: nginx.conf                              │
│  API: /api/                                        │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- عملکرد بسیار بالا
- قابلیت اطمینان آزمایش‌شده
- ردپای منابع کم
- پیکربندی انعطاف‌پذیر
- پشتیبانی تجاری موجود

**نقاط ضعف:**

- پیچیدگی پیکربندی (developer-friendly نیست)
- ویژگی‌های محدود مدیریت API به صورت out-of-box
- نیاز به NGINX Plus برای ویژگی‌های پیشرفته

#### 8.1.3 Spring Cloud Gateway

```
┌─────────────────────────────────────────────────────┐
│         Spring Cloud Gateway (Java/Spring)          │
│                                                     │
│  ساخته شده بر:                                     │
│  • Spring WebFlux (reactive)                       │
│  • Project Reactor                                  │
│  • Netty                                            │
│                                                     │
│  ویژگی‌ها:                                         │
│  • Route predicates (path, method, header)         │
│  • Gateway filters (rate limit, retry, circuit)    │
│  • یکپارچگی با اکوسیستم Spring                     │
│  • Service discovery با Eureka                     │
│  • یکپارچگی Config Server                          │
│                                                     │
│  پیکربندی: YAML یا Java DSL                        │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- یکپارچگی بومی Java/Spring
- معماری Reactive و non-blocking
- آسان برای توسعه‌دهندگان Java
- یکپارچگی قوی اکوسیستم Spring
- پشتیبانی داخلی [Circuit Breaker](../resilience/circuit-breaker.fa.md)

**نقاط ضعف:**

- سربار JVM
- پشتیبانی محدود زبان (فقط Java)
- کمتر mature از Kong/NGINX

### 8.2 راه‌حل‌های Cloud-Managed

#### 8.2.1 AWS API Gateway

```
┌─────────────────────────────────────────────────────┐
│           AWS API Gateway                           │
│                                                     │
│  انواع:                                             │
│  ┌─────────────────────────────────────────────┐  │
│  │  REST API                                   │  │
│  │  • ویژگی‌های کامل مدیریت API                │  │
│  │  • تبدیل request/response                   │  │
│  │  • تولید SDK                                │  │
│  └─────────────────────────────────────────────┘  │
│  ┌─────────────────────────────────────────────┐  │
│  │  HTTP API                                   │  │
│  │  • هزینه کمتر (70% ارزان‌تر)                │  │
│  │  • تأخیر کمتر                               │  │
│  │  • مجموعه ویژگی‌های ساده‌تر                │  │
│  └─────────────────────────────────────────────┘  │
│  ┌─────────────────────────────────────────────┐  │
│  │  WebSocket API                              │  │
│  │  • ارتباط دوطرفه real-time                  │  │
│  │  • اتصالات پایدار                           │  │
│  └─────────────────────────────────────────────┘  │
│                                                     │
│  یکپارچگی‌ها:                                      │
│  • Lambda functions                                │
│  • HTTP endpoints                                  │
│  • سرویس‌های AWS (DynamoDB, SQS, S3)              │
│  • VPC Link (منابع خصوصی)                         │
│                                                     │
│  ویژگی‌ها:                                         │
│  • احراز هویت Cognito                              │
│  • یکپارچگی WAF                                    │
│  • لاگ‌گیری CloudWatch                             │
│  • ردیابی X-Ray                                   │
│  • Request throttling                              │
│  • API keys و usage plans                          │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- کاملاً managed (بدون زیرساخت)
- یکپارچگی بومی AWS
- Auto-scaling
- قیمت‌گذاری pay-per-use
- نظارت داخلی

**نقاط ضعف:**

- وابستگی به AWS
- تأخیر cold start (با Lambda)
- سفارشی‌سازی محدود
- هزینه می‌تواند در حجم بالا افزایش یابد

#### 8.2.2 Azure API Management

```
┌─────────────────────────────────────────────────────┐
│          Azure API Management                       │
│                                                     │
│  اجزا:                                              │
│  • API Gateway (مدیریت درخواست)                   │
│  • Management Plane (پیکربندی)                    │
│  • Developer Portal (مستندات)                     │
│  • Analytics (بینش‌ها)                             │
│                                                     │
│  ویژگی‌ها:                                         │
│  • پشتیبانی چندپروتکل (REST, SOAP, GraphQL)       │
│  • نسخه‌بندی و revisionهای API                    │
│  • تبدیلات مبتنی بر سیاست                          │
│  • OAuth 2.0، OpenID Connect                       │
│  • Rate limiting و quotas                          │
│  • Response caching                                │
│  • Mock responses                                  │
│  • گزینه Self-hosted gateway                       │
│                                                     │
│  سطوح: Developer, Basic, Standard, Premium        │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- پلتفرم جامع مدیریت API
- Developer portal از ابتدا
- استقرار ترکیبی (cloud + on-premises)
- موتور سیاست غنی
- ویژگی‌های قوی سازمانی

**نقاط ضعف:**

- وابستگی به Azure
- هزینه بالاتر از AWS API Gateway
- مدل قیمت‌گذاری پیچیده

#### 8.2.3 Google Cloud API Gateway

```
┌─────────────────────────────────────────────────────┐
│       Google Cloud API Gateway                      │
│                                                     │
│  • مبتنی بر OpenAPI/Swagger specification          │
│  • کاملاً managed                                   │
│  • backend با Cloud Endpoints                      │
│  • پشتیبانی Cloud Run, Cloud Functions, App Engine│
│  • احراز هویت: API keys, Firebase, Auth0          │
│  • یکپارچگی Cloud Armor (حفاظت DDoS)              │
│  • Cloud Logging و Monitoring                      │
│                                                     │
│  قیمت‌گذاری: به ازای میلیون فراخوانی API           │
└─────────────────────────────────────────────────────┘
```

**نقاط قوت:**

- ساده و developer-friendly
- رویکرد OpenAPI-first
- یکپارچگی خوب GCP
- قیمت‌گذاری رقابتی

**نقاط ضعف:**

- وابستگی به GCP
- ویژگی‌های محدود در مقابل Azure/AWS
- ارائه جدیدتر (کمتر mature)

### 8.3 یکپارچگی Service Mesh

#### 8.3.1 Istio + Envoy

```
┌─────────────────────────────────────────────────────┐
│         Service Mesh (Istio) + API Gateway          │
│                                                     │
│  ترافیک خارجی:                                      │
│  Client → Istio Ingress Gateway (Envoy)            │
│                    │                                │
│                    ▼                                │
│         ┌──────────────────────┐                   │
│         │   Service Mesh       │                   │
│         │   (ترافیک داخلی)     │                   │
│         │                      │                   │
│         │   Service A ←→ Envoy │                   │
│         │   Service B ←→ Envoy │                   │
│         │   Service C ←→ Envoy │                   │
│         └──────────────────────┘                   │
│                                                     │
│  ویژگی‌ها:                                         │
│  • mTLS بین سرویس‌ها                               │
│  • مسیریابی پیشرفته (canary, A/B)                 │
│  • retryهای خودکار و circuit breaking              │
│  • ردیابی توزیع‌شده                                │
│  • Traffic mirroring                               │
└─────────────────────────────────────────────────────┘
```

**مورد استفاده**: محیط‌های Kubernetes نیازمند API Gateway و مدیریت ارتباط service-to-service

### 8.4 ماتریس مقایسه

| راه‌حل | استقرار | هزینه | عملکرد | ویژگی‌ها | منحنی یادگیری |
|----------|-----------|------|-------------|----------|----------------|
| **Kong** | Self-hosted | کم | بسیار بالا | عالی | متوسط |
| **NGINX Plus** | Self-hosted | متوسط | بالاترین | خوب | بالا |
| **Spring Cloud Gateway** | Self-hosted | کم | بالا | خوب | متوسط |
| **AWS API Gateway** | Managed | Pay-per-use | بالا | عالی | کم |
| **Azure API Management** | Managed/Hybrid | بالا | بالا | عالی | متوسط |
| **GCP API Gateway** | Managed | Pay-per-use | بالا | خوب | کم |
| **Istio/Envoy** | Self-hosted | متوسط | بسیار بالا | عالی | بسیار بالا |

## 9. مزایا و معایب و ملاحظات

### 9.1 مزایا

```
✓ یکپارچگی ساده کلاینت
  • نقطه پایانی واحد برای همه سرویس‌ها
  • قرارداد API سازگار
  • انتزاع پروتکل

✓ امنیت متمرکز
  • احراز هویت/مجوزدهی در یک مکان
  • سیاست‌های امنیتی سازگار
  • ممیزی انطباق آسان‌تر

✓ کاهش جفت‌شدگی سرویس
  • کلاینت‌ها به توپولوژی سرویس وابسته نیستند
  • سرویس‌ها می‌توانند به صورت مستقل refactor شوند
  • نسخه‌بندی سرویس آسان‌تر

✓ مسئولیت‌های مشترک
  • عدم تکرار منطق مشترک
  • رفتار سازگار در سرویس‌ها
  • به‌روزرسانی سیاست‌ها آسان‌تر

✓ بهبود مشاهده‌پذیری
  • لاگ‌گیری و نظارت متمرکز
  • ردیابی درخواست در سرویس‌ها
  • تحلیل API در یک مکان

✓ بهینه‌سازی عملکرد
  • Response caching
  • ادغام درخواست round tripها را کاهش می‌دهد
  • بهینه‌سازی پروتکل (HTTP/2, gRPC)
```

### 9.2 معایب

```
✗ نقطه واحد شکست
  • خرابی gateway تمام سرویس‌ها را تحت تأثیر قرار می‌دهد
  • نیاز به تنظیم high availability
  • کاهش: نمونه‌های متعدد، load balancing

✗ تأخیر اضافی
  • hop شبکه اضافی
  • سربار پردازش (auth, transformation)
  • معمولاً: 5-20ms تأخیر اضافی

✗ گلوگاه احتمالی
  • تمام ترافیک از gateway عبور می‌کند
  • باید به طور مناسب مقیاس‌بندی شود
  • می‌تواند محدودیت عملکرد شود

✗ افزایش پیچیدگی
  • component دیگری برای deploy و مدیریت
  • چالش‌های مدیریت پیکربندی
  • نیاز به تخصص عملیاتی

✗ گلوگاه توسعه
  • تغییرات ممکن است نیاز به به‌روزرسانی gateway داشته باشند
  • مشکل مالکیت تیم واحد احتمالی
  • می‌تواند تحویل ویژگی را کند کند

✗ وابستگی به vendor (راه‌حل‌های Managed)
  • ویژگی‌های خاص cloud
  • پیچیدگی مهاجرت
  • فرمت‌های پیکربندی اختصاصی
```

### 9.3 کاهش نقطه واحد شکست

```
┌─────────────────────────────────────────────────────┐
│              تنظیم High Availability                │
│                                                     │
│                  ┌──────────────┐                  │
│      ┌──────────▶│Load Balancer │◀──────────┐     │
│      │           │  (Layer 4)   │           │     │
│      │           └──────────────┘           │     │
│      │                                      │     │
│      ▼                                      ▼     │
│ ┌──────────┐                          ┌──────────┐│
│ │   API    │                          │   API    ││
│ │ Gateway  │                          │ Gateway  ││
│ │Instance 1│                          │Instance 2││
│ │(Active)  │                          │(Active)  ││
│ └────┬─────┘                          └─────┬────┘│
│      │                                      │     │
│      │      ┌──────────────────┐           │     │
│      └─────▶│  Shared Cache    │◀──────────┘     │
│              │  (Redis Cluster) │                 │
│              └──────────────────┘                 │
│                                                     │
│  • بررسی سلامت (هر 5s)                             │
│  • Failover خودکار                                │
│  • خاموشی graceful                                 │
│  • Circuit breaker به backendها                   │
│  • Rate limiting با وضعیت توزیع‌شده               │
└─────────────────────────────────────────────────────┘
```

**استراتژی‌ها:**

1. **نمونه‌های متعدد**: استقرار gateway در availability zoneها
2. **بررسی سلامت**: نظارت مداوم با failover خودکار
3. **Circuit Breaker**: جلوگیری از شکست‌های آبشاری (نگاه کنید [الگوی Circuit Breaker](../resilience/circuit-breaker.fa.md))
4. **Degradation تدریجی**: سرویس cache قدیمی هنگام شکست backendها
5. **Chaos Engineering**: تست منظم سناریوهای شکست

### 9.4 ملاحظات عملکرد

```
تجزیه تأخیر:

┌────────────────────────────────────────┐
│ زمان کل درخواست: 100ms                │
│                                        │
│ ┌────────────────────────────────────┐ │
│ │ سربار API Gateway: 15ms            │ │
│ │ ├─ SSL/TLS: 5ms                    │ │
│ │ ├─ احراز هویت: 3ms                │ │
│ │ ├─ Rate Limiting: 1ms              │ │
│ │ ├─ تصمیم مسیریابی: 1ms            │ │
│ │ ├─ تبدیل درخواست: 2ms             │ │
│ │ └─ لاگ‌گیری: 3ms                   │ │
│ └────────────────────────────────────┘ │
│                                        │
│ ┌────────────────────────────────────┐ │
│ │ شبکه: 10ms                         │ │
│ │ Gateway → Backend                  │ │
│ └────────────────────────────────────┘ │
│                                        │
│ ┌────────────────────────────────────┐ │
│ │ پردازش Backend: 75ms               │ │
│ │ (منطق کسب‌وکار، دیتابیس)          │ │
│ └────────────────────────────────────┘ │
└────────────────────────────────────────┘
```

**استراتژی‌های بهینه‌سازی:**

| استراتژی | تأثیر | پیچیدگی |
|----------|--------|------------|
| Response Caching | بالا (اجتناب از فراخوانی backend) | کم |
| Connection Pooling | متوسط (کاهش سربار اتصال) | کم |
| Request Batching | بالا (کاهش round tripها) | متوسط |
| Async Processing | متوسط (non-blocking I/O) | متوسط |
| Edge Deployment | بالا (کاهش تأخیر شبکه) | بالا |
| بهینه‌سازی پروتکل (HTTP/2) | متوسط (multiplexing) | کم |
| فشرده‌سازی | متوسط (کاهش پهنای باند) | کم |

### 9.5 استراتژی‌های مقیاس‌بندی

```
مقیاس‌بندی عمودی:
┌──────────┐         ┌──────────┐
│ Gateway  │  ──▶    │ Gateway  │
│ 2 CPU    │         │ 8 CPU    │
│ 4GB RAM  │         │ 16GB RAM │
└──────────┘         └──────────┘
مزایا: ساده، بدون تغییر معماری
معایب: محدود، گران، نقطه واحد شکست

مقیاس‌بندی افقی:
┌──────────┐         ┌──────────┐  ┌──────────┐  ┌──────────┐
│ Gateway  │  ──▶    │ Gateway  │  │ Gateway  │  │ Gateway  │
│          │         │Instance 1│  │Instance 2│  │Instance 3│
└──────────┘         └──────────┘  └──────────┘  └──────────┘
مزایا: مقیاس نامحدود، افزونگی، مقرون‌به‌صرفه
معایب: نیاز به load balancer، طراحی stateless

توزیع منطقه‌ای:
        ┌──────────────────────────────────┐
        │        Global Load Balancer      │
        │        (GeoDNS/Anycast)          │
        └──────┬───────────────────┬───────┘
               │                   │
        ┌──────▼──────┐     ┌──────▼──────┐
        │   US East   │     │  EU West    │
        │  Gateway    │     │  Gateway    │
        │  Cluster    │     │  Cluster    │
        └─────────────┘     └─────────────┘
مزایا: تأخیر کم در سراسر جهان، بازیابی فاجعه
معایب: پیچیده، چالش‌های سازگاری، هزینه بالاتر
```

## 10. الگوهای مرتبط

الگوی API Gateway در ارتباط با الگوهای معماری دیگر کار می‌کند:

### 10.1 معماری Microservices

API Gateway یک جزء اساسی [معماری‌های microservices](microservices.fa.md) است و نقطه ورود به یک سیستم توزیع‌شده از سرویس‌ها را فراهم می‌کند.

### 10.2 Circuit Breaker

API Gatewayها اغلب [الگوی Circuit Breaker](../resilience/circuit-breaker.fa.md) را برای جلوگیری از شکست‌های آبشاری هنگام ناسالم بودن سرویس‌های backend پیاده‌سازی می‌کنند.

```
┌─────────────────────────────────────┐
│      API Gateway                    │
│  ┌───────────────────────────────┐ │
│  │  Circuit Breaker               │ │
│  │  وضعیت: OPEN                   │ │
│  │  درخواست‌های ناموفق: 15/20     │ │
│  │  آخرین شکست: 2s پیش            │ │
│  │                                │ │
│  │  اقدام: بازگشت پاسخ            │ │
│  │          cached یا خطا          │ │
│  └───────────────────────────────┘ │
└──────────────┬──────────────────────┘
               │
               ✗ (فراخوانی نشود)
               │
        ┌──────▼────────┐
        │   Unhealthy   │
        │    Backend    │
        │   Service     │
        └───────────────┘
```

### 10.3 معماری Event-Driven

API Gatewayها می‌توانند با [معماری‌های event-driven](../event-driven/event-driven-architecture.fa.md) یکپارچه شوند و هنگامی که فراخوانی‌های خاص API انجام می‌شود رویدادها را منتشر کنند.

### 10.4 الگوی Saga

برای تراکنش‌های طولانی که چندین سرویس را در بر می‌گیرند، API Gateway می‌تواند [الگوی Saga](../distributed-transactions/saga.fa.md) را هماهنگ کند.

### 10.5 CQRS

API Gatewayها می‌توانند query های خواندن را به سرویس‌های بهینه‌شده برای خواندن و دستورات نوشتن را به سرویس‌های بهینه‌شده برای نوشتن در یک معماری CQRS مسیریابی کنند.

### 10.6 Strangler Fig

در طول مهاجرت از monolith به microservices، API Gateway الگوی Strangler Fig را با مسیریابی درخواست‌ها به سرویس‌های legacy یا جدید امکان‌پذیر می‌کند.

```
┌─────────────────────────────────────┐
│         API Gateway                 │
│  ┌───────────────────────────────┐ │
│  │  قوانین مسیریابی:             │ │
│  │  /new/feature → Microservice  │ │
│  │  /legacy/*    → Monolith      │ │
│  └───────────────────────────────┘ │
└──────────┬──────────────────────────┘
           │
    ┌──────┴───────┐
    │              │
    ▼              ▼
┌─────────┐  ┌──────────────┐
│  New    │  │   Legacy     │
│Micro    │  │   Monolith   │
│Services │  │ (در حال حذف) │
│         │  │              │
└─────────┘  └──────────────┘
```

### 10.7 معماری Serverless

API Gatewayها در [معماری‌های serverless](serverless.fa.md) ضروری هستند و درخواست‌ها را به توابع serverless (AWS Lambda، Azure Functions و غیره) مسیریابی می‌کنند.

## 11. مثال‌های دنیای واقعی

### 11.1 Netflix - Zuul

Netflix، Zuul را توسعه داد، سرویس edge خود که مسیریابی پویا، نظارت، انعطاف‌پذیری و امنیت را فراهم می‌کند.

```
┌─────────────────────────────────────────────────────┐
│             معماری Netflix Zuul                     │
│                                                     │
│  Client → [AWS ELB] → [Zuul] → Backend Services    │
│                                                     │
│  ویژگی‌های Zuul:                                   │
│  • مسیریابی پویا                                    │
│  • شکل‌دهی ترافیک                                  │
│  • احراز هویت و امنیت درخواست                      │
│  • بینش‌ها و نظارت                                │
│  • تست استرس                                       │
│  • تست canary                                      │
│  • انعطاف‌پذیری چندمنطقه‌ای                        │
│                                                     │
│  تکامل:                                             │
│  Zuul 1 (Blocking I/O) → Zuul 2 (Async/Non-blocking)│
│                                                     │
│  مقیاس: مدیریت میلیاردها درخواست در روز            │
└─────────────────────────────────────────────────────┘
```

**بینش‌های کلیدی:**

- **مسیریابی پویا**: مسیریابی درخواست‌ها بر اساس معیارهای مختلف (کاربر، دستگاه، منطقه)
- **Chaos Engineering**: تزریق شکست داخلی برای تست
- **چندمنطقه‌ای**: مدیریت failover بین مناطق AWS
- **نظارت**: متریک‌ها و ردیابی توزیع‌شده گسترده

**Netflix بعداً به Spring Cloud Gateway منتقل شد** برای پشتیبانی Reactive و عملکرد بهتر.

### 11.2 Amazon - AWS API Gateway

Amazon از API Gateway برای افشای سرویس‌های AWS و توابع Lambda استفاده می‌کند.

```
┌─────────────────────────────────────────────────────┐
│          موارد استفاده AWS API Gateway              │
│                                                     │
│  1. Backendهای Serverless                         │
│     Client → API Gateway → Lambda → DynamoDB       │
│                                                     │
│  2. مدرن‌سازی Legacy                               │
│     Mobile → API Gateway → { Lambda (new)          │
│                            { EC2 (legacy)          │
│                                                     │
│  3. نمای Microservices                             │
│     API Gateway → { User Service (ECS)             │
│                   { Order Service (EKS)            │
│                   { Payment Service (Lambda)       │
│                                                     │
│  4. درآمدزایی API شخص ثالث                        │
│     Partner → API Gateway → Usage Plans → Billing  │
└─────────────────────────────────────────────────────┘
```

**ویژگی‌های کلیدی استفاده‌شده:**

- **یکپارچگی Lambda**: backend serverless یکپارچه
- **API Keys و Usage Plans**: درآمدزایی و rate limiting
- **اعتبارسنجی درخواست**: اعتبارسنجی schema قبل از رسیدن به backend
- **تولید SDK**: SDKهای کلاینت تولید خودکار

### 11.3 Uber - API Gateway برای Microservices

Uber از API Gateway برای مدیریت هزاران microservices استفاده می‌کند.

```
┌─────────────────────────────────────────────────────┐
│            Uber API Gateway                         │
│                                                     │
│  چالش‌ها:                                          │
│  • 2000+ microservices                             │
│  • چندین زبان برنامه‌نویسی                         │
│  • حجم درخواست بالا                                │
│  • نیازهای تأخیر کم                                │
│                                                     │
│  راه‌حل‌ها:                                         │
│  • gateway ساخته‌شده سفارشی (اختصاصی)              │
│  • تبدیل پروتکل (HTTP ↔ Thrift)                   │
│  • مسیریابی هوشمند                                 │
│  • load balancing پیشرفته                          │
│  • شکل‌دهی ترافیک real-time                        │
│  • Circuit breaking و retryها                     │
│                                                     │
│  نتایج:                                             │
│  • تأخیر gateway زیر میلی‌ثانیه                    │
│  • مدیریت میلیون‌ها درخواست در ثانیه              │
│  • امکان توسعه سریع سرویس                          │
└─────────────────────────────────────────────────────┘
```

### 11.4 Spotify - API Gateway با GraphQL

Spotify از API Gateway با GraphQL برای ارائه یک API انعطاف‌پذیر به کلاینت‌ها استفاده می‌کند.

```
┌─────────────────────────────────────────────────────┐
│         معماری API Spotify                         │
│                                                     │
│  Client (Mobile/Web)                               │
│       │                                             │
│       ▼                                             │
│  ┌─────────────────┐                               │
│  │  API Gateway    │                               │
│  │  (GraphQL)      │                               │
│  └────────┬────────┘                               │
│           │                                         │
│    ┌──────┼──────┬──────┬──────┐                  │
│    ▼      ▼      ▼      ▼      ▼                  │
│  User  Playlist Track  Album  Artist              │
│  Svc    Svc     Svc    Svc    Svc                 │
│                                                     │
│  مزایا:                                             │
│  • کلاینت‌ها دقیقاً آنچه نیاز دارند درخواست می‌کنند│
│  • کاهش over-fetching                              │
│  • یک round trip برای query‌های پیچیده            │
│  • schema با تایپ قوی                              │
└─────────────────────────────────────────────────────┘
```

### 11.5 Twitter - Edge API

Twitter از یک لایه edge API برای مدیریت درخواست‌های کلاینت استفاده می‌کند.

```
┌─────────────────────────────────────────────────────┐
│           Twitter Edge API                          │
│                                                     │
│  مسئولیت‌ها:                                        │
│  • احراز هویت (OAuth)                              │
│  • Rate limiting (per user, per endpoint)          │
│  • Response caching                                │
│  • مسیریابی درخواست                                │
│  • تبدیل پروتکل                                    │
│  • تست A/B                                         │
│  • Feature flags                                   │
│                                                     │
│  تکنولوژی‌ها:                                      │
│  • gateway سفارشی مبتنی بر Scala                   │
│  • Finagle (فریم‌ورک RPC)                          │
│  • ردیابی توزیع‌شده با Zipkin                      │
│                                                     │
│  مقیاس:                                             │
│  • مدیریت صدها هزار req/sec                        │
│  • تأخیر زیر 50ms در P99                           │
└─────────────────────────────────────────────────────┘
```

## 12. چارچوب مصاحبه و نکات کلیدی

### 12.1 هنگام بحث درباره API Gateway در مصاحبه‌ها

**با مسئله شروع کنید:**

- "در یک معماری microservices با 50+ سرویس، فراخوانی مستقیم هر سرویس توسط کلاینت‌ها چندین مشکل ایجاد می‌کند: جفت‌شدگی محکم، round tripهای متعدد، منطق امنیتی تکراری و کد پیچیده کلاینت."

**راه‌حل را توضیح دهید:**

- "یک API Gateway یک نقطه ورود واحد ارائه می‌دهد که مسیریابی، احراز هویت، rate limiting و ادغام را مدیریت می‌کند. کلاینت‌ها را از سرویس‌های backend جدا می‌کند."

**مزایا و معایب را بحث کنید:**

- "در حالی که یکپارچگی کلاینت را ساده می‌کند و مسئولیت‌های مشترک را متمرکز می‌کند، یک hop شبکه اضافی معرفی می‌کند و می‌تواند به نقطه واحد شکست تبدیل شود. ما با نمونه‌های متعدد، بررسی سلامت و circuit breakerها این را کاهش می‌دهیم."

**مثال‌های واقعی ارائه دهید:**

- "Netflix از Zuul/Spring Cloud Gateway برای مسیریابی ترافیک به هزاران سرویس backend استفاده می‌کند. AWS API Gateway معماری‌های serverless با Lambda را امکان‌پذیر می‌کند."

### 12.2 سوالات متداول مصاحبه

**Q: API Gateway با Load Balancer چه تفاوتی دارد؟**

A: یک Load Balancer در لایه 4 (TCP) یا لایه 7 (HTTP) کار می‌کند و ترافیک را بین نمونه‌های یکسان توزیع می‌کند. یک API Gateway در لایه 7 کار می‌کند و ویژگی‌های مدیریت API مانند احراز هویت، rate limiting، ادغام درخواست و تبدیل پروتکل ارائه می‌دهد. اغلب هر دو را استفاده می‌کنید: یک Load Balancer ترافیک را بین نمونه‌های متعدد API Gateway توزیع می‌کند.

**Q: چگونه احراز هویت را در API Gateway مدیریت می‌کنید؟**

A: gateway در هر درخواست tokenها (JWT، OAuth) را اعتبارسنجی می‌کند، user context را استخراج می‌کند، دسترسی‌ها را بررسی می‌کند و درخواست‌های احراز شده را با metadata کاربر در headerها به سرویس‌های backend forward می‌کند. سرویس‌های backend به gateway اعتماد می‌کنند و مجدداً احراز هویت نمی‌کنند. این منطق امنیتی را متمرکز می‌کند و تکرار را کاهش می‌دهد.

**Q: اگر API Gateway خراب شود چه اتفاقی می‌افتد؟**

A: این نگرانی نقطه واحد شکست است. استراتژی‌های کاهش شامل:

- استقرار نمونه‌های متعدد gateway پشت load balancer
- استفاده از بررسی سلامت با failover خودکار
- پیاده‌سازی circuit breakerها برای جلوگیری از شکست‌های آبشاری
- استقرار در چندین availability zone
- در نظر گرفتن توزیع منطقه‌ای برای بازیابی فاجعه

**Q: چگونه نسخه‌بندی را با API Gateway مدیریت می‌کنید؟**

A: رویکردهای متداول:

- مبتنی بر URL: `/v1/users`، `/v2/users`
- مبتنی بر Header: `Accept: application/vnd.api+json;version=2`
- مسیریابی Gateway: مسیریابی بر اساس نسخه به سرویس‌های مختلف backend
- مهاجرت تدریجی: استفاده از gateway برای مسیریابی درصدی از ترافیک به نسخه جدید (استقرار canary)

**Q: API Gateway چگونه بر تأخیر تأثیر می‌گذارد؟**

A: 5-20ms سربار برای احراز هویت، مسیریابی و تبدیل اضافه می‌کند. این معمولاً قابل قبول است زیرا:

- ادغام درخواست کل round tripها را کاهش می‌دهد
- Caching می‌تواند فراخوانی‌های backend را به طور کامل حذف کند
- ساده‌سازی سرویس‌های backend اغلب عملکرد آنها را بهبود می‌بخشد
- بهینه‌سازی پروتکل (HTTP/2، فشرده‌سازی) می‌تواند سربار را جبران کند

**Q: چه زمانی از API Gateway استفاده نکنید؟**

A: جایگزین‌ها را در نظر بگیرید وقتی:

- یک برنامه monolithic ساده دارید (over-engineering)
- ارتباط داخلی service-to-service (به جای آن از service mesh استفاده کنید)
- نیازهای تأخیر فوق‌العاده کم که هر میلی‌ثانیه مهم است
- مقیاس بسیار کوچک که پیچیدگی عملیاتی از مزایا بیشتر است

### 12.3 نکات کلیدی

1. **API Gateway = نقطه ورود واحد**: تمام درخواست‌های خارجی از gateway عبور می‌کنند که به سرویس‌های مناسب backend مسیریابی می‌کند.

2. **مسئولیت‌های مشترک**: احراز هویت، rate limiting، لاگ‌گیری، caching و خاتمه SSL را متمرکز می‌کند و تکرار را از سرویس‌های backend حذف می‌کند.

3. **ادغام درخواست**: می‌تواند چندین فراخوانی backend را در یک درخواست کلاینت واحد ترکیب کند، round tripها را کاهش می‌دهد و عملکرد موبایل را بهبود می‌بخشد.

4. **تبدیل پروتکل**: بین پروتکل‌های مختلف پل می‌زند (REST ↔ gRPC، HTTP ↔ WebSocket)، اجازه می‌دهد backendها از پروتکل‌های بهینه استفاده کنند.

5. **الگوی BFF**: gatewayهای جداگانه را برای انواع مختلف کلاینت (وب، موبایل، شرکا) برای بهینه‌سازی برای نیازهای خاص در نظر بگیرید.

6. **نه فقط Reverse Proxy**: در حالی که شامل عملکرد reverse proxy است، قابلیت‌های مدیریت API بسیار غنی‌تری ارائه می‌دهد.

7. **مزایا و معایب: سادگی در مقابل پیچیدگی**: یکپارچگی کلاینت را ساده می‌کند اما پیچیدگی عملیاتی و نقطه واحد شکست احتمالی اضافه می‌کند.

8. **گزینه‌های پیاده‌سازی**: بین self-hosted (Kong، NGINX)، cloud-managed (AWS، Azure) یا service mesh (Istio) بر اساس نیازها انتخاب کنید.

9. **ملاحظات عملکرد**: تأخیر اضافه می‌کند اما می‌تواند عملکرد کلی را از طریق caching، ادغام و connection pooling بهبود بخشد.

10. **ضروری برای Microservices**: در یک معماری microservices با ده‌ها یا صدها سرویس، یک API Gateway عملاً برای یکپارچگی کلاینت قابل مدیریت ضروری است.

11. **مرز امنیتی**: به عنوان محیط امنیتی عمل می‌کند، تمام درخواست‌های خارجی را قبل از رسیدن به سرویس‌های داخلی احراز هویت می‌کند.

12. **الگوهای انعطاف‌پذیری**: circuit breaker، retryها، timeoutها و rate limiting را پیاده‌سازی کنید تا هم gateway و هم سرویس‌های backend را محافظت کنید.

13. **مشاهده‌پذیری**: یک نقطه متمرکز برای لاگ‌گیری، نظارت و ردیابی توزیع‌شده در تمام فراخوانی‌های API فراهم می‌کند.

14. **مسیر تکامل**: با مسیریابی پایه ساده شروع کنید، سپس ویژگی‌ها را به صورت تدریجی با رشد نیازها اضافه کنید (احراز هویت → rate limiting → caching → ادغام).

15. **الگوهای مکمل**: با Circuit Breaker، Microservices، Event-Driven Architecture، Saga Pattern و Serverless برای ساخت سیستم‌های توزیع‌شده قوی کار می‌کند.

---

**موضوعات مرتبط:**

- [معماری Microservices](microservices.fa.md)
- [الگوی Circuit Breaker](../resilience/circuit-breaker.fa.md)
- [قضیه CAP](../fundamentals/cap-theorem.fa.md) - درک مزایا و معایب سیستم توزیع‌شده
- [الگوی Saga](../distributed-transactions/saga.fa.md) - تراکنش‌های توزیع‌شده
- [معماری Event-Driven](../event-driven/event-driven-architecture.fa.md)
- [معماری Serverless](serverless.fa.md)
- [صف‌های پیام: RabbitMQ در مقابل Kafka](../messaging/rabbitmq-vs-kafka.fa.md)

**منابع:**

- "Building Microservices" نوشته Sam Newman (فصل API Gateway)
- "System Design Interview" نوشته Alex Xu (بخش API Gateway)
- وبلاگ فنی Netflix: Zuul gateway
- مستندات AWS API Gateway
- مستندات Kong Gateway
- Martin Fowler: "Gateway Aggregation Pattern"
