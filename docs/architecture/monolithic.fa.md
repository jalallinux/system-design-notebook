# معماری Monolithic

## 1. مقدمه

**معماری Monolithic** یک سبک معماری نرم‌افزاری سنتی است که در آن کل اپلیکیشن به عنوان یک واحد یکپارچه و غیرقابل تفکیک ساخته و مستقر می‌شود. تمام کامپوننت‌ها — رابط کاربری، منطق کسب‌وکار، دسترسی به داده و پردازش‌های پس‌زمینه — با هم بسته‌بندی شده و به عنوان یک پروسس اجرا می‌شوند.

### منشا و زمینه تاریخی

معماری Monolithic **قدیمی‌ترین و طبیعی‌ترین** روش برای ساخت نرم‌افزار است. قبل از ظهور [معماری Microservices](./microservices.fa.md) در دهه 2010، عملاً هر اپلیکیشنی یک monolith بود. شرکت‌هایی مانند eBay، Twitter، Netflix و Amazon همگی به عنوان اپلیکیشن‌های monolithic شروع کردند و سپس با رشد مقیاس، به معماری‌های توزیع‌شده مهاجرت کردند.

اصطلاح "monolith" معنای مدرن خود را عمدتاً به عنوان تقابل با microservices به دست آورد. با این حال، معماری monolithic همچنان یک رویکرد **معتبر و اغلب ترجیح‌داده‌شده** برای بسیاری از اپلیکیشن‌ها باقی مانده است، به ویژه در مراحل اولیه چرخه حیات محصول.

### ایده اصلی

> یک اپلیکیشن monolithic یک واحد قابل استقرار واحد است که تمام عملکرد اپلیکیشن — UI، منطق کسب‌وکار و دسترسی به داده — را در یک codebase، یک پروسس و یک خط لوله استقرار در بر می‌گیرد.

**مفهوم کلیدی:**
Martin Fowler از استراتژی **"Monolith First"** حمایت می‌کند — با یک monolith شروع کنید تا دامنه را درک کنید، سپس فقط زمانی به [microservices](./microservices.fa.md) تجزیه کنید که پیچیدگی و نیازهای مقیاس‌پذیری آن را توجیه کنند.

---

## 2. زمینه و مشکل

### مشکلی که Monolithها حل می‌کنند

هنگام ساخت یک اپلیکیشن جدید، تیم‌ها با تصمیمات معماری بنیادی مواجه می‌شوند:

- codebase چگونه باید سازمان‌دهی شود؟
- کامپوننت‌ها چگونه باید با هم ارتباط برقرار کنند؟
- اپلیکیشن چگونه باید مستقر شود؟
- اپلیکیشن چگونه باید مقیاس یابد؟

معماری Monolithic به این سوالات با **سادگی** پاسخ می‌دهد: همه چیز در یک جا، ارتباط از طریق فراخوانی توابع درون‌پروسسی، مستقر شده به عنوان یک artifact واحد.

### زمانی که سادگی برنده است

برای بسیاری از سناریوها، سربار سیستم‌های توزیع‌شده توجیه ندارد:

- **استارتاپ‌های مرحله اولیه** نیاز به تکرار سریع و اعتبارسنجی ایده‌های کسب‌وکار دارند
- **تیم‌های کوچک** (کمتر از 10 توسعه‌دهنده) از سربار هماهنگی کم بهره می‌برند
- **دامنه‌های ساده** نیاز به الگوهای معماری پیچیده ندارند
- **MVPها و نمونه‌های اولیه** به زمان سریع رسیدن به بازار نیاز دارند
- **ابزارهای داخلی** به تعداد محدودی کاربر با نیازهای مقیاس‌پذیری متوسط خدمت می‌رسانند

هزینه تجزیه زودهنگام به [microservices](./microservices.fa.md) می‌تواند شدید باشد: افزایش پیچیدگی عملیاتی، چالش‌های debugging سیستم توزیع‌شده و کاهش سرعت توسعه زمانی که تیم و محصول آماده نیستند.

---

## 3. نیروها (Forces)

نیروهای مختلفی به سمت یا بر ضد معماری monolithic فشار می‌آورند:

| نیرو | فشار به سمت Monolith | فشار به دور از Monolith |
|------|---------------------|------------------------|
| **اندازه تیم** | تیم کوچک (< 10 نفر) | سازمان بزرگ (50+ نفر) |
| **پیچیدگی دامنه** | دامنه ساده و شناخته‌شده | دامنه پیچیده با چندین bounded context |
| **نیازهای مقیاس‌پذیری** | مقیاس‌پذیری یکنواخت | کامپوننت‌های مختلف نیاز به مقیاس متفاوت دارند |
| **سرعت استقرار** | استقرار واحد کافی است | استقرارهای مستقل مورد نیاز |
| **نیازهای تکنولوژی** | یک technology stack کافی است | مشکلات مختلف نیاز به ابزارهای مختلف دارند |
| **زمان رسیدن به بازار** | نیاز به ارسال سریع | نیاز به تکرار مستقل |
| **سازگاری** | تراکنش‌های ACID مورد نیاز | سازگاری نهایی قابل قبول |
| **بودجه** | بودجه زیرساخت محدود | می‌تواند در DevOps و ابزار سرمایه‌گذاری کند |

---

## 4. راه‌حل

### ساختار Monolithic

یک اپلیکیشن monolithic تمام عملکرد را در یک واحد قابل استقرار واحد بسته‌بندی می‌کند:

```
┌───────────────────────────────────────────────────────────┐
│                 MONOLITHIC APPLICATION                     │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Presentation Layer                      │ │
│  │  (Web UI, REST API, GraphQL)                        │ │
│  └──────────────────────┬──────────────────────────────┘ │
│                         │                                 │
│  ┌──────────────────────▼──────────────────────────────┐ │
│  │              Business Logic Layer                    │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │ │
│  │  │  Users   │  │  Orders  │  │ Payments │          │ │
│  │  │  Module  │  │  Module  │  │  Module  │          │ │
│  │  └──────────┘  └──────────┘  └──────────┘          │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │ │
│  │  │Inventory │  │ Reports  │  │  Notif.  │          │ │
│  │  │  Module  │  │  Module  │  │  Module  │          │ │
│  │  └──────────┘  └──────────┘  └──────────┘          │ │
│  └──────────────────────┬──────────────────────────────┘ │
│                         │                                 │
│  ┌──────────────────────▼──────────────────────────────┐ │
│  │              Data Access Layer                       │ │
│  │  (ORM, Repositories, Query Builders)                │ │
│  └──────────────────────┬──────────────────────────────┘ │
│                         │                                 │
│  ┌──────────────────────▼──────────────────────────────┐ │
│  │              Single Database                         │ │
│  │  (PostgreSQL, MySQL, SQL Server)                    │ │
│  └─────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────┘
                  واحد استقرار واحد
```

**ویژگی‌ها:**

- **Codebase واحد**: تمام کد منبع در یک مخزن
- **پروسس واحد**: به عنوان یک پروسس سیستم‌عامل اجرا می‌شود (یا مجموعه کوچکی از پروسس‌ها)
- **پایگاه داده واحد**: یک پایگاه داده مشترک برای تمام ماژول‌ها
- **استقرار واحد**: یک artifact ساخته شده و به صورت اتمیک مستقر می‌شود
- **ارتباط درون‌پروسسی**: ماژول‌ها از طریق فراخوانی تابع/متد با هم ارتباط برقرار می‌کنند

### انواع Monolith

همه monolithها یکسان نیستند. سه نوع متمایز وجود دارد:

#### نوع 1: Single Process Monolith (کلاسیک)

رایج‌ترین نوع — تمام کد در یک پروسس واحد با حداقل ساختار داخلی اجرا می‌شود.

```
┌──────────────────────────────────────┐
│       Single Process Monolith        │
│                                      │
│  ┌────────────────────────────────┐ │
│  │   تمام کدها با هم مخلوط       │ │
│  │                                │ │
│  │   Controllers ←→ Services     │ │
│  │        ↕              ↕        │ │
│  │   Models    ←→   Helpers      │ │
│  │        ↕              ↕        │ │
│  │   Repositories ←→ Utilities   │ │
│  │                                │ │
│  │   (بدون مرزهای واضح ماژول)    │ │
│  └────────────────────────────────┘ │
│              ↓                       │
│  ┌────────────────────┐             │
│  │  Shared Database   │             │
│  └────────────────────┘             │
└──────────────────────────────────────┘
```

**ویژگی‌ها:**
- شروع سریع ساخت
- کد با گذشت زمان درهم‌تنیده می‌شود ("توپ بزرگ گلی")
- با افزایش پیچیدگی استدلال درباره آن دشوار می‌شود
- ریسک بالای عوارض جانبی ناخواسته از تغییرات

#### نوع 2: Modular Monolith (رویکرد مدرن)

یک monolith با ساختار مناسب با **مرزهای ماژول واضح** و رابط‌های تعریف‌شده بین ماژول‌ها. این رویکرد مدرن توصیه‌شده است.

```
┌──────────────────────────────────────────────────────┐
│                  MODULAR MONOLITH                     │
│                                                       │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐     │
│  │   Order    │  │  Payment   │  │ Inventory  │     │
│  │   Module   │  │  Module    │  │  Module    │     │
│  │ ┌────────┐ │  │ ┌────────┐ │  │ ┌────────┐ │     │
│  │ │Public  │ │  │ │Public  │ │  │ │Public  │ │     │
│  │ │API     │ │  │ │API     │ │  │ │API     │ │     │
│  │ ├────────┤ │  │ ├────────┤ │  │ ├────────┤ │     │
│  │ │Internal│ │  │ │Internal│ │  │ │Internal│ │     │
│  │ │Logic   │ │  │ │Logic   │ │  │ │Logic   │ │     │
│  │ ├────────┤ │  │ ├────────┤ │  │ ├────────┤ │     │
│  │ │Data    │ │  │ │Data    │ │  │ │Data    │ │     │
│  │ │Access  │ │  │ │Access  │ │  │ │Access  │ │     │
│  │ └────────┘ │  │ └────────┘ │  │ └────────┘ │     │
│  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘     │
│        │               │               │             │
│        │   Public API   │   Public API   │             │
│        │   Calls Only   │   Calls Only   │             │
│        │               │               │             │
│  ┌─────▼───────────────▼───────────────▼──────┐      │
│  │            Shared Database                  │      │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐   │      │
│  │  │ order_*  │ │payment_* │ │ inv_*    │   │      │
│  │  │ tables   │ │ tables   │ │ tables   │   │      │
│  │  └──────────┘ └──────────┘ └──────────┘   │      │
│  └────────────────────────────────────────────┘      │
└──────────────────────────────────────────────────────┘
                 واحد استقرار واحد
          (اما با مرزهای تعریف‌شده واضح)
```

**ویژگی‌ها:**
- مرزهای واضح ماژول که توسط قراردادهای کد یا ویژگی‌های زبان اعمال می‌شوند
- هر ماژول یک API عمومی ارائه می‌دهد؛ جزئیات داخلی پنهان هستند
- ماژول‌ها فقط از طریق رابط‌های عمومی خود ارتباط برقرار می‌کنند
- پایگاه داده مشترک، اما هر ماژول مالک جداول/schema خود است
- استخراج آسان ماژول‌ها به [microservices](./microservices.fa.md) در آینده
- توصیه‌شده توسط Sam Newman، Simon Brown و بسیاری از معماران مدرن

#### نوع 3: Distributed Monolith (ضدالگو)

سیستمی که **بدترین هر دو دنیا** را دارد: پیچیدگی یک سیستم توزیع‌شده همراه با جفت‌شدگی سفت یک monolith. تمام سرویس‌ها باید با هم مستقر شوند.

```
┌──────────────────────────────────────────────────────┐
│            DISTRIBUTED MONOLITH (ضدالگو)              │
│                                                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │Service A │  │Service B │  │Service C │           │
│  │          │←→│          │←→│          │           │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘           │
│       │              │              │                 │
│       │   جفت‌شدگی سفت در سراسر    │                 │
│       │    مرزهای شبکه             │                 │
│       │              │              │                 │
│       └──────────────┼──────────────┘                 │
│                      │                                │
│             ┌────────▼────────┐                       │
│             │ Shared Database │                       │
│             └─────────────────┘                       │
│                                                       │
│  باید تمام سرویس‌ها را با هم مستقر کنید              │
│  تاخیر شبکه دارد اما استقلال ندارد                   │
└──────────────────────────────────────────────────────┘
```

**ویژگی‌ها:**
- چندین سرویس، اما با جفت‌شدگی سفت
- پایگاه داده مشترک بین سرویس‌ها
- نمی‌توان سرویس‌ها را به صورت مستقل مستقر کرد
- تاخیر شبکه بدون مزایای استقلال سرویس
- اغلب نتیجه یک مهاجرت بد برنامه‌ریزی‌شده به microservices

---

## 5. مثال

### Monolith تجارت الکترونیک ساده

**سناریو**: یک استارتاپ در حال ساخت یک فروشگاه آنلاین با تیم کوچک 5 نفره.

**معماری:**

```
┌──────────────────────────────────────────────────────────┐
│               E-COMMERCE MONOLITH                         │
│                                                           │
│  ┌─────────────────────────────────────────────────┐     │
│  │              Web Layer (Controllers)             │     │
│  │  /products  /cart  /orders  /users  /admin       │     │
│  └────────────────────┬────────────────────────────┘     │
│                       │                                   │
│  ┌────────────────────▼────────────────────────────┐     │
│  │           Business Logic Services                │     │
│  │                                                   │     │
│  │  ProductService ──▶ direct call ──▶ InventoryService │
│  │       │                                           │     │
│  │       ▼                                           │     │
│  │  OrderService ──▶ direct call ──▶ PaymentService  │     │
│  │       │                                           │     │
│  │       ▼                                           │     │
│  │  NotificationService (ارسال ایمیل، SMS)           │     │
│  └────────────────────┬────────────────────────────┘     │
│                       │                                   │
│  ┌────────────────────▼────────────────────────────┐     │
│  │           Data Access Layer (ORM)                │     │
│  └────────────────────┬────────────────────────────┘     │
│                       │                                   │
│  ┌────────────────────▼────────────────────────────┐     │
│  │              PostgreSQL Database                  │     │
│  │  products | orders | users | payments | inventory│     │
│  └──────────────────────────────────────────────────┘     │
└──────────────────────────────────────────────────────────┘
```

**خط لوله استقرار:**

```
Developer ──▶ Git Push ──▶ CI Build ──▶ Run Tests ──▶ Build Artifact ──▶ Deploy
                              │            │                │              │
                              │            │                │              │
                         Compile        Unit +          Single JAR/    سرور
                         all code     Integration        WAR/Docker    واحد یا
                                       tests             image        خوشه
```

**چه چیزی اینجا خوب کار می‌کند:**

- **توسعه سریع**: تمام کد در یک جا، پیمایش آسان
- **تراکنش‌های ساده**: `OrderService` با `PaymentService` و `InventoryService` در همان تراکنش پایگاه داده فراخوانی می‌شود
- **debugging آسان**: پروسس واحد، فایل log واحد، debugger استاندارد
- **استقرار ساده**: یک artifact، یک deploy، یک rollback
- **هزینه کم**: یک سرور، یک پایگاه داده، زیرساخت حداقلی

---

## 6. مزایا و معایب

### مزایا

| مزیت | توضیح | تاثیر |
|------|-------|-------|
| **سادگی** | Codebase واحد، استقرار واحد، پروسس واحد | سربار شناختی کمتر، ورود سریع‌تر برای توسعه‌دهندگان جدید |
| **debugging آسان** | تمام کد در یک پروسس با debuggerهای استاندارد اجرا می‌شود | stack traceها کامل هستند، نیاز به distributed tracing نیست |
| **بدون تاخیر شبکه** | ماژول‌ها از طریق فراخوانی تابع درون‌پروسسی ارتباط برقرار می‌کنند | تاخیر میکروثانیه در مقابل میلی‌ثانیه بین ماژول‌ها |
| **تراکنش‌های ACID** | پایگاه داده واحد تراکنش‌های ساده را ممکن می‌کند | نیاز به [الگوی Saga](../distributed-transactions/saga.fa.md) یا [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) نیست |
| **استقرار ساده** | یک بار build، یک بار deploy | بدون هماهنگی سرویس، بدون مدیریت وابستگی بین سرویس‌ها |
| **تست آسان** | تست‌های end-to-end در یک پروسس واحد اجرا می‌شوند | نیاز به محیط‌های تست یکپارچه‌سازی پیچیده نیست |
| **نظارت ساده** | یک اپلیکیشن برای نظارت | بدون distributed tracing، جریان log واحد، هشداردهی ساده‌تر |
| **هزینه کمتر** | زیرساخت کمتر، ابزار کمتر | بدون Kubernetes، بدون service mesh، سرورهای کمتر |
| **Refactoring** | پشتیبانی IDE برای تغییر نام، جابجایی کد | refactoring ایمن درون یک codebase واحد |

### معایب

| عیب | توضیح | کاهش |
|-----|-------|------|
| **محدودیت‌های مقیاس‌پذیری** | باید کل اپلیکیشن را مقیاس داد حتی اگر فقط یک ماژول زیر بار باشد | مقیاس‌پذیری عمودی، caching، read replicaهای پایگاه داده |
| **ریسک جفت‌شدگی سفت** | بدون نظم، ماژول‌ها درهم‌تنیده می‌شوند | اعمال مرزهای ماژول، استفاده از الگوهای modular monolith |
| **استقرار همه‌یا‌هیچ** | یک تغییر کوچک نیاز به استقرار مجدد کل اپ دارد | feature flags، blue-green deployments، چرخه‌های انتشار کوتاه |
| **قفل شدن به تکنولوژی** | یک technology stack واحد برای تمام ماژول‌ها | انتخاب stack همه‌کاره، استفاده از modular monolith با کامپوننت‌های pluggable |
| **زمان build طولانی** | با رشد codebase، زمان build و تست افزایش می‌یابد | buildهای افزایشی، تست موازی، build caching |
| **هماهنگی تیم** | چندین تیم که در همان codebase کار می‌کنند ممکن است تداخل داشته باشند | قوانین مالکیت کد، استراتژی‌های branch، modular monolith |
| **ریسک قابلیت اطمینان** | باگ در یک ماژول می‌تواند کل اپلیکیشن را خراب کند | ایزوله‌سازی پروسس، مدیریت خطای خوب، تست کامل |
| **نوآوری محدود** | آزمایش تکنولوژی‌های جدید دشوار است | کپسوله‌سازی آزمایش‌ها در ماژول‌ها با مرزهای واضح |

### تحلیل هزینه-فایده

```
سرعت توسعه
        ▲
        │
  بالا  │  ┌────────────┐
        │  │ Monolith   │       ┌──────────────────┐
        │  │ (اولیه)    │       │   Microservices   │
        │  └──────┬─────┘       │   (در مقیاس)      │
        │         │             └─────────┬────────┘
        │         │                       │
  متوسط │         └───────────┐           │
        │                     │           │
        │              ┌──────▼──────┐    │
        │              │ Monolith    │    │
        │              │ (در حال رشد)│    │
  پایین │              └─────────────┘    │
        │                                 │
        └─────────────────────────────────────────▶
          کوچک            متوسط           بزرگ
                    اندازه اپلیکیشن / تیم
```

---

## 7. الگوهای مرتبط

### Monolith در مقابل Microservices

جدول زیر معماری monolithic را با [معماری Microservices](./microservices.fa.md) مقایسه می‌کند:

| بعد | Monolithic | Microservices |
|-----|-----------|---------------|
| **استقرار** | واحد واحد | چندین واحد مستقل |
| **مقیاس‌پذیری** | عمودی (scale up) | افقی (scale out به ازای هر سرویس) |
| **ارتباط** | فراخوانی تابع درون‌پروسسی | فراخوانی شبکه (HTTP، gRPC، messaging) |
| **پایگاه داده** | پایگاه داده مشترک واحد | پایگاه داده به ازای هر سرویس |
| **تراکنش‌ها** | ACID — ساده | توزیع‌شده — [Saga](../distributed-transactions/saga.fa.md) یا [2PC](../distributed-transactions/two-phase-commit.fa.md) |
| **تکنولوژی** | stack واحد | Polyglot (stackهای مختلف به ازای هر سرویس) |
| **ساختار تیم** | Codebase مشترک | تیم‌های مستقل به ازای هر سرویس |
| **Debugging** | ساده (پروسس واحد) | پیچیده (distributed tracing مورد نیاز) |
| **سازگاری** | قوی (DB واحد) | نهایی (به [قضیه CAP](../fundamentals/cap-theorem.fa.md) مراجعه کنید) |
| **هزینه عملیاتی** | کم | بالا (Kubernetes، service mesh، نظارت) |
| **سرعت اولیه** | سریع | کند (سربار زیرساخت) |
| **سرعت بلندمدت** | با رشد codebase کند می‌شود | با رشد تیم مقیاس می‌یابد |

### Monolith در مقابل Modular Monolith در مقابل Microservices

```
┌─────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐
│   Classic        │    │   Modular            │    │   Microservices     │
│   Monolith       │    │   Monolith           │    │                     │
│                  │    │                      │    │  ┌────┐  ┌────┐    │
│  ┌────────────┐ │    │  ┌──────┐ ┌──────┐  │    │  │Svc │  │Svc │    │
│  │  All code  │ │    │  │Mod A │ │Mod B │  │    │  │ A  │  │ B  │    │
│  │  mixed     │ │    │  │      │ │      │  │    │  └──┬─┘  └──┬─┘    │
│  │  together  │ │    │  └──┬───┘ └──┬───┘  │    │     │       │      │
│  └──────┬─────┘ │    │     │Public  │API   │    │  Network  Network   │
│         │       │    │     │API     │      │    │     │       │      │
│  ┌──────▼─────┐ │    │  ┌──▼───────▼───┐  │    │  ┌──▼─┐  ┌──▼─┐    │
│  │  Single DB │ │    │  │  Shared DB   │  │    │  │DB A│  │DB B│    │
│  └────────────┘ │    │  └──────────────┘  │    │  └────┘  └────┘    │
│                  │    │                      │    │                     │
│  1 واحد استقرار │    │  1 واحد استقرار      │    │  N واحد استقرار     │
└─────────────────┘    └─────────────────────┘    └─────────────────────┘

سادگی ◀────────────────────────────────────────────▶ انعطاف‌پذیری
عملیات کم ◀────────────────────────────────────────▶ عملیات زیاد
```

### استراتژی Monolith First

رویکرد "Monolith First" از Martin Fowler:

```
فاز 1: Monolith                  فاز 2: Modular Monolith
┌──────────────────┐              ┌──────────────────────────┐
│                  │              │  ┌────┐ ┌────┐ ┌────┐   │
│  Monolith        │   Refactor  │  │Mod │ │Mod │ │Mod │   │
│  (کشف دامنه)    │  ─────────▶ │  │ A  │ │ B  │ │ C  │   │
│                  │              │  └────┘ └────┘ └────┘   │
│                  │              │  مرزهای واضح ماژول      │
└──────────────────┘              └──────────────────────────┘
                                              │
                                              │ استخراج زمانی که توجیه شود
                                              ▼
                                  فاز 3: استخراج انتخابی
                                  ┌──────────────────────────┐
                                  │  ┌────┐ ┌────────────┐  │
                                  │  │Mod │ │  Monolith   │  │
                                  │  │ A  │ │  (Mod B+C)  │  │
                                  │  └──┬─┘ └──────┬─────┘  │
                                  │     │          │         │
                                  └─────┼──────────┼─────────┘
                                        │          │
                                  ┌─────▼──┐       │
                                  │ Svc A  │       │
                                  │(استخراج‌شده)   │
                                  └────────┘       │
```

**اصول کلیدی:**

1. **با یک monolith شروع کنید** تا دامنه را درک کنید
2. **مرزهای واضح ماژول را** زود ایجاد کنید (modular monolith)
3. **سرویس‌ها را فقط زمانی استخراج کنید** که توسط نیازهای مقیاس، تیم یا تکنولوژی توجیه شود
4. **همه را یکجا استخراج نکنید** — هر بار یک سرویس را جدا کنید

### الگوهای مرتبط مورد استفاده درون Monolithها

- **[API Gateway](./api-gateway.fa.md)**: حتی monolithها می‌توانند پشت یک API gateway برای محدودیت نرخ، احراز هویت و SSL termination قرار بگیرند
- **[CQRS](../data-patterns/cqrs.fa.md)**: می‌تواند درون یک monolith اعمال شود (CQRS با همان DB) برای بهینه‌سازی خواندن/نوشتن
- **[معماری Event-Driven](../event-driven/event-driven-architecture.fa.md)**: event bus داخلی درون monolith برای ماژول‌های جداشده
- **[Circuit Breaker](../resilience/circuit-breaker.fa.md)**: زمانی اعمال می‌شود که monolith سرویس‌ها یا APIهای خارجی را فراخوانی می‌کند

---

## 8. کاربرد در دنیای واقعی

### Shopify — Modular Monolith در مقیاس

**مقیاس:** بیش از 2 میلیون بازرگان، میلیاردها دلار در تراکنش‌ها

Shopify تصمیم گرفت **با modular monolith (Ruby on Rails) بماند** به جای مهاجرت به microservices. آن‌ها به شدت در ماژولارسازی از طریق ابتکار داخلی "componentization" سرمایه‌گذاری کردند.

**تصمیمات کلیدی:**
- شناسایی حدود 300 کامپوننت درون monolith
- اعمال مرزها بین کامپوننت‌ها با استفاده از تحلیل استاتیک و بررسی‌های CI
- کامپوننت‌ها از طریق APIهای عمومی تعریف‌شده ارتباط برقرار می‌کنند
- پایگاه داده مشترک با مالکیت واضح schema به ازای هر کامپوننت

**چرا کار می‌کند:**
- استقرار واحد عملیات را ساده می‌کند
- تراکنش‌های ACID در سراسر سیستم
- بدون تاخیر شبکه بین کامپوننت‌ها
- refactoring و جابجایی کد بین کامپوننت‌ها آسان‌تر

### Basecamp / فلسفه DHH

**David Heinemeier Hansson (DHH)**، خالق Ruby on Rails و CTO شرکت Basecamp (اکنون 37signals)، یک مدافع پرصدا برای معماری monolithic است. Basecamp و ایمیل HEY هر دو اپلیکیشن‌های monolithic Rails هستند.

**استدلال‌های اصلی:**
- اکثر اپلیکیشن‌ها نیاز به microservices ندارند
- پیچیدگی عملیاتی microservices به ندرت توجیه دارد
- یک monolith با ساختار مناسب می‌تواند به میلیون‌ها کاربر خدمت رساند
- رضایت تیم و سرعت توسعه بیش از روندهای معماری اهمیت دارد

### استارتاپ‌های مرحله اولیه

تقریباً هر شرکت فناوری موفقی با یک monolith شروع کرد:

| شرکت | شروع به عنوان | مهاجرت به | زمان مهاجرت |
|------|-------------|-----------|-------------|
| **Netflix** | Monolith (Java) | Microservices | پس از رسیدن به میلیون‌ها مشترک |
| **Amazon** | Monolith (C++/Perl) | Microservices | حدود 2001، پس از رشد عظیم تیم |
| **Twitter** | Monolith (Ruby on Rails) | Microservices | پس از قطعی‌های مکرر ("Fail Whale") |
| **Uber** | Monolith (Python) | Microservices | حدود 2014، پس از گسترش سریع جهانی |
| **Shopify** | Monolith (Ruby on Rails) | **monolith ماند** | به جای تجزیه، ماژولارسازی کرد |
| **Basecamp** | Monolith (Ruby on Rails) | **monolith ماند** | عمداً monolithic باقی ماند |
| **Stack Overflow** | Monolith (C# / .NET) | **monolith ماند** | بیش از 100 میلیون کاربر ماهانه را به عنوان monolith سرویس می‌دهد |

**درس:** مهاجرت به microservices توسط **نیازهای مقیاس‌پذیری سازمانی** هدایت می‌شود، نه روندهای فنی. بسیاری از محصولات بسیار موفق به عنوان monolith عمل می‌کنند.

---

## 9. خلاصه

### چه زمانی از Monolith استفاده کنیم

1. **محصول مرحله اولیه** — نیازمندی‌های نامطمئن، نیاز به تکرار سریع
2. **تیم کوچک** — کمتر از 10 توسعه‌دهنده، سربار هماهنگی کم
3. **دامنه ساده** — پیچیدگی کسب‌وکار محدود، مرزهای واضح
4. **سازگاری قوی مورد نیاز** — تراکنش‌های ACID در سراسر اپلیکیشن
5. **بودجه محدود** — نمی‌تواند در Kubernetes، service mesh، distributed tracing سرمایه‌گذاری کند
6. **MVP یا نمونه اولیه** — نیاز به اعتبارسنجی سریع ایده

### چه زمانی مهاجرت را در نظر بگیریم

1. **تیم بزرگ شده** — چندین تیم در همان codebase به هم برخورد می‌کنند
2. **نیازمندی‌های مقیاس‌پذیری متفاوت** — یک ماژول 100 برابر بیشتر از دیگری منابع نیاز دارد
3. **گلوگاه استقرار** — استقرار کل اپ کند و پرریسک است
4. **محدودیت‌های تکنولوژی** — یک ماژول به طور قابل توجهی از tech stack متفاوت بهره می‌برد
5. **استقلال سازمانی** — تیم‌ها نیاز به استقرار مستقل دارند

### نکات کلیدی

1. **معماری Monolithic منسوخ نشده** — همچنان انتخاب درست برای بسیاری از اپلیکیشن‌ها، به ویژه در مراحل اولیه باقی مانده است.

2. **Modular Monolith رویکرد مدرن است** — مرزهای واضح ماژول را درون monolith اعمال کنید تا بهترین هر دو دنیا را بگیرید.

3. **Monolith First** — با یک monolith شروع کنید تا دامنه را درک کنید، سپس فقط زمانی تجزیه کنید که درد monolith از هزینه توزیع بیشتر شود.

4. **از Distributed Monolith اجتناب کنید** — اگر خیلی زود یا بدون مرزهای واضح تجزیه کنید، بدترین هر دو دنیا را می‌گیرید.

5. **مقیاس‌پذیری فقط درباره تکنولوژی نیست** — بیشتر مهاجرت‌ها به [microservices](./microservices.fa.md) توسط نیازهای سازمانی (اندازه تیم، استقلال) هدایت می‌شوند نه محدودیت‌های فنی.

6. **سادگی ارزش دارد** — بدون تاخیر شبکه، بدون تراکنش‌های توزیع‌شده، بدون سازگاری نهایی، بدون service discovery. اینها مزایای واقعی هستند.

7. **Stack Overflow، Shopify و Basecamp** ثابت می‌کنند که monolithها می‌توانند به صدها میلیون کاربر خدمت رسانند وقتی ساختار مناسبی داشته باشند.

8. **سادگی استقرار مهم است** — یک deploy واحد، یک rollback واحد و یک خط لوله نظارت واحد بار عملیاتی را به طور قابل توجهی کاهش می‌دهد.

9. **تراکنش‌های ACID یک ابرقدرت هستند** — درون یک monolith، سازگاری بین ماژول‌ها ساده است در مقایسه با پیچیدگی [الگوی Saga](../distributed-transactions/saga.fa.md) یا [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md).

10. **بر اساس زمینه خود انتخاب کنید** — نه بر اساس آنچه Netflix یا Amazon انجام می‌دهد. مشکلات آن‌ها مشکلات شما نیستند.

### موضوعات مرتبط

- [معماری Microservices](./microservices.fa.md) — جایگزین توزیع‌شده monolithها
- [API Gateway](./api-gateway.fa.md) — الگوی نقطه ورود که می‌تواند جلوی هم monolithها و هم microservices قرار بگیرد
- [الگوی Saga](../distributed-transactions/saga.fa.md) — تراکنش‌های توزیع‌شده مورد نیاز وقتی monolith را ترک می‌کنید
- [Two-Phase Commit](../distributed-transactions/two-phase-commit.fa.md) — رویکرد دیگر تراکنش توزیع‌شده
- [قضیه CAP](../fundamentals/cap-theorem.fa.md) — مصالحه‌هایی که فقط در سیستم‌های توزیع‌شده اعمال می‌شوند
- [CQRS](../data-patterns/cqrs.fa.md) — می‌تواند درون monolith برای جداسازی خواندن/نوشتن اعمال شود
- [معماری Event-Driven](../event-driven/event-driven-architecture.fa.md) — می‌تواند درون monolith از طریق event bus داخلی استفاده شود
- [Circuit Breaker](../resilience/circuit-breaker.fa.md) — مفید وقتی monolith سرویس‌های خارجی را فراخوانی می‌کند

### مطالعه بیشتر

- **"Monolith First"** از Martin Fowler — مقاله بنیادی درباره چرایی شروع با monolith
- **"Building Microservices"** از Sam Newman — شامل پوشش عالی سفر از monolith به microservices
- **"Deconstructing the Monolith"** از Shopify Engineering — چگونه Shopify monolith خود را ماژولارسازی کرد
- **"The Majestic Monolith"** از DHH — استدلال برای ماندن با monolithic
- **"Modular Monolith: A Primer"** از Kamil Grzybek — بررسی عمیق الگوهای modular monolith

---

**به یاد داشته باشید**: یک monolith اشتباهی نیست که باید اصلاح شود — بلکه یک انتخاب معماری معتبر است. بهترین معماری آن است که با تیم، محصول و مرحله رشد شما سازگار باشد. ساده شروع کنید، عمدا رشد کنید و فقط زمانی تجزیه کنید که مزایا به وضوح بیش از هزینه‌ها باشد.
