# پیام‌رسانی (Messaging)

## ۱. مقدمه

پیام‌رسانی یک **الگوی ارتباطی ناهمزمان بین سرویس‌ها** است که در آن سرویس‌ها از طریق ارسال و دریافت پیام‌ها از طریق یک واسطه پیام (message broker) داده‌ها را مبادله می‌کنند. به جای فراخوانی مستقیم یکدیگر از طریق یک پروتکل همزمان، سرویس‌ها پیام‌ها را به واسطه تولید می‌کنند و پیام‌ها را از آن مصرف می‌کنند، و به این ترتیب جداسازی زمانی و اتصال سست را به دست می‌آورند.

پیام‌رسانی یکی از دو سبک ارتباطی اساسی در [معماری Microservices](../architecture/microservices.md) است. در حالی که الگوهای همزمان فراخوانی رویه راه دور (RPI) مانند REST و gRPC نیاز دارند که هر دو فراخواننده و فراخوانده همزمان در دسترس باشند، پیام‌رسانی به سرویس‌ها اجازه می‌دهد حتی زمانی که گیرنده به طور موقت در دسترس نیست، ارتباط برقرار کنند. واسطه پیام‌ها را تا زمانی که مصرف‌کننده آماده پردازش آن‌ها شود نگه می‌دارد.

```
┌──────────────────────────────────────────────────────────────────────┐
│                     معماری پیام‌رسانی                                │
│                                                                     │
│  ┌─────────┐     message     ┌─────────────┐     message     ┌─────────┐
│  │ Service │ ──────────────▶ │   Message   │ ──────────────▶ │ Service │
│  │    A    │    (produce)    │   Broker    │   (consume)     │    B    │
│  │(Producer)│                │             │                 │(Consumer)│
│  └─────────┘                └─────────────┘                 └─────────┘
│                                    │                                  │
│                                    │          message                 │
│                                    └──────────────────▶ ┌─────────┐  │
│                                         (consume)       │ Service │  │
│                                                         │    C    │  │
│                                                         │(Consumer)│  │
│                                                         └─────────┘  │
└──────────────────────────────────────────────────────────────────────┘
```

این سند الگوی پیام‌رسانی را به طور عمیق پوشش می‌دهد: مشکلاتی که حل می‌کند، نحوه کار آن، انواع پیام و کانال، تضمین‌های تحویل، معناشناسی ترتیب، فناوری‌های محبوب واسطه، مثال‌های عملی و مصالحه‌ها.

---

## ۲. زمینه و مسئله

در یک سیستم توزیع‌شده — به ویژه سیستمی که از [معماری Microservices](../architecture/microservices.md) پیروی می‌کند — سرویس‌ها برای انجام عملیات تجاری نیاز به ارتباط با یکدیگر دارند. به عنوان مثال، وقتی یک سفارش ثبت می‌شود، سرویس سفارش باید سرویس انبار را برای رزرو موجودی و سرویس اعلان‌ها را برای ارسال ایمیل تأیید مطلع کند.

### مسئله

سرویس‌ها چگونه باید ارتباط برقرار کنند وقتی:

- **پاسخ فوری** از گیرنده مورد نیاز نیست؟
- **اتصال سست** یک اولویت است تا سرویس‌ها بتوانند به طور مستقل تکامل یابند؟
- **تاب‌آوری** مورد نیاز است تا خرابی موقت در یک سرویس به سرویس‌های دیگر سرایت نکند؟
- سیستم باید **جهش‌های ترافیک را مدیریت کند** بدون اینکه سرویس‌های پایین‌دستی تحت فشار قرار گیرند؟

ارتباط همزمان (مانند REST یا gRPC) اتصال زمان اجرای محکمی ایجاد می‌کند: اگر فراخوانده کند باشد یا از کار بیفتد، فراخواننده مسدود می‌شود یا شکست می‌خورد. این منجر به شکست‌های آبشاری، کاهش دسترس‌پذیری و دشواری در مقیاس‌گذاری مستقل سرویس‌ها می‌شود.

---

## ۳. نیروها

چندین نیروی رقابتی نیاز به الگوی ارتباطی مبتنی بر پیام‌رسانی را ایجاب می‌کنند:

| نیرو | توضیحات |
|------|---------|
| **جداسازی** | سرویس‌ها نباید نیاز به دانستن مکان فیزیکی، فناوری یا دسترس‌پذیری سرویس‌های دیگر داشته باشند |
| **تاب‌آوری** | اگر یک سرویس پایین‌دستی در دسترس نباشد، سرویس بالادستی نباید شکست بخورد |
| **بافرینگ** | سیستم باید جهش‌های بار را بدون تحت فشار قرار دادن مصرف‌کنندگان جذب کند |
| **مقیاس‌پذیری** | مصرف‌کنندگان باید بتوانند بر اساس توان عملیاتی پیام به طور مستقل مقیاس شوند |
| **آزادی زمانی** | تولیدکننده و مصرف‌کننده نیاز ندارند همزمان فعال باشند |
| **پخش** | یک رویداد واحد ممکن است نیاز داشته باشد به چندین مصرف‌کننده علاقه‌مند برسد |
| **ترتیب** | برخی فرآیندهای تجاری نیاز دارند پیام‌ها به ترتیب خاصی پردازش شوند |
| **قابلیت اطمینان** | پیام‌ها نباید حتی در طول خرابی واسطه یا مصرف‌کننده از بین بروند |
| **پیچیدگی** | افزودن زیرساخت (واسطه) سربار عملیاتی و اشکال‌زدایی را افزایش می‌دهد |

---

## ۴. راه‌حل

### ایده اصلی

سرویس‌ها از طریق **ارسال و دریافت پیام‌ها از طریق یک کانال پیام** که توسط یک **واسطه پیام** مدیریت می‌شود، ارتباط برقرار می‌کنند. تولیدکننده پیامی را به یک کانال با نام مشخص ارسال می‌کند؛ واسطه آن را ذخیره کرده و به یک یا چند مصرف‌کننده مشترک آن کانال تحویل می‌دهد.

```
┌──────────────────────────────────────────────────────────────────────────┐
│                        جریان پیام                                        │
│                                                                          │
│   Producer                  Broker                   Consumer(s)         │
│   ────────                  ──────                   ───────────         │
│                                                                          │
│   1. Create message                                                      │
│   2. Send to channel ────▶ 3. Receive & store                           │
│                            4. Route to subscriber(s)                     │
│                            5. Deliver ────────────▶ 6. Receive message  │
│                                                     7. Process message  │
│                            8. Wait for ACK ◀─────── 8. Send ACK        │
│                            9. Remove / mark done                         │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### انواع پیام

پیام‌ها بسته به هدف، معانی معنایی مختلفی دارند:

| نوع پیام | هدف | مثال |
|----------|------|------|
| **Command (فرمان)** | به یک سرویس می‌گوید عملی انجام دهد | `ReserveInventory { orderId, items }` |
| **Event (رویداد)** | اطلاع می‌دهد که چیزی اتفاق افتاده | `OrderPlaced { orderId, customerId, total }` |
| **Document (سند)** | داده‌ها را بین سرویس‌ها انتقال می‌دهد | `CustomerProfile { id, name, email, address }` |

**پیام‌های فرمان** یک گیرنده خاص دارند که انتظار می‌رود عمل درخواست‌شده را انجام دهد. **پیام‌های رویداد** بدون اطلاع از اینکه چه کسی آن‌ها را مصرف خواهد کرد منتشر می‌شوند — آن‌ها بیانیه‌هایی از واقعیت درباره گذشته هستند. **پیام‌های سند** بار داده‌ای را برای استفاده گیرنده حمل می‌کنند.

### انواع کانال

دو نوع کانال اساسی وجود دارد:

```
┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│   Point-to-Point (Queue)            Publish-Subscribe (Topic)     │
│   ──────────────────────            ─────────────────────────     │
│                                                                   │
│   Producer ──▶ [Queue] ──▶ Consumer    Producer ──▶ [Topic] ──┬──▶ Consumer A
│                                                               │
│   * One message goes to exactly       * One message goes to   ├──▶ Consumer B
│     ONE consumer                        ALL subscribers       │
│   * Load balancing across             * Fan-out pattern       └──▶ Consumer C
│     competing consumers               * Each subscriber gets
│   * Used for commands/tasks              its own copy
│                                       * Used for events
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

**نقطه به نقطه (صف)**:
- یک پیام دقیقاً به **یک** مصرف‌کننده از بین چندین مصرف‌کننده رقیب تحویل داده می‌شود.
- توازن بار را فعال می‌کند: چندین نمونه از یک سرویس می‌توانند از یک صف مصرف کنند.
- برای پیام‌های فرمان و توزیع وظایف ایده‌آل است.

**انتشار-اشتراک (تاپیک)**:
- یک پیام به **تمام** مشترکین تاپیک تحویل داده می‌شود.
- هر مشترک کپی خود را از پیام دریافت می‌کند.
- برای اعلان‌های رویداد که چندین سرویس به یک رویداد واکنش نشان می‌دهند ایده‌آل است.

### نقش واسطه پیام

واسطه پیام زیرساخت مرکزی است که کانال‌های پیام را مدیریت می‌کند. مسئولیت‌های آن عبارتند از:

| مسئولیت | توضیحات |
|---------|---------|
| **مسیریابی** | پیام‌ها را از تولیدکنندگان به کانال(ها) و مصرف‌کننده(های) صحیح هدایت می‌کند |
| **بافرینگ** | پیام‌ها را هنگامی که مصرف‌کنندگان کندتر از تولیدکنندگان هستند یا موقتاً در دسترس نیستند ذخیره می‌کند |
| **تضمین‌های تحویل** | اطمینان می‌دهد پیام‌ها طبق سطح تضمین پیکربندی‌شده تحویل داده می‌شوند |
| **صف‌های نامه مرده (DLQ)** | پیام‌هایی که پس از تعداد تلاش مجدد پیکربندی‌شده در پردازش شکست می‌خورند را ضبط می‌کند |
| **پایداری پیام** | پیام‌ها را به طور بادوام ذخیره می‌کند تا از راه‌اندازی مجدد واسطه جان سالم به در ببرند |
| **مدیریت مصرف‌کننده** | آفست‌ها، تأییدیه‌ها و اشتراک‌های مصرف‌کننده را ردیابی می‌کند |
| **نظارت** | معیارهایی درباره عمق صف، توان عملیاتی، تأخیر و نرخ خطا ارائه می‌دهد |

```
┌──────────────────────────────────────────────────────────┐
│                   اجزای داخلی واسطه پیام                  │
│                                                          │
│  ┌────────┐   ┌────────────┐   ┌──────────────────────┐ │
│  │ Inbound│   │  Routing   │   │   Channel Storage    │ │
│  │  Port  │──▶│  Engine    │──▶│  ┌───────┐ ┌──────┐  │ │
│  └────────┘   └────────────┘   │  │Queue A│ │TopicB│  │ │
│                                │  └───────┘ └──────┘  │ │
│                                │  ┌───────┐ ┌──────┐  │ │
│                                │  │Queue C│ │ DLQ  │  │ │
│                                │  └───────┘ └──────┘  │ │
│                                └──────────────────────┘ │
│                                          │              │
│                                          ▼              │
│                                ┌──────────────────┐     │
│                                │ Delivery Engine  │     │
│                                │ (push or pull)   │     │
│                                └──────────────────┘     │
└──────────────────────────────────────────────────────────┘
```

### تضمین‌های تحویل

یکی از مهم‌ترین جنبه‌های پیام‌رسانی **تضمین تحویل** است — قرارداد بین واسطه و مصرف‌کنندگان درباره تعداد دفعاتی که یک پیام تحویل داده می‌شود:

| تضمین | توضیحات | مصالحه |
|-------|---------|--------|
| **حداکثر یک‌بار (At-most-once)** | پیام صفر یا یک بار تحویل داده می‌شود. اگر تحویل شکست بخورد، پیام از بین می‌رود. | کمترین تأخیر، خطر از دست رفتن داده |
| **حداقل یک‌بار (At-least-once)** | پیام یک یا چند بار تحویل داده می‌شود. تکراری‌ها ممکن هستند. | بدون از دست رفتن داده، مصرف‌کنندگان باید بی‌توان باشند |
| **دقیقاً یک‌بار (Exactly-once)** | پیام دقیقاً یک بار تحویل داده می‌شود. بدون از دست رفتن، بدون تکرار. | بیشترین سربار، نیاز به پشتیبانی تراکنشی |

در عمل، **حداقل یک‌بار** پرکاربردترین تضمین است. مصرف‌کنندگان طوری طراحی می‌شوند که **بی‌توان (idempotent)** باشند — پردازش چندباره یک پیام نتیجه یکسانی تولید می‌کند. تحویل دقیقاً یک‌بار واقعی بسیار دشوار است و معمولاً نیاز به هماهنگی تراکنشی بین واسطه و ذخیره داده مصرف‌کننده دارد (مانند تراکنش‌های Kafka + تأیید آفست مصرف‌کننده).

### ترتیب پیام

ترتیب پیام برای بسیاری از فرآیندهای تجاری حیاتی است، اما **ترتیب جهانی در تمام پیام‌ها معمولاً تضمین نمی‌شود** (یا بسیار پرهزینه است). واسطه‌ها مدل‌های ترتیب‌دهی مختلفی ارائه می‌دهند:

| واسطه | مدل ترتیب‌دهی |
|-------|--------------|
| **Apache Kafka** | ترتیب در یک **پارتیشن** تضمین می‌شود. پیام‌هایی با کلید پارتیشن یکسان همیشه به ترتیب پردازش می‌شوند. |
| **RabbitMQ** | ترتیب در هر **صف** با یک مصرف‌کننده تضمین می‌شود. با مصرف‌کنندگان رقیب، ترتیب تضمین نمی‌شود. |
| **AWS SQS** | صف‌های استاندارد: ترتیب تلاش بهینه. صف‌های FIFO: ترتیب دقیق در یک گروه پیام. |
| **Azure Service Bus** | جلسات (Sessions) تحویل مرتب را برای پیام‌هایی با شناسه جلسه یکسان فراهم می‌کنند. |

برای حفظ ترتیب پیام‌های مرتبط (مثلاً تمام رویدادهای یک سفارش خاص)، از **کلید پارتیشن** یا **گروه پیام** استفاده کنید تا پیام‌های مرتبط همیشه به یک پارتیشن/صف بروند.

### واسطه‌های پیام محبوب

| واسطه | نوع | پروتکل | بهترین برای |
|-------|------|---------|------------|
| **RabbitMQ** | واسطه پیام | AMQP, MQTT, STOMP | مسیریابی پیچیده، صف‌های وظیفه، RPC از طریق پیام‌رسانی |
| **Apache Kafka** | پلتفرم جریان رویداد | پروتکل Kafka | جریان رویداد با توان عملیاتی بالا، Event Sourcing، تجمیع لاگ |
| **AWS SQS/SNS** | سرویس ابری مدیریت‌شده | HTTP/HTTPS | معماری‌های Serverless، صف‌بندی ساده، fan-out |
| **Azure Service Bus** | سرویس ابری مدیریت‌شده | AMQP, HTTP | پیام‌رسانی سازمانی، جلسات، تراکنش‌ها |
| **Google Pub/Sub** | سرویس ابری مدیریت‌شده | gRPC, HTTP | توزیع جهانی رویداد، خطوط لوله تحلیل |
| **Redis Streams** | ذخیره داده درون‌حافظه | پروتکل Redis | پیام‌رسانی با تأخیر کم، جریان رویداد سبک |
| **Apache Pulsar** | پیام‌رسانی توزیع‌شده | پروتکل Pulsar | چند اجاره‌ای، تکرار جغرافیایی، صف‌بندی + جریان یکپارچه |

برای مقایسه عمیق‌تر دو گزینه متن‌باز محبوب، به [مقایسه RabbitMQ و Kafka](../messaging/rabbitmq-vs-kafka.md) مراجعه کنید.

---

## ۵. مثال

### تجارت الکترونیک: پردازش سفارش با پیام‌رسانی

یک پلتفرم تجارت الکترونیک را در نظر بگیرید که ثبت سفارش، چندین عمل پایین‌دستی را فعال می‌کند. با استفاده از پیام‌رسانی، سرویس سفارش یک رویداد منتشر می‌کند و چندین مصرف‌کننده به طور مستقل واکنش نشان می‌دهند.

```
┌──────────────────────────────────────────────────────────────────────┐
│              پردازش سفارش تجارت الکترونیک از طریق پیام‌رسانی         │
│                                                                      │
│  ┌─────────────┐    OrderPlaced     ┌──────────────────┐            │
│  │   Order     │ ─────event───────▶ │   Message Broker │            │
│  │  Service    │                    │   (Kafka/Rabbit) │            │
│  └─────────────┘                    └────────┬─────────┘            │
│                                              │                       │
│                          ┌───────────────────┼───────────────┐       │
│                          │                   │               │       │
│                          ▼                   ▼               ▼       │
│                   ┌────────────┐     ┌─────────────┐  ┌──────────┐  │
│                   │ Inventory  │     │Notification │  │ Analytics│  │
│                   │  Service   │     │  Service    │  │ Service  │  │
│                   └────────────┘     └─────────────┘  └──────────┘  │
│                          │                   │               │       │
│                   Reserve stock     Send email/SMS    Record event   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**جریان گام به گام:**

1. مشتری از طریق API سفارشی ثبت می‌کند.
2. **سرویس سفارش** سفارش را در پایگاه داده خود ایجاد کرده و یک رویداد `OrderPlaced` را به تاپیک `orders` منتشر می‌کند.
3. **سرویس انبار** به تاپیک `orders` مشترک است، رویداد `OrderPlaced` را دریافت کرده و موجودی را رزرو می‌کند. اگر موجودی کافی نباشد، یک رویداد `InventoryReservationFailed` منتشر می‌کند.
4. **سرویس اعلان‌ها** به همان تاپیک مشترک است و یک ایمیل تأیید و SMS به مشتری ارسال می‌کند.
5. **سرویس تحلیل‌ها** به همان تاپیک مشترک است و رویداد را برای گزارش‌دهی و داشبوردها ثبت می‌کند.

**نمونه بار پیام:**

```json
{
  "eventType": "OrderPlaced",
  "eventId": "evt-a1b2c3d4",
  "timestamp": "2026-02-06T14:30:00Z",
  "payload": {
    "orderId": "ord-98765",
    "customerId": "cust-12345",
    "items": [
      { "productId": "prod-001", "quantity": 2, "price": 29.99 },
      { "productId": "prod-042", "quantity": 1, "price": 89.50 }
    ],
    "totalAmount": 149.48,
    "shippingAddress": {
      "city": "Tehran",
      "country": "IR"
    }
  }
}
```

برای اطمینان از اینکه سرویس سفارش به طور قابل اعتماد رویداد را منتشر می‌کند (به صورت اتمی با نوشتن پایگاه داده)، اغلب از الگوی [Transactional Outbox](../messaging/transactional-outbox.md) استفاده می‌شود. این از سناریویی که سفارش ذخیره شده ولی رویداد به دلیل خرابی واسطه یا شبکه از بین رفته جلوگیری می‌کند.

---

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیحات |
|------|---------|
| **اتصال سست** | تولیدکنندگان و مصرف‌کنندگان از نظر زمان، مکان و فناوری جدا هستند. سرویس‌ها می‌توانند به طور مستقل توسعه، استقرار و مقیاس‌گذاری شوند. |
| **دسترس‌پذیری بهتر** | اگر یک مصرف‌کننده موقتاً از کار بیفتد، پیام‌ها در واسطه بافر شده و هنگام بازیابی مصرف‌کننده تحویل داده می‌شوند. تولیدکننده تحت تأثیر قرار نمی‌گیرد. |
| **تعادل بار** | واسطه پیام‌ها را در طول جهش‌های ترافیک بافر می‌کند و به مصرف‌کنندگان اجازه می‌دهد با سرعت خود پردازش کنند. |
| **طراحی طبیعی رویداد-محور** | پیام‌رسانی به طور طبیعی با [معماری رویداد-محور](../event-driven/event-driven-architecture.md) هماهنگ است و سیستم‌های واکنشی و با اتصال سست را فعال می‌کند. |
| **مقیاس‌پذیری** | مصرف‌کنندگان می‌توانند به صورت افقی (اضافه کردن نمونه‌های بیشتر) برای افزایش توان عملیاتی مقیاس شوند. |
| **قابلیت پخش** | یک رویداد واحد می‌تواند توسط چندین سرویس از طریق pub-sub مصرف شود و fan-out را بدون اطلاع تولیدکننده از هر مصرف‌کننده فعال می‌کند. |
| **ناهمگونی فناوری** | سرویس‌های مختلف می‌توانند با زبان‌ها/فریم‌ورک‌های مختلف ساخته شوند در حالی که از طریق واسطه یکسان ارتباط برقرار می‌کنند. |

### معایب

| عیب | توضیحات |
|-----|---------|
| **افزایش پیچیدگی** | معرفی یک واسطه سربار عملیاتی اضافه می‌کند: استقرار، نظارت، پیکربندی، ارتقاء و برنامه‌ریزی ظرفیت. |
| **سازگاری نهایی** | از آنجا که ارتباط ناهمزمان است، سیستم به صورت نهایی سازگار است. مصرف‌کنندگان ممکن است رویدادها را با تأخیر پردازش کنند. برای پیش‌زمینه مصالحه‌های سازگاری، [قضیه CAP](../fundamentals/cap-theorem.md) را ببینید. |
| **دشواری اشکال‌زدایی** | ردیابی یک درخواست در چندین سرویس ناهمزمان سخت‌تر از دنبال کردن زنجیره فراخوانی همزمان است. ابزارهای ردیابی توزیع‌شده (Jaeger، Zipkin) ضروری هستند. |
| **چالش‌های ترتیب پیام** | ترتیب جهانی تضمین نمی‌شود. اطمینان از پردازش مرتب نیاز به پارتیشن‌بندی دقیق دارد و ممکن است موازی‌سازی را محدود کند. |
| **پیام‌های تکراری** | تحویل حداقل یک‌بار به این معنی است که مصرف‌کنندگان باید تکراری‌ها را مدیریت کنند (بی‌توانی). |
| **واسطه به عنوان نقطه شکست واحد** | اگر واسطه از کار بیفتد و خوشه‌بندی نشده باشد، تمام پیام‌رسانی متوقف می‌شود. پیکربندی دسترس‌پذیری بالا حیاتی است. |
| **تأخیر** | پیام‌رسانی ناهمزمان نسبت به فراخوانی‌های مستقیم همزمان تأخیر ایجاد می‌کند. برای سناریوهایی که نیاز به پاسخ فوری دارند مناسب نیست. |

### مقایسه پیام‌رسانی و RPI همزمان

| جنبه | پیام‌رسانی (ناهمزمان) | RPI — REST/gRPC (همزمان) |
|------|----------------------|--------------------------|
| **اتصال** | سست — تولیدکننده مصرف‌کننده را نمی‌شناسد | محکم — فراخواننده باید آدرس فراخوانده را بداند |
| **دسترس‌پذیری** | بالا — واسطه بافر می‌کند اگر مصرف‌کننده از کار بیفتد | پایین‌تر — فراخوانده باید در دسترس باشد |
| **تأخیر** | بالاتر (عبور از واسطه + پردازش ناهمزمان) | پایین‌تر (فراخوانی مستقیم) |
| **پیچیدگی** | بالاتر (زیرساخت واسطه) | پایین‌تر (فراخوانی HTTP/gRPC) |
| **مقیاس‌پذیری** | بهتر — مصرف‌کنندگان به طور مستقل مقیاس می‌شوند | محدود به ظرفیت فراخوانده |
| **مدیریت خطا** | DLQ، تلاش مجدد در سطح واسطه | Circuit Breaker، تلاش مجدد در سطح فراخواننده |
| **مورد استفاده** | رویدادها، وظایف ناهمزمان، fan-out | پرس‌وجوها، درخواست‌های بلادرنگ |

برای سناریوهایی که نیاز به پاسخ فوری دارند (مثلاً دریافت صفحه جزئیات محصول)، RPI همزمان مناسب‌تر است. برای رویدادهای fire-and-forget و اعلان‌های بین سرویسی، پیام‌رسانی انتخاب بهتری است. بسیاری از سیستم‌های دنیای واقعی از **هر دو الگو** با هم استفاده می‌کنند.

---

## ۷. الگوهای مرتبط

| الگو | رابطه |
|------|-------|
| **RPI (فراخوانی رویه راه دور)** | جایگزین همزمان پیام‌رسانی. سرویس‌ها یکدیگر را مستقیماً از طریق REST، gRPC یا GraphQL فراخوانی می‌کنند. ببینید [RPI](./rpi.md). |
| **Transactional Outbox** | اطمینان می‌دهد که یک سرویس به طور قابل اعتماد پیام‌ها را به صورت اتمی با نوشتن‌های پایگاه داده منتشر می‌کند. ببینید [Transactional Outbox](../messaging/transactional-outbox.md). |
| **معماری رویداد-محور** | پیام‌رسانی پایه [معماری رویداد-محور](../event-driven/event-driven-architecture.md) است و اعلان رویداد، انتقال وضعیت حامل رویداد و Event Sourcing را فعال می‌کند. |
| **Saga** | [الگوی Saga](../distributed-transactions/saga.md) از پیام‌رسانی (کوریوگرافی) یا ترکیبی از پیام‌رسانی و ارکستراسیون برای هماهنگی تراکنش‌های توزیع‌شده استفاده می‌کند. |
| **CQRS** | [CQRS](../data-patterns/cqrs.md) اغلب از پیام‌رسانی برای انتشار رویدادها از مدل نوشتن به مدل خواندن به صورت ناهمزمان استفاده می‌کند. |
| **پروتکل خاص دامنه** | الگوی ارتباطی جایگزین با استفاده از پروتکل‌های تخصصی برای دامنه‌های خاص. ببینید [Domain-Specific Protocol](./domain-specific-protocol.md). |
| **Circuit Breaker** | الگوی [Circuit Breaker](../resilience/circuit-breaker.md) در پیام‌رسانی کمتر مرتبط است (زیرا واسطه بافر می‌کند)، اما ممکن است زمانی استفاده شود که مصرف‌کننده سرویس‌های همزمان پایین‌دستی را فراخوانی می‌کند. |
| **مقایسه RabbitMQ و Kafka** | مقایسه دقیق دو فناوری پیام‌رسانی محبوب. ببینید [RabbitMQ vs Kafka](../messaging/rabbitmq-vs-kafka.md). |

---

## ۸. استفاده در دنیای واقعی

### پذیرش صنعتی

| شرکت | نحوه استفاده |
|------|-------------|
| **Netflix** | از Apache Kafka برای جریان رویداد بلادرنگ در صدها میکروسرویس استفاده می‌کند. رویدادها از طریق Kafka برای توصیه‌ها، نظارت و تحلیل جریان می‌یابند. |
| **Uber** | از Apache Kafka برای رویدادهای سفر، به‌روزرسانی موقعیت راننده و محاسبات قیمت‌گذاری پویا استفاده می‌کند. تریلیون‌ها پیام در روز پردازش می‌کند. |
| **LinkedIn** | در ابتدا Kafka را برای پردازش جریان فعالیت و تجمیع لاگ ایجاد کرد. از آن برای خط لوله داده اصلی استفاده می‌کند. |
| **Shopify** | از ترکیب Kafka و RabbitMQ استفاده می‌کند. Kafka برای جریان رویداد و خط لوله داده؛ RabbitMQ برای صف‌های کار پس‌زمینه. |
| **Airbnb** | از Kafka برای Event Sourcing و ارتباط بین سرویسی در سیستم‌های جستجو و قیمت‌گذاری خود استفاده می‌کند. |
| **Goldman Sachs** | از پیام‌رسانی (IBM MQ، Kafka) برای پردازش معاملات، محاسبات ریسک و گزارش‌دهی نظارتی استفاده می‌کند. |

### موارد استفاده رایج

- **پردازش سفارش**: رویدادهای سفارش سرویس‌های انبار، پرداخت، حمل و نقل و اعلان‌ها را فعال می‌کنند.
- **تحلیل‌های بلادرنگ**: جریان کلیک و رویدادهای رفتار کاربر از طریق Kafka به سیستم‌های تحلیل جریان می‌یابند.
- **تجمیع لاگ**: لاگ‌های برنامه به عنوان پیام منتشر شده و توسط ثبت متمرکز (ELK stack) مصرف می‌شوند.
- **جذب داده IoT**: داده‌های سنسور از طریق MQTT به واسطه منتشر شده و توسط خطوط لوله پردازش مصرف می‌شوند.
- **پردازش کار پس‌زمینه**: پیام‌های وظیفه (مانند تولید گزارش، تغییر اندازه تصویر) در صف قرار گرفته و توسط کارگران پردازش می‌شوند.
- **ضبط تغییرات داده (CDC)**: تغییرات پایگاه داده به عنوان رویداد ضبط شده و از طریق Kafka Connect یا Debezium به سرویس‌های پایین‌دستی جریان می‌یابند.

---

## ۹. خلاصه

پیام‌رسانی یک الگوی ارتباطی بنیادی برای ساخت سیستم‌های توزیع‌شده با اتصال سست، تاب‌آور و مقیاس‌پذیر است. با معرفی یک واسطه پیام بین سرویس‌ها، تولیدکنندگان را از مصرف‌کنندگان در زمان و مکان جدا می‌کند و پردازش ناهمزمان، تعادل بار و معماری‌های طبیعی رویداد-محور را فعال می‌سازد.

**نکات کلیدی:**

- از کانال‌های **نقطه به نقطه (صف)** برای پیام‌های فرمان و توزیع وظایف استفاده کنید.
- از کانال‌های **انتشار-اشتراک (تاپیک)** برای اعلان‌های رویداد و fan-out استفاده کنید.
- مصرف‌کنندگان را **بی‌توان** طراحی کنید تا تحویل حداقل یک‌بار را مدیریت کنند.
- از **کلیدهای پارتیشن** برای حفظ ترتیب پیام‌های مرتبط استفاده کنید.
- با الگوی [Transactional Outbox](../messaging/transactional-outbox.md) برای انتشار قابل اعتماد پیام ترکیب کنید.
- بین [RabbitMQ و Kafka](../messaging/rabbitmq-vs-kafka.md) بر اساس مورد استفاده خود (صف وظیفه در مقابل جریان رویداد) انتخاب کنید.
- پیام‌رسانی مکمل RPI همزمان است — بیشتر سیستم‌های دنیای واقعی از هر دو استفاده می‌کنند.

```
┌────────────────────────────────────────────────────────┐
│                 خلاصه الگوی پیام‌رسانی                  │
│                                                        │
│   چه زمانی از پیام‌رسانی استفاده کنیم:                 │
│   ✓ رویدادهای fire-and-forget                          │
│   ✓ Fan-out به چندین مصرف‌کننده                        │
│   ✓ تعادل بار و جذب جهش‌های ترافیک                    │
│   ✓ سرویس‌های جداشده و قابل استقرار مستقل             │
│   ✓ معماری رویداد-محور                                │
│                                                        │
│   چه زمانی RPI همزمان ترجیح دهیم:                     │
│   ✓ نیاز به پاسخ فوری (پرس‌وجوها)                     │
│   ✓ تعاملات ساده درخواست-پاسخ                          │
│   ✓ الزامات تأخیر پایین                               │
│   ✓ اشکال‌زدایی و ردیابی ساده‌تر                       │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

*برای مطالعه بیشتر، [معماری رویداد-محور](../event-driven/event-driven-architecture.md)، [مقایسه RabbitMQ و Kafka](../messaging/rabbitmq-vs-kafka.md)، [الگوی Saga](../distributed-transactions/saga.md) و [CQRS](../data-patterns/cqrs.md) را کاوش کنید.*
