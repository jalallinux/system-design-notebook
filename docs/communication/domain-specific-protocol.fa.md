# پروتکل خاص دامنه (Domain-Specific Protocol)

## ۱. مقدمه

در سیستم‌های توزیع‌شده، ارتباط بین سرویس‌ها معمولاً توسط پروتکل‌های عمومی مانند HTTP/REST و gRPC برای فراخوانی‌های همزمان، یا واسطه‌های پیام مانند RabbitMQ و Kafka برای پیام‌رسانی ناهمزمان انجام می‌شود. با این حال، برخی سناریوهای ارتباطی نیازمندی‌های منحصربه‌فردی دارند که این پروتکل‌های عمومی نمی‌توانند به طور کارآمد آن‌ها را برآورده کنند.

**پروتکل‌های خاص دامنه** پروتکل‌های ارتباطی تخصصی هستند که برای موارد استفاده خاص طراحی و بهینه‌سازی شده‌اند. آن‌ها دانش دامنه را مستقیماً در لایه پروتکل کدگذاری می‌کنند و عملکرد، معناشناسی و تجربه توسعه‌دهنده برتری برای سناریوهای هدف ارائه می‌دهند. مثال‌ها شامل SMTP برای ایمیل، MQTT برای دستگاه‌های IoT، وب‌سوکت برای ارتباط دوطرفه بلادرنگ و FIX برای معاملات مالی است.

این سند بررسی می‌کند که چه زمانی و چرا باید فراتر از پروتکل‌های عمومی بروید، پروتکل‌های خاص دامنه اصلی موجود، و نحوه انتخاب پروتکل مناسب برای سیستم شما.

## ۲. زمینه و مسئله

### زمینه

شما در حال طراحی یک سیستم توزیع‌شده هستید که سرویس‌ها نیاز به ارتباط دارند. شما قبلاً پروتکل‌های همزمان عمومی مانند [RPI](./rpi.md) (REST، gRPC) و پروتکل‌های ناهمزمان مانند [پیام‌رسانی](./messaging.md) (RabbitMQ، Kafka) را در نظر گرفته‌اید. با این حال، برخی نیازهای ارتباطی سیستم شما نیازمندی‌های تخصصی دارند.

### مسئله

پروتکل‌های عمومی مانند REST/HTTP یا صف پیام ممکن است برای الگوهای ارتباطی خاص **ناکارآمد یا ناکافی** باشند:

- **REST/HTTP** فقط درخواست-پاسخ است. نمی‌تواند بدون polling داده‌ها را از سرور به کلاینت ارسال کند، که آن را برای داشبوردهای بلادرنگ یا اعلان‌های زنده نامناسب می‌سازد.
- **gRPC** از streaming پشتیبانی می‌کند اما همچنان روی HTTP/2 کار می‌کند که ممکن است برای دستگاه‌های IoT محدود با پهنای باند و باتری کم، بیش از حد سنگین باشد.
- **واسطه‌های پیام سنتی** تأخیر و سربار زیرساختی اضافه می‌کنند که ممکن است برای جریان رسانه نظیر-به-نظیر یا معاملات مالی با تأخیر زیر میلی‌ثانیه غیرقابل قبول باشد.

```
تصویر مسئله:

    REST/HTTP (فقط درخواست-پاسخ)
    +---------+        +---------+
    | Client  | -----> | Server  |    کلاینت باید مکرراً
    |         | <----- |         |    برای به‌روزرسانی‌ها poll کند (ناکارآمد)
    +---------+        +---------+

    سنسورهای IoT (هزاران دستگاه محدود)
    +-------+  +-------+  +-------+
    |Sensor1|  |Sensor2|  |Sensor3|  ... x10,000
    +-------+  +-------+  +-------+
        |          |          |
        v          v          v
    سربار HTTP به ازای هر پیام = غیرقابل قبول
    (هدرها، TLS handshake، برقراری اتصال)
```

## ۳. نیروها

چندین نیرو به سمت اتخاذ پروتکل‌های خاص دامنه سوق می‌دهند:

| نیرو | توضیح |
|------|-------|
| **الزامات بلادرنگ** | برخی موارد استفاده نیاز به push از سمت سرور یا streaming دوطرفه با حداقل تأخیر دارند |
| **محدودیت‌های منابع** | دستگاه‌های IoT، کلاینت‌های موبایل یا سیستم‌های تعبیه‌شده CPU، حافظه و پهنای باند محدودی دارند |
| **الگوهای اتصال** | ارتباط نظیر-به-نظیر، fan-out از نوع pub-sub، یا اتصالات پایدار به خوبی به الگوی درخواست-پاسخ نگاشت نمی‌شوند |
| **حجم داده** | جریان‌های داده با فرکانس بالا (تله‌متری سنسور، داده بازار) سربار HTTP به ازای هر درخواست را تحت فشار قرار می‌دهند |
| **معناشناسی پروتکل** | دامنه‌هایی مانند ایمیل، معاملات مالی یا جریان رسانه معناشناسی خاصی دارند که از پشتیبانی در سطح پروتکل بهره می‌برند |
| **تضمین‌های قابلیت اطمینان** | برخی دامنه‌ها به سطوح QoS خاصی نیاز دارند (مثلاً at-most-once برای تله‌متری در مقابل exactly-once برای تراکنش‌ها) |
| **استانداردسازی** | پروتکل‌های سطح صنعت، قابلیت همکاری بین فروشندگان و سازمان‌ها را تضمین می‌کنند (مثلاً SMTP برای ایمیل، FIX برای معاملات) |

## ۴. راه‌حل

از **پروتکل‌های خاص دامنه** متناسب با نیازهای ارتباطی سیستم خود استفاده کنید. به جای اجبار تمام ارتباطات از طریق یک پروتکل عمومی واحد، پروتکل‌های تخصصی را برای سناریوهایی انتخاب کنید که مزایای واضحی ارائه می‌دهند.

### ماتریس مقایسه پروتکل‌ها

```
+------------------+-------------+-----------+------------+-----------+---------------+
| پروتکل          | جهت         | انتقال    | تأخیر      | سربار     | بهترین برای   |
+------------------+-------------+-----------+------------+-----------+---------------+
| HTTP/REST        | درخواست-    | TCP       | متوسط      | بالا      | APIهای CRUD   |
|                  | پاسخ        |           |            |           |               |
| gRPC             | دوطرفه     | HTTP/2    | کم-متوسط   | متوسط     | RPC سرویس    |
|                  | streaming   |           |            |           | به سرویس     |
| WebSocket        | دوطرفه     | TCP       | کم         | کم        | اپلیکیشن‌های |
|                  | full-duplex |           |            |           | بلادرنگ       |
| SSE              | push سرور  | HTTP/1.1  | کم         | کم        | فیدهای زنده  |
| MQTT             | Pub-Sub     | TCP       | کم         | بسیار کم  | دستگاه‌های   |
|                  |             |           |            |           | IoT           |
| AMQP             | Pub-Sub /   | TCP       | کم-متوسط   | متوسط     | پیام‌رسانی   |
|                  | صف‌بندی    |           |            |           | سازمانی      |
| WebRTC           | نظیر-به-   | UDP/SRTP  | بسیار کم   | متوسط     | جریان        |
|                  | نظیر        |           |            |           | رسانه        |
| SMTP             | ذخیره-و-   | TCP       | بالا       | متوسط     | تحویل        |
|                  | ارسال       |           |            |           | ایمیل        |
| FIX              | درخواست-   | TCP       | بسیار کم   | کم        | معاملات       |
|                  | پاسخ/Stream |           |            |           | مالی          |
| GraphQL Subs     | push سرور  | WebSocket | کم         | متوسط     | کوئری‌های    |
|                  |             |           |            |           | بلادرنگ       |
+------------------+-------------+-----------+------------+-----------+---------------+
```

### ۴.۱ وب‌سوکت (WebSocket)

وب‌سوکت **ارتباط دوطرفه full-duplex** را روی یک اتصال TCP پایدار فراهم می‌کند. پس از یک handshake اولیه HTTP، اتصال ارتقا می‌یابد و هم کلاینت و هم سرور می‌توانند در هر زمانی به طور مستقل پیام ارسال کنند.

```
مقایسه WebSocket در مقابل REST:

REST (Polling برای به‌روزرسانی‌ها):
Client  ----GET /updates----->  Server     (بدون داده)
Client  ----GET /updates----->  Server     (بدون داده)
Client  ----GET /updates----->  Server     (داده!)
Client  ----GET /updates----->  Server     (بدون داده)
        ۴ درخواست، ۱ پاسخ مفید

WebSocket (اتصال پایدار):
Client  ====UPGRADE==========>  Server
Client  <==== message ========  Server     (داده فوراً push می‌شود)
Client  ===== message =======>  Server     (کلاینت هم می‌تواند ارسال کند)
Client  <==== message ========  Server     (داده فوراً push می‌شود)
        ۱ اتصال، ۰ درخواست هدررفته
```

**چه زمانی استفاده شود:** اپلیکیشن‌های چت، داشبوردهای زنده، ویرایش مشارکتی، بازی، اعلان‌های بلادرنگ.

### ۴.۲ رویدادهای ارسالی سرور (SSE)

SSE یک کانال **push یک‌طرفه از سرور به کلاینت** روی HTTP استاندارد فراهم می‌کند. برخلاف وب‌سوکت، از یک اتصال HTTP معمولی استفاده می‌کند و به طور بومی توسط مرورگرها از طریق API `EventSource` پشتیبانی می‌شود.

**چه زمانی استفاده شود:** فیدهای زنده، تیکرهای سهام، به‌روزرسانی‌های پیشرفت، جریان‌های اعلان که فقط push از سرور به کلاینت مورد نیاز است.

**SSE در مقابل WebSocket:** زمانی SSE را انتخاب کنید که فقط به push سرور نیاز دارید (راه‌اندازی ساده‌تر، اتصال مجدد خودکار، کار از طریق پروکسی‌های HTTP). زمانی WebSocket را انتخاب کنید که به ارتباط دوطرفه نیاز دارید.

### ۴.۳ MQTT (پروتکل انتقال تله‌متری صف پیام)

MQTT یک پروتکل **انتشار-اشتراک بسیار سبک** است که برای دستگاه‌های محدود و شبکه‌های غیرقابل اعتماد طراحی شده است. از حداقل پهنای باند استفاده می‌کند و از سه سطح کیفیت سرویس (QoS) پشتیبانی می‌کند.

```
معماری MQTT:

  +----------+         +-------------+         +----------+
  | Sensor A | --pub-> |             | --sub-> | Dashboard|
  +----------+   topic |   MQTT      |  topic  +----------+
  +----------+  /temp  |   Broker    | /temp   +----------+
  | Sensor B | --pub-> |             | --sub-> | Alert    |
  +----------+         +-------------+         | Service  |
                            |                  +----------+
                       سطوح QoS:
                       0 = حداکثر یک‌بار  (ارسال و فراموش)
                       1 = حداقل یک‌بار  (تأیید شده)
                       2 = دقیقاً یک‌بار (handshake چهار مرحله‌ای)
```

**مقایسه اندازه بسته:**
- حداقل درخواست HTTP: حدود ۳۰۰-۷۰۰ بایت (فقط هدرها)
- حداقل PUBLISH در MQTT: **۲ بایت** (فقط هدر ثابت)

**چه زمانی استفاده شود:** شبکه‌های سنسور IoT، اتوماسیون خانگی، تله‌متری خودرو، اپلیکیشن‌های موبایل با اتصال غیرقابل اعتماد.

### ۴.۴ AMQP (پروتکل پیشرفته صف پیام)

AMQP یک **پروتکل سطح سیم** برای میان‌افزار پیام‌محور سازمانی است. برخلاف سادگی MQTT، AMQP ویژگی‌های غنی شامل exchange‌ها، binding‌ها، مسیریابی، تراکنش‌ها و امنیت فراهم می‌کند. RabbitMQ محبوب‌ترین پیاده‌سازی AMQP است.

**چه زمانی استفاده شود:** یکپارچه‌سازی سازمانی، مسیریابی پیچیده پیام، سیستم‌هایی که نیاز به تراکنش و تأیید در سطح پیام دارند.

### ۴.۵ اشتراک‌های GraphQL

اشتراک‌های GraphQL زبان کوئری GraphQL را با **قابلیت‌های بلادرنگ** گسترش می‌دهند. کلاینت‌ها با استفاده از همان سینتکس کوئری که برای خواندن معمولی استفاده می‌کنند، در تغییرات داده خاص مشترک می‌شوند و به‌روزرسانی‌ها را از طریق اتصال وب‌سوکت دریافت می‌کنند.

**چه زمانی استفاده شود:** اپلیکیشن‌هایی که قبلاً از GraphQL استفاده می‌کنند و به به‌روزرسانی‌های بلادرنگ برای نتایج کوئری خاص نیاز دارند.

### ۴.۶ WebRTC (ارتباط بلادرنگ وب)

WebRTC ارتباط **نظیر-به-نظیر** صدا، ویدئو و داده را مستقیماً بین مرورگرها یا دستگاه‌ها فراهم می‌کند و سرور را برای انتقال رسانه دور می‌زند.

```
برقراری اتصال WebRTC:

  +--------+                              +--------+
  | Peer A |                              | Peer B |
  +--------+                              +--------+
      |     1. Offer (SDP) از طریق Signaling  |
      | -------- Server ------------------>   |
      |     2. Answer (SDP) از طریق Signaling |
      | <------- Server -------------------   |
      |     3. تبادل ICE Candidates           |
      | <--------- STUN/TURN ------------>    |
      |                                       |
      |     4. جریان رسانه مستقیم P2P         |
      | <================================>    |
      |     (UDP/SRTP - بدون نیاز به سرور)   |
```

**چه زمانی استفاده شود:** ویدئو کنفرانس، تماس صوتی، اشتراک‌گذاری فایل نظیر-به-نظیر، اشتراک‌گذاری صفحه، بازی با تأخیر کم.

### ۴.۷ SMTP (پروتکل ساده انتقال ایمیل)

SMTP استاندارد اینترنت برای **انتقال ایمیل** است. از مدل ذخیره-و-ارسال استفاده می‌کند که در آن سرورهای ایمیل پیام‌ها را گام به گام ارسال می‌کنند تا به سرور ایمیل مقصد برسند.

**چه زمانی استفاده شود:** تحویل ایمیل (هیچ جایگزین عملی برای ایمیل اینترنتی وجود ندارد).

### ۴.۸ FIX (تبادل اطلاعات مالی)

FIX استاندارد پیام‌رسانی بالفعل برای صنعت **معاملات مالی** است. انواع پیام از پیش تعریف شده برای سفارشات، اجراها، داده بازار و تخصیص معاملات با ترتیب‌بندی دقیق و تحویل تضمین‌شده فراهم می‌کند.

**چه زمانی استفاده شود:** پلتفرم‌های معاملات الکترونیک، سیستم‌های مدیریت سفارش، توزیع داده بازار در خدمات مالی.

### معیارهای انتخاب پروتکل

هنگام انتخاب پروتکل، این ابعاد را ارزیابی کنید:

```
ماتریس تصمیم‌گیری:

                        تأخیر کم
                            |
                  WebRTC    |    FIX
                  WebSocket |    MQTT
                            |
   دوطرفه -----------------+----------- یک‌طرفه
                            |
                  AMQP      |    SSE
                  gRPC      |    SMTP
                            |
                       تأخیر بالا


   مرحله ۱: جهت ارتباط چیست؟
           دوطرفه        --> WebSocket, WebRTC, gRPC
           push سرور     --> SSE, MQTT, GraphQL Subs
           درخواست-پاسخ  --> REST, gRPC

   مرحله ۲: محدودیت‌های کلاینت چیست؟
           IoT محدود     --> MQTT
           مرورگر         --> WebSocket, SSE, WebRTC
           سرور-به-سرور  --> gRPC, AMQP

   مرحله ۳: چه تأخیری قابل قبول است؟
           زیر میلی‌ثانیه --> FIX, TCP سفارشی
           کم (1-50ms)    --> WebSocket, MQTT, WebRTC
           متوسط (50-500ms) --> gRPC, AMQP
           بالا (ثانیه+)  --> REST, SMTP

   مرحله ۴: چه تضمین قابلیت اطمینانی مورد نیاز است؟
           حداکثر یک‌بار  --> MQTT QoS 0, UDP
           حداقل یک‌بار  --> MQTT QoS 1, AMQP
           دقیقاً یک‌بار --> MQTT QoS 2, FIX
```

## ۵. مثال

### کارخانه هوشمند IoT: معماری چند پروتکلی

یک سیستم کارخانه هوشمند را در نظر بگیرید که تجهیزات را نظارت می‌کند، داشبورد بلادرنگ برای اپراتورها فراهم می‌کند و هشدار ارسال می‌کند.

```
نمای کلی معماری:

  +----------+  +----------+  +----------+
  | Temp     |  | Pressure |  | Vibration|    (هزاران سنسور)
  | Sensor   |  | Sensor   |  | Sensor   |
  +----+-----+  +----+-----+  +----+-----+
       |              |              |
       |   MQTT (QoS 1, سبک‌وزن)    |
       v              v              v
  +-----------------------------------+
  |           MQTT Broker             |
  |         (e.g., Mosquitto)         |
  +--------+----------+--------------+
           |          |
           v          v
  +--------+--+  +----+---------+         +-----------------+
  | Data       |  | Alert       |         | Operator        |
  | Ingestion  |  | Engine      |         | Dashboard       |
  | Service    |  | (نظارت بر  |         | (مرورگر)        |
  |            |  |  آستانه)    |         |                 |
  +--------+---+  +-----+------+         +-------+---------+
           |             |                        |
           |  REST API   |  SMTP (هشدار ایمیلی)   | WebSocket
           |  (ذخیره در  |  + SMS Gateway         | (به‌روزرسانی
           |  TimescaleDB)|                       |  بلادرنگ)
           v             v                        v
  +--------+---+  +------+-------+  +-------------+------+
  | Time-Series|  | Notification |  | WebSocket Server   |
  | Database   |  | Service      |  | (push داده زنده   |
  |            |  |              |  |  به داشبورد)       |
  +------------+  +--------------+  +--------------------+
```

**توضیح انتخاب پروتکل‌ها:**

| لایه | پروتکل | چرا |
|------|---------|-----|
| سنسورها به Broker | MQTT QoS 1 | سنسورها محدود هستند (توان کم، پهنای باند محدود). سربار ۲ بایتی MQTT ایده‌آل است. QoS 1 تحویل حداقل یک‌بار را تضمین می‌کند |
| Broker به سرویس‌ها | اشتراک MQTT | سرویس‌ها در تاپیک‌های مرتبط برای پردازش بلادرنگ مشترک می‌شوند |
| دریافت داده به DB | REST/HTTP | ذخیره‌سازی CRUD استاندارد؛ نیازی به بلادرنگ برای نوشتن نیست |
| هشدارها | SMTP + SMS | ایمیل استاندارد تحویل هشدار است؛ SMS برای هشدارهای بحرانی |
| داشبورد | WebSocket | اپراتورها به به‌روزرسانی‌های بلادرنگ بدون بارگذاری مجدد صفحه نیاز دارند. دوطرفه بودن امکان تغییر فیلترها را فراهم می‌کند |

### مثال جریان پیام

```
سنسور خوانش دما را منتشر می‌کند:

1. Sensor -> MQTT Broker
   Topic: factory/floor-2/machine-42/temperature
   Payload: {"value": 87.3, "unit": "C", "ts": 1706900000}
   QoS: 1 (حداقل یک‌بار)
   اندازه بسته: حدود ۸۰ بایت

2. MQTT Broker -> Alert Engine (مشترک)
   قانون: IF temperature > 85 THEN alert
   اقدام: ارسال ایمیل SMTP به تیم نگهداری

3. MQTT Broker -> Data Ingestion Service (مشترک)
   اقدام: POST به TimescaleDB از طریق REST

4. Data Ingestion -> WebSocket Server -> Dashboard
   Push: {"machine": "42", "temp": 87.3, "status": "WARNING"}
   داشبورد در کمتر از ۱۰۰ میلی‌ثانیه از خوانش سنسور به‌روز می‌شود
```

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیح |
|------|-------|
| **عملکرد بهینه** | هر پروتکل برای سناریوی هدف خود تنظیم شده است (مثلاً هدر ۲ بایتی MQTT در مقابل هدرهای حدود ۷۰۰ بایتی HTTP) |
| **معناشناسی بهتر** | پشتیبانی در سطح پروتکل از مفاهیم دامنه (سطوح QoS، سلسله‌مراتب تاپیک، کشف نظیر) پیچیدگی سطح اپلیکیشن را کاهش می‌دهد |
| **بهره‌وری منابع** | دستگاه‌های محدود می‌توانند بدون سربار پروتکل‌های عمومی در سیستم شرکت کنند |
| **استانداردسازی صنعتی** | پروتکل‌های دامنه (SMTP، FIX، AMQP) قابلیت همکاری بین فروشندگان و سازمان‌ها را تضمین می‌کنند |
| **قابلیت اطمینان مناسب** | تضمین تحویل دقیقاً مورد نیاز را انتخاب کنید (ارسال و فراموش برای تله‌متری، دقیقاً یک‌بار برای معاملات) |
| **بهره‌برداری از تخصص دامنه** | دهه‌ها بهینه‌سازی خاص دامنه (مثلاً ۳۰+ سال پروتکل FIX در بازارهای مالی) |

### معایب

| عیب | توضیح |
|-----|-------|
| **اکوسیستم کوچک‌تر** | کتابخانه‌ها، ابزارها و منابع جامعه کمتر در مقایسه با HTTP/REST |
| **دانش تخصصی** | اعضای تیم به تخصص خاص پروتکل نیاز دارند؛ استخدام برای پروتکل‌های خاص دشوارتر است |
| **شکاف‌های ابزاری** | ابزارهای اشکال‌زدایی، نظارت و مشاهده‌پذیری ممکن است نسبت به معادل‌های HTTP کمتر بالغ باشند |
| **چالش‌های قابلیت همکاری** | اتصال سیستم‌هایی که از پروتکل‌های دامنه مختلف استفاده می‌کنند نیاز به لایه‌های ترجمه یا gateway دارد |
| **پیچیدگی عملیاتی** | اجرا و مدیریت broker/serverهای خاص پروتکل (MQTT broker، سرور WebSocket، سرور TURN) بار زیرساختی اضافه می‌کند |
| **ریسک وابستگی به فروشنده** | برخی پیاده‌سازی‌های پروتکل به فروشندگان یا پلتفرم‌های خاص وابسته هستند |
| **مشکلات Gateway/Proxy** | فایروال‌ها و پروکسی‌های شرکتی ممکن است پروتکل‌های غیر HTTP را مسدود کنند؛ WebSocket و MQTT از طریق WebSocket به کاهش این مشکل کمک می‌کنند |

### چه زمانی از پروتکل‌های خاص دامنه استفاده کنیم

```
از پروتکل‌های خاص دامنه استفاده کنید وقتی:

  [x] پروتکل‌های عمومی گلوگاه‌های قابل اندازه‌گیری ایجاد می‌کنند
  [x] دامنه یک پروتکل استاندارد مستقر دارد (ایمیل=SMTP، معاملات=FIX)
  [x] محدودیت‌های کلاینت HTTP را غیرعملی می‌سازد (IoT، تعبیه‌شده)
  [x] ارتباط دوطرفه بلادرنگ یک نیاز اصلی است
  [x] ارتباط نظیر-به-نظیر مورد نیاز است (WebRTC)
  [x] به کنترل QoS دقیق به ازای هر پیام نیاز دارید

با پروتکل‌های عمومی بمانید وقتی:

  [x] عملیات CRUD استاندارد الگوی اصلی هستند
  [x] تیم تخصص در پروتکل تخصصی را ندارد
  [x] سیستم به اندازه کافی ساده است که polling HTTP قابل قبول است
  [x] قابلیت همکاری با سیستم‌های خارجی متعدد حیاتی است
  [x] سادگی اشکال‌زدایی و در دسترس بودن ابزار اولویت‌ها هستند
```

## ۷. الگوهای مرتبط

| الگو | رابطه |
|------|-------|
| [RPI (فراخوانی رویه از راه دور)](./rpi.md) | الگوی پروتکل همزمان عمومی؛ پروتکل‌های خاص دامنه مواردی را پوشش می‌دهند که RPI ناکافی است |
| [پیام‌رسانی](./messaging.md) | الگوی پروتکل ناهمزمان عمومی؛ MQTT و AMQP اصلاحات خاص دامنه پیام‌رسانی هستند |
| API Gateway | می‌تواند به عنوان لایه ترجمه پروتکل عمل کند و بین پروتکل‌های سمت کلاینت (WebSocket) و پروتکل‌های داخلی (gRPC، AMQP) تبدیل کند |
| Backend for Frontend (BFF) | فرانت‌اندهای مختلف ممکن است به پروتکل‌های مختلف نیاز داشته باشند (WebSocket برای وب، MQTT برای اپلیکیشن همراه IoT) |
| معماری رویداد-محور | پروتکل‌های خاص دامنه مانند MQTT و AMQP اغلب لایه انتقال سیستم‌های رویداد-محور هستند |
| Circuit Breaker | الگوهای تاب‌آوری برای اتصالات پروتکل خاص دامنه نیز اعمال می‌شوند (مثلاً منطق اتصال مجدد برای WebSocket) |

## ۸. استفاده در دنیای واقعی

| شرکت/سیستم | پروتکل | مورد استفاده |
|-------------|---------|-------------|
| **WhatsApp** | مبتنی بر XMPP سفارشی | پیام‌رسانی در مقیاس با حداقل استفاده از پهنای باند؛ پروتکل اصلاح‌شده آن‌ها روزانه میلیاردها پیام را مدیریت می‌کند |
| **Slack** | WebSocket | تحویل پیام بلادرنگ به کلاینت‌های متصل؛ در صورت عدم دسترسی WebSocket به polling بازمی‌گردد |
| **Bloomberg Terminal** | FIX + اختصاصی | توزیع داده بازار مالی با الزامات تأخیر زیر میلی‌ثانیه |
| **AWS IoT Core** | MQTT | اتصال میلیاردها دستگاه IoT؛ پشتیبانی از MQTT 3.1.1 و 5.0 با device shadow برای وضعیت آفلاین |
| **Zoom** | WebRTC + سفارشی | ویدئو کنفرانس با استفاده از WebRTC برای اتصالات نظیر و پروتکل‌های سفارشی برای جلسات بزرگ واسطه سرور |
| **Robinhood** | FIX | اجرای سفارش و فیدهای داده بازار متصل به بورس‌های سهام |
| **Tesla** | MQTT | جمع‌آوری داده تله‌متری خودرو از میلیون‌ها خودرو به پلتفرم داده مرکزی |
| **Discord** | WebSocket + WebRTC | WebSocket برای حضور چت و رویدادها؛ WebRTC برای کانال‌های صوتی |
| **Google Gmail** | SMTP + IMAP | پروتکل‌های ایمیل استاندارد برای ارسال (SMTP) و دریافت (IMAP) در سراسر اینترنت |
| **Home Assistant** | MQTT | هاب اتوماسیون خانه هوشمند با استفاده از MQTT برای ارتباط با هزاران نوع دستگاه IoT |

## ۹. خلاصه

پروتکل‌های خاص دامنه شکاف‌هایی را پر می‌کنند که پروتکل‌های عمومی (REST، gRPC، پیام‌رسانی سنتی) باز می‌گذارند. آن‌ها جایگزین پروتکل‌های عمومی نیستند بلکه **مکمل‌هایی** هستند که در بخش‌های خاصی از سیستم استفاده می‌شوند که رفتار تخصصی مورد نیاز است.

**نکات کلیدی:**

1. **با پروتکل‌های عمومی شروع کنید** ([RPI](./rpi.md) برای همزمان، [پیام‌رسانی](./messaging.md) برای ناهمزمان) و فقط زمانی پروتکل‌های خاص دامنه را اتخاذ کنید که نیاز واضح و قابل اندازه‌گیری وجود دارد.
2. **پروتکل را با دامنه تطبیق دهید**: MQTT برای IoT، WebSocket برای اپلیکیشن‌های وب بلادرنگ، FIX برای معاملات، SMTP برای ایمیل، WebRTC برای رسانه نظیر-به-نظیر.
3. **مصالحه‌ها را در نظر بگیرید**: عملکرد و معناشناسی بهتر با هزینه ابزار تخصصی، الزامات دانش و پیچیدگی عملیاتی همراه است.
4. **معماری‌های چند پروتکلی طبیعی هستند**: سیستم‌های دنیای واقعی معمولاً از ۳ تا ۵ پروتکل مختلف استفاده می‌کنند که هر کدام یک نیاز ارتباطی خاص را برآورده می‌کنند.
5. **gatewayهای ترجمه پروتکل** (API Gateway، پل‌های پروتکل) هنگام ترکیب چند پروتکل در یک سیستم واحد ضروری هستند.

```
درخت تصمیم خلاصه:

   نیاز به ارتباط دارید؟
         |
         v
   آیا REST/HTTP کافی است؟
   |                    |
  بله                  خیر
   |                    |
   REST را           آیا فقط push سرور است؟
   استفاده کنید     |                   |
                  بله                  خیر
                   |                    |
                  SSE            آیا رسانه P2P است؟
                               |              |
                              بله            خیر
                               |              |
                            WebRTC      آیا کلاینت‌ها محدود هستند؟
                                        |                |
                                       بله              خیر
                                        |                |
                                      MQTT          WebSocket
                                                   (یا gRPC streaming)
```

---

*پروتکل‌های خاص دامنه اصل "ابزار مناسب برای کار مناسب" هستند که در ارتباط بین سرویس‌ها و کلاینت-سرور اعمال شده‌اند. دانستن اینکه چه زمانی فراتر از REST و gRPC بروید، نشانه طراحی بالغ سیستم توزیع‌شده است.*
