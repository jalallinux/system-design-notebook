# الگوی Transactional Outbox

## ۱. مقدمه

در معماری میکروسرویس‌ها که هر سرویس مالک پایگاه داده خود است (الگوی **Database per Service**)، یکی از مهم‌ترین چالش‌ها اطمینان از این است که یک سرویس بتواند **به صورت اتمیک پایگاه داده خود را به‌روزرسانی کند و یک رویداد یا پیام منتشر کند**. الگوی **Transactional Outbox** این مشکل را با استفاده از تراکنش محلی پایگاه داده حل می‌کند تا تحویل قابل اعتماد پیام بدون نیاز به تراکنش‌های توزیع‌شده تضمین شود.

به جای انتشار مستقیم رویدادها به واسطه پیام (مانند [RabbitMQ یا Kafka](./rabbitmq-vs-kafka.fa.md))، سرویس رویداد را در یک **جدول outbox** ویژه در همان تراکنش پایگاه داده‌ای که تغییر وضعیت کسب‌وکار را ذخیره می‌کند، می‌نویسد. سپس یک فرآیند جداگانه از جدول outbox می‌خواند و رویدادها را به واسطه پیام منتشر می‌کند.

این الگو یکی از سنگ‌بناهای [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) قابل اعتماد است و به طور گسترده در سیستم‌های تولیدی استفاده می‌شود.

---

## ۲. زمینه و مسئله

### زمینه

یک سیستم میکروسرویس‌ها را در نظر بگیرید که:

- هر سرویس پایگاه داده مخصوص خود را دارد (الگوی **Database per Service**).
- سرویس‌ها باید تغییرات وضعیت را از طریق رویدادها یا پیام‌ها به سرویس‌های دیگر اطلاع دهند.
- سیستم برای ارتباط ناهمزمان به یک واسطه پیام (Kafka، RabbitMQ و غیره) متکی است.

### مشکل نوشتن دوگانه (Dual Write)

وقتی یک سرویس نیاز به به‌روزرسانی پایگاه داده خود **و** انتشار یک پیام دارد، دو عملیات مجزا روی دو سیستم متفاوت انجام می‌دهد. این به عنوان **مشکل نوشتن دوگانه** (Dual Write Problem) شناخته می‌شود.

```
                         مشکل نوشتن دوگانه
  ┌─────────────┐
  │             │   1. نوشتن در DB        ┌──────────────┐
  │   سرویس     │ ───────────────────────>│   پایگاه داده │  ✅ موفق
  │   سفارش     │                         └──────────────┘
  │             │   2. انتشار رویداد       ┌──────────────┐
  │             │ ────────────────────────>│ واسطه         │  ❌ شکست!
  └─────────────┘                         │ پیام          │
                                          └──────────────┘

  نتیجه: پایگاه داده به‌روز شده، اما هیچ رویدادی منتشر نشده.
         سرویس‌های دیگر هرگز از تغییر مطلع نمی‌شوند.
         سیستم اکنون ناسازگار است.
```

**چه چیزی ممکن است اشتباه برود:**

| سناریو | نوشتن در DB | انتشار پیام | نتیجه |
|---------|------------|-------------|-------|
| مسیر موفق | موفق | موفق | سازگار |
| واسطه از دسترس خارج | موفق | شکست | DB به‌روز شده، رویدادی منتشر نشده |
| کرش سرویس پس از نوشتن DB | موفق | هرگز تلاش نشده | DB به‌روز شده، رویدادی منتشر نشده |
| DB از دسترس خارج | شکست | موفق | رویداد منتشر شده، اما تغییری در DB نیست |
| پارتیشن شبکه | موفق | تایم‌اوت / نامشخص | وضعیت نامشخص |

مشکل اساسی این است که **به‌روزرسانی پایگاه داده و انتشار پیام دو عملیات جداگانه هستند که بدون پروتکل تراکنش توزیع‌شده نمی‌توانند اتمیک شوند**. استفاده از [Two-Phase Commit (2PC)](../distributed-transactions/two-phase-commit.fa.md) بین پایگاه داده و واسطه پیام عملی نیست زیرا اکثر واسطه‌های پیام از XA/2PC پشتیبانی نمی‌کنند و عملکرد و دسترس‌پذیری را به شدت تحت تأثیر قرار می‌دهد.

---

## ۳. نیروها

نیروهای زیر نیاز به این الگو را شکل می‌دهند:

- **اتمی بودن**: تغییر وضعیت کسب‌وکار و انتشار رویداد باید هر دو موفق شوند یا هر دو شکست بخورند. تکمیل جزئی منجر به ناسازگاری سیستم می‌شود.
- **بدون تراکنش توزیع‌شده**: 2PC بین پایگاه داده و واسطه پیام عملی نیست، توسط بسیاری از واسطه‌ها پشتیبانی نمی‌شود و به دسترس‌پذیری آسیب می‌رساند (نقض مصالحه‌های [قضیه CAP](../fundamentals/cap-theorem.fa.md)).
- **قابلیت اطمینان**: رویدادها نباید از دست بروند. سرویس‌های دیگر برای حفظ وضعیت خود به دریافت رویدادها وابسته هستند (مثلاً در جریان‌های کاری [Saga](../distributed-transactions/saga.fa.md) یا به‌روزرسانی‌های مدل خواندن [CQRS](../data-patterns/cqrs.fa.md)).
- **ترتیب**: رویدادها در حالت ایده‌آل باید به ترتیبی که ایجاد شده‌اند منتشر شوند.
- **عملکرد**: راه‌حل نباید عملکرد عملیات اصلی کسب‌وکار را به طور قابل توجهی کاهش دهد.
- **سادگی**: راه‌حل باید برای تیم توسعه قابل درک و نگهداری باشد.

---

## ۴. راه‌حل

### ایده اصلی

به جای انتشار مستقیم رویدادها به واسطه پیام، سرویس رویداد را در یک **جدول outbox** در **همان تراکنش محلی پایگاه داده** همراه با تغییر داده‌های کسب‌وکار می‌نویسد. سپس یک مؤلفه جداگانه جدول outbox را می‌خواند و رویدادها را به واسطه پیام منتشر می‌کند.

```
                    الگوی Transactional Outbox
  ┌─────────────┐
  │             │      BEGIN TRANSACTION
  │   سرویس     │   1. INSERT INTO orders (...)        ┌──────────────┐
  │   سفارش     │ ────────────────────────────────────>│              │
  │             │   2. INSERT INTO outbox (...)         │   پایگاه داده │
  │             │ ────────────────────────────────────>│              │
  │             │      COMMIT                          └──────┬───────┘
  └─────────────┘                                             │
                                                              │ خواندن
                                                              │ outbox
  ┌─────────────┐                                             │
  │  فرآیند     │      3. خواندن رویداد       ┌──────────────▼───────┐
  │  رله پیام   │ <───────────────────────────│   جدول Outbox       │
  │             │                              └──────────────────────┘
  │             │      4. انتشار به واسطه       ┌──────────────┐
  │             │ ────────────────────────────>│ واسطه         │
  └─────────────┘                              │ پیام          │
                                               └──────────────┘
```

چون هر دو عملیات نوشتن داده‌های کسب‌وکار و ورودی outbox در **یک تراکنش ACID** هستند، تضمین می‌شود که هر دو موفق شوند یا هر دو شکست بخورند. فرآیند رله پیام مسئول خواندن رویدادهای منتشر نشده از outbox و ارسال آن‌ها به واسطه پیام است.

### ساختار جدول Outbox

جدول outbox رویدادهایی که باید منتشر شوند را ذخیره می‌کند. یک ساختار معمول:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         جدول outbox                                 │
├───────────────┬──────────────┬──────────────────────────────────────┤
│ ستون          │ نوع          │ توضیحات                              │
├───────────────┼──────────────┼──────────────────────────────────────┤
│ id            │ UUID / BIGINT│ شناسه منحصربه‌فرد رویداد              │
│ aggregate_type│ VARCHAR(255) │ نوع aggregate (مثلاً "Order")        │
│ aggregate_id  │ VARCHAR(255) │ شناسه نمونه aggregate                │
│ event_type    │ VARCHAR(255) │ نوع رویداد (مثلاً "OrderCreated")    │
│ payload       │ JSON / TEXT  │ داده‌های سریالایز شده رویداد          │
│ created_at    │ TIMESTAMP    │ زمان ایجاد رویداد                     │
│ published_at  │ TIMESTAMP    │ زمان انتشار رویداد (NULL اگر هنوز    │
│               │              │ منتشر نشده)                          │
└───────────────┴──────────────┴──────────────────────────────────────┘
```

**مثال SQL DDL:**

```sql
CREATE TABLE outbox (
    id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    aggregate_type VARCHAR(255) NOT NULL,
    aggregate_id   VARCHAR(255) NOT NULL,
    event_type     VARCHAR(255) NOT NULL,
    payload        JSONB NOT NULL,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW(),
    published_at   TIMESTAMP NULL
);

CREATE INDEX idx_outbox_unpublished ON outbox (created_at)
    WHERE published_at IS NULL;
```

### دو مکانیزم تحویل

پس از قرار گرفتن رویدادها در جدول outbox، باید به واسطه پیام تحویل داده شوند. دو رویکرد اصلی وجود دارد:

#### ۱. ناشر نظرسنجی (Polling Publisher)

یک فرآیند پس‌زمینه به صورت دوره‌ای جدول outbox را برای رویدادهای منتشر نشده **نظرسنجی** می‌کند، آن‌ها را منتشر می‌کند و به عنوان منتشر شده علامت‌گذاری می‌کند.

```
┌────────────────┐    SELECT * FROM outbox     ┌────────────┐
│   Polling      │    WHERE published_at IS NULL│            │
│   Publisher    │ <──────────────────────────  │  پایگاه داده│
│   (cron/worker)│                              │            │
│                │    UPDATE outbox SET          └────────────┘
│                │    published_at = NOW()
│                │
│                │    انتشار پیام                ┌────────────┐
│                │ ─────────────────────────────>│  واسطه     │
└────────────────┘                               │  پیام      │
                                                 └────────────┘
```

**مزایا:** ساده برای پیاده‌سازی، با هر پایگاه داده‌ای کار می‌کند.
**معایب:** تأخیر ناشی از نظرسنجی، بار اضافی روی پایگاه داده، مقیاس‌پذیری دشوارتر.

> برای بررسی دقیق‌تر، [Polling Publisher](./polling-publisher.fa.md) را ببینید.

#### ۲. دنباله‌روی از لاگ تراکنش (Transaction Log Tailing / CDC)

به جای نظرسنجی، یک ابزار **Change Data Capture (CDC)** لاگ تراکنش پایگاه داده (WAL در PostgreSQL، binlog در MySQL) را نظارت می‌کند و درج‌های جدید به جدول outbox را تقریباً بلادرنگ ضبط می‌کند.

```
┌────────────────┐    خواندن لاگ تراکنش        ┌────────────┐
│   ابزار CDC    │ <─────────────────────────  │  پایگاه داده│
│   (Debezium)   │    (WAL / binlog)           │            │
│                │                              └────────────┘
│                │    انتشار پیام               ┌────────────┐
│                │ ────────────────────────────>│  واسطه     │
└────────────────┘                              │  پیام      │
                                                └────────────┘
```

**مزایا:** تحویل تقریباً بلادرنگ، بدون سربار نظرسنجی، بدون کوئری اضافی روی پایگاه داده.
**معایب:** زیرساخت پیچیده‌تر (نیاز به ابزار CDC)، پیاده‌سازی وابسته به نوع پایگاه داده.

> برای بررسی دقیق‌تر، [Transaction Log Tailing](./transaction-log-tailing.fa.md) را ببینید.

### تحویل دقیقاً-یک‌بار و بی‌تکراری (Idempotency)

الگوی outbox تحویل **حداقل-یک‌بار** (at-least-once) به واسطه پیام را تضمین می‌کند. اما در سناریوهای شکست (مثلاً فرآیند رله پس از انتشار اما قبل از علامت‌گذاری رویداد به عنوان منتشر شده کرش کند)، ممکن است همان رویداد بیش از یک بار منتشر شود.

برای دستیابی به پردازش **عملاً دقیقاً-یک‌بار**، مصرف‌کنندگان باید **بی‌تکرار** (idempotent) باشند:

- از `id` رویداد به عنوان کلید حذف تکرار استفاده کنید.
- شناسه رویدادهای پردازش شده را در پایگاه داده مصرف‌کننده ذخیره کنید.
- عملیات‌ها را به طور طبیعی بی‌تکرار طراحی کنید (مثلاً "تنظیم موجودی به ۱۰۰ دلار" به جای "اضافه کردن ۱۰ دلار به موجودی").

```
  الگوی مصرف‌کننده بی‌تکرار (Idempotent Consumer):

  ┌───────────────┐         ┌──────────────────────────┐
  │               │  رویداد │ 1. بررسی: آیا قبلاً این  │
  │  واسطه        │────────>│    شناسه رویداد را       │
  │  پیام         │         │    دیده‌ام؟               │
  └───────────────┘         │                          │
                            │ 2a. بله -> رد شود (ack)  │
                            │ 2b. خیر -> پردازش رویداد │
                            │     + ذخیره شناسه رویداد │
                            └──────────────────────────┘
```

---

## ۵. مثال

### سرویس سفارش: ایجاد یک سفارش

یک **سرویس سفارش** را در نظر بگیرید که باید یک سفارش ایجاد کند و سرویس‌های دیگر (انبار، پرداخت، اعلان) را از سفارش جدید مطلع کند.

#### بدون Transactional Outbox (مشکل نوشتن دوگانه)

```python
def create_order(order_data):
    # مرحله ۱: ذخیره سفارش در پایگاه داده
    order = db.orders.insert(order_data)     # ✅ موفق

    # مرحله ۲: انتشار رویداد به واسطه پیام
    broker.publish("OrderCreated", order)     # ❌ ممکن است شکست بخورد!

    return order
```

اگر واسطه پس از نوشتن پایگاه داده در دسترس نباشد، سفارش ایجاد می‌شود اما هیچ رویدادی منتشر نمی‌شود. سرویس انبار هرگز موجودی رزرو نمی‌کند، سرویس پرداخت هرگز مشتری را شارژ نمی‌کند و سیستم ناسازگار است.

#### با Transactional Outbox

```python
def create_order(order_data):
    with db.transaction() as txn:
        # مرحله ۱: ذخیره سفارش در پایگاه داده
        order = txn.execute(
            "INSERT INTO orders (customer_id, total, status) "
            "VALUES (%s, %s, 'CREATED') RETURNING id",
            (order_data.customer_id, order_data.total)
        )

        # مرحله ۲: نوشتن رویداد در جدول outbox (همان تراکنش)
        txn.execute(
            "INSERT INTO outbox (aggregate_type, aggregate_id, event_type, payload) "
            "VALUES (%s, %s, %s, %s)",
            (
                "Order",
                order.id,
                "OrderCreated",
                json.dumps({
                    "order_id": order.id,
                    "customer_id": order_data.customer_id,
                    "total": order_data.total,
                    "items": order_data.items,
                    "created_at": datetime.utcnow().isoformat()
                })
            )
        )

    # تراکنش commit شد: هم سفارش و هم ورودی outbox ذخیره شده‌اند
    return order
```

#### فرآیند رله پیام (Polling Publisher)

```python
def relay_outbox_events():
    while True:
        with db.transaction() as txn:
            # دریافت رویدادهای منتشر نشده (با قفل ردیف برای جلوگیری از تکرار)
            events = txn.execute(
                "SELECT id, aggregate_type, aggregate_id, event_type, payload "
                "FROM outbox "
                "WHERE published_at IS NULL "
                "ORDER BY created_at "
                "LIMIT 100 "
                "FOR UPDATE SKIP LOCKED"
            )

            for event in events:
                # انتشار به واسطه پیام
                broker.publish(
                    topic=f"{event.aggregate_type}.{event.event_type}",
                    key=event.aggregate_id,
                    value=event.payload,
                    headers={"event-id": str(event.id)}
                )

                # علامت‌گذاری به عنوان منتشر شده
                txn.execute(
                    "UPDATE outbox SET published_at = NOW() WHERE id = %s",
                    (event.id,)
                )

        time.sleep(1)  # نظرسنجی هر ثانیه
```

#### جریان سرتاسری

```
  ┌──────────┐    POST /orders     ┌──────────────┐
  │  کلاینت  │ ──────────────────>│              │
  └──────────┘                     │  سرویس       │
                                   │  سفارش       │
                                   │              │
                                   │  BEGIN TXN   │
                                   │  ┌────────┐  │     ┌────────────────┐
                                   │  │ INSERT │  │────>│ جدول orders    │
                                   │  │ order  │  │     └────────────────┘
                                   │  ├────────┤  │     ┌────────────────┐
                                   │  │ INSERT │  │────>│ جدول outbox    │
                                   │  │ event  │  │     └────────────────┘
                                   │  └────────┘  │
                                   │  COMMIT TXN  │
                                   └──────────────┘
                                          │
              ┌───────────────────────────┘
              │ (ناهمزمان - فرآیند رله)
              ▼
  ┌──────────────────┐   خواندن outbox  ┌────────────────┐
  │  رله پیام        │ <─────────────  │ جدول outbox    │
  │  (Poller / CDC)  │                 └────────────────┘
  │                  │   انتشار
  │                  │ ──────────────> ┌────────────────┐
  └──────────────────┘                 │ واسطه پیام     │
                                       │ (Kafka/RMQ)   │
                                       └───────┬────────┘
                           ┌───────────────────┼────────────────┐
                           ▼                   ▼                ▼
                    ┌────────────┐     ┌────────────┐   ┌────────────┐
                    │ سرویس      │     │  سرویس     │   │ سرویس      │
                    │ انبار      │     │  پرداخت    │   │ اعلان      │
                    └────────────┘     └────────────┘   └────────────┘
```

---

## ۶. مزایا و معایب

### مزایا

| مزیت | توضیحات |
|------|---------|
| **تحویل تضمین شده** | رویدادها در همان تراکنش با داده‌های کسب‌وکار ذخیره می‌شوند. اگر تراکنش commit شود، رویداد در نهایت منتشر خواهد شد. |
| **اتمی بودن بدون 2PC** | نیازی به تراکنش‌های توزیع‌شده بین پایگاه داده و واسطه پیام نیست. تراکنش محلی ACID تضمین اتمی بودن را فراهم می‌کند. |
| **سادگی** | این الگو ساده و قابل درک است. از قابلیت‌های استاندارد پایگاه داده (تراکنش‌ها، جداول) استفاده می‌کند. |
| **استقلال از واسطه** | منطق کسب‌وکار به در دسترس بودن واسطه پیام در زمان عملیات وابسته نیست. واسطه می‌تواند موقتاً از دسترس خارج باشد. |
| **قابلیت حسابرسی** | جدول outbox به عنوان لاگی از تمام رویدادهای تولید شده توسط سرویس عمل می‌کند. می‌توان آن را برای دیباگ و حسابرسی کوئری زد. |
| **ترتیب** | رویدادها در جدول outbox ترتیب طبیعی دارند (بر اساس `created_at`) که می‌تواند هنگام انتشار حفظ شود. |

### معایب

| عیب | توضیحات |
|-----|---------|
| **سازگاری نهایی** | تأخیری بین commit پایگاه داده و انتشار رویداد به واسطه وجود دارد. سرویس‌های دیگر تغییر را فوراً نمی‌بینند. |
| **تحویل حداقل-یک‌بار** | فرآیند رله ممکن است در سناریوهای شکست همان رویداد را بیش از یک بار منتشر کند. مصرف‌کنندگان باید بی‌تکرار باشند. |
| **جدول اضافی** | جدول outbox نیاز به مدیریت دارد: ساختار، ایندکس‌ها و پاک‌سازی رویدادهای قدیمی منتشر شده. |
| **سربار نظرسنجی** | در صورت استفاده از رویکرد Polling Publisher، نظرسنجی مکرر بار اضافی روی پایگاه داده می‌گذارد. اگر نظرسنجی نادر باشد، تأخیر افزایش می‌یابد. |
| **پیچیدگی CDC** | در صورت استفاده از Transaction Log Tailing، به زیرساخت اضافی (مثلاً Debezium، Kafka Connect) و پیکربندی خاص پایگاه داده نیاز دارید. |
| **رشد حافظه** | بدون پاک‌سازی دوره‌ای، جدول outbox به طور نامحدود رشد می‌کند. یک استراتژی نگهداری/بایگانی مورد نیاز است. |

### چه زمانی استفاده شود

- به **انتشار قابل اعتماد رویداد** از سرویسی که مالک یک پایگاه داده رابطه‌ای است نیاز دارید.
- در حال ساخت [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) هستید و نمی‌توانید از دست رفتن رویدادها را تحمل کنید.
- در حال پیاده‌سازی [الگوی Saga](../distributed-transactions/saga.fa.md) هستید و به تحویل تضمین شده فرمان‌ها/رویدادهای saga نیاز دارید.
- مدل‌های خواندن [CQRS](../data-patterns/cqrs.fa.md) شما باید با مدل نوشتن همگام نگه داشته شوند.

### چه زمانی استفاده نشود

- پایگاه داده شما از تراکنش‌های ACID پشتیبانی نمی‌کند (مثلاً برخی پایگاه‌های داده NoSQL بدون پشتیبانی از تراکنش).
- می‌توانید از دست رفتن گاه‌به‌گاه رویدادها را تحمل کنید (مثلاً رویدادهای تحلیلی غیربحرانی).
- از یک event store استفاده می‌کنید که به طور بومی ذخیره‌سازی داده و انتشار رویداد را ترکیب می‌کند (مثلاً EventStoreDB).

---

## ۷. الگوهای مرتبط

| الگو | رابطه |
|------|-------|
| [الگوی Saga](../distributed-transactions/saga.fa.md) | Saga‌ها به تحویل قابل اعتماد رویداد/فرمان متکی هستند. Transactional Outbox تضمین می‌کند که مراحل saga از دست نروند. |
| [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) | الگوی Outbox یک فعال‌ساز کلیدی ارتباط رویداد-محور قابل اعتماد بین سرویس‌ها است. |
| [CQRS](../data-patterns/cqrs.fa.md) | به‌روزرسانی‌های مدل خواندن CQRS اغلب به رویدادهای منتشر شده از طریق الگوی Outbox متکی هستند. |
| [Polling Publisher](./polling-publisher.fa.md) | یکی از دو مکانیزم تحویل رویدادهای outbox به واسطه پیام. از نظرسنجی دوره‌ای پایگاه داده استفاده می‌کند. |
| [Transaction Log Tailing](./transaction-log-tailing.fa.md) | مکانیزم تحویل دیگر. از CDC برای ضبط درج‌های outbox از لاگ تراکنش پایگاه داده استفاده می‌کند. |
| [Domain Event](../event-driven/domain-event.fa.md) | Domain Event‌ها محتوای معمولی هستند که در جدول outbox ذخیره می‌شوند. Outbox انتشار قابل اعتماد آن‌ها را تضمین می‌کند. |
| [Two-Phase Commit (2PC)](../distributed-transactions/two-phase-commit.fa.md) | رویکرد جایگزین (غیرعملی) برای اتمی بودن بین DB و واسطه. الگوی Outbox از 2PC اجتناب می‌کند. |

---

## ۸. استفاده در دنیای واقعی

### Debezium + Kafka (رویکرد CDC)

[Debezium](https://debezium.io) محبوب‌ترین پلتفرم CDC متن‌باز برای پیاده‌سازی الگوی Transactional Outbox است. این ابزار یک **Outbox Event Router** اختصاصی ارائه می‌دهد که:

- جدول outbox را از طریق لاگ تراکنش پایگاه داده نظارت می‌کند.
- به طور خودکار رویدادها را بر اساس `aggregate_type` به topic صحیح Kafka هدایت می‌کند.
- رکوردهای outbox پردازش شده را حذف می‌کند (اختیاری) تا از رشد جدول جلوگیری شود.
- از PostgreSQL، MySQL، SQL Server، MongoDB و موارد دیگر پشتیبانی می‌کند.

```
┌─────────────┐     WAL/binlog     ┌──────────────┐    Kafka    ┌──────────┐
│  PostgreSQL │ ─────────────────> │   Debezium   │ ──────────> │  Kafka   │
│  (جدول      │                    │   Connector  │             │  Topics  │
│   outbox)   │                    └──────────────┘             └──────────┘
└─────────────┘
```

### پذیرش صنعتی

| شرکت / پروژه | رویکرد | توضیحات |
|--------------|--------|---------|
| **Debezium** | CDC (خواندن لاگ) | مسیریاب رویداد outbox اختصاصی برای Kafka Connect |
| **MassTransit** (.NET) | Polling + CDC | پشتیبانی داخلی از transactional outbox |
| **Axon Framework** (Java) | Polling | پشتیبانی بومی outbox برای برنامه‌های CQRS رویداد-محور |
| **NServiceBus** (.NET) | Polling | ویژگی outbox برای حذف تکرار و تضمین تحویل |
| **Eventuate Tram** (Java) | CDC (Debezium) | فریمورک میکروسرویس‌ها با الگوی outbox داخلی |
| **Amazon EventBridge** | مدیریت شده | سرویس AWS که می‌تواند به عنوان رله outbox مدیریت شده عمل کند |

### استراتژی‌های پاک‌سازی

با گذشت زمان، جدول outbox رویدادهای منتشر شده را انباشته می‌کند. استراتژی‌های پاک‌سازی رایج شامل:

1. **حذف دوره‌ای**: یک وظیفه زمان‌بندی شده ردیف‌هایی را که `published_at` آن‌ها قدیمی‌تر از دوره نگهداری است (مثلاً ۷ روز) حذف می‌کند.
2. **جدول پارتیشن شده**: استفاده از پارتیشن‌بندی مبتنی بر زمان برای حذف کارآمد پارتیشن‌های قدیمی.
3. **حذف هنگام انتشار**: فرآیند رله بلافاصله پس از انتشار موفق، ردیف outbox را حذف می‌کند (قابلیت حسابرسی را فدای سادگی می‌کند).

---

## ۹. خلاصه

الگوی **Transactional Outbox** یک تکنیک اساسی برای اطمینان از انتشار قابل اعتماد رویداد در معماری‌های میکروسرویس است. این الگو **مشکل نوشتن دوگانه** را با نوشتن رویدادها در جدول outbox در همان تراکنش پایگاه داده با تغییر داده‌های کسب‌وکار حل می‌کند و سپس از یک فرآیند رله جداگانه برای انتشار آن رویدادها به واسطه پیام استفاده می‌کند.

```
  ┌─────────────────────────────────────────────────────────┐
  │             خلاصه Transactional Outbox                   │
  ├─────────────────────────────────────────────────────────┤
  │                                                         │
  │  مسئله:  نوشتن دوگانه — DB + واسطه نمی‌توانند اتمیک    │
  │          باشند                                          │
  │                                                         │
  │  راه‌حل: نوشتن رویداد در جدول outbox در همان             │
  │         تراکنش DB با داده‌های کسب‌وکار                   │
  │                                                         │
  │  تحویل: Polling Publisher  یا  CDC (خواندن لاگ)         │
  │                                                         │
  │  تضمین: حداقل-یک‌بار (مصرف‌کنندگان باید بی‌تکرار باشند)  │
  │                                                         │
  │  ابزارهای کلیدی: Debezium, Kafka Connect, MassTransit,  │
  │                  Axon Framework, Eventuate Tram           │
  │                                                         │
  └─────────────────────────────────────────────────────────┘
```

**نکات کلیدی:**

1. هرگز نوشتن دوگانه (به‌روزرسانی DB + انتشار پیام) را بدون مکانیزم هماهنگی انجام ندهید.
2. جدول outbox به عنوان یک بافر قابل اعتماد بین سرویس شما و واسطه پیام عمل می‌کند.
3. بین Polling Publisher (ساده‌تر) و Transaction Log Tailing (تأخیر کمتر) بر اساس نیازهای خود انتخاب کنید.
4. همیشه مصرف‌کنندگان را بی‌تکرار طراحی کنید، زیرا تحویل حداقل-یک‌بار ذاتی این الگو است.
5. برای پاک‌سازی جدول outbox برنامه‌ریزی کنید تا از رشد نامحدود حافظه جلوگیری شود.

---

**همچنین ببینید:**
- [الگوی Saga](../distributed-transactions/saga.fa.md) - هماهنگی تراکنش‌های توزیع‌شده با استفاده از outbox برای پیام‌رسانی قابل اعتماد
- [معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md) - سبک معماری گسترده‌تر که توسط انتشار قابل اعتماد رویداد فعال می‌شود
- [مقایسه RabbitMQ و Kafka](./rabbitmq-vs-kafka.fa.md) - انتخاب واسطه پیام مناسب برای رله outbox شما
- [Two-Phase Commit (2PC)](../distributed-transactions/two-phase-commit.fa.md) - رویکرد جایگزینی که الگوی outbox جایگزین آن می‌شود
