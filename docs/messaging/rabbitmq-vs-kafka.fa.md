# مقایسه RabbitMQ و Kafka

## ۱. مقدمه

هنگام ساخت سیستم‌های توزیع‌شده، ارتباط غیرهمزمان بین سرویس‌ها ضروری است. دو مورد از محبوب‌ترین فناوری‌ها برای این منظور **RabbitMQ** و **Apache Kafka** هستند. در حالی که هر دو پیام‌رسانی را مدیریت می‌کنند، اساساً برای موارد استفاده متفاوتی طراحی شده‌اند. درک تفاوت‌های آن‌ها برای انتخاب معماری مناسب حیاتی است.

RabbitMQ یک **واسطه پیام عمومی** است که در مسیریابی پیام‌ها بین تولیدکنندگان و مصرف‌کنندگان با استفاده از صف‌ها برتری دارد. Apache Kafka یک **پلتفرم جریان رویداد توزیع‌شده** است که برای دریافت، ذخیره‌سازی و بازپخش جریان‌های رویداد با توان عملیاتی بالا ساخته شده است.

این سند مقایسه‌ای جامع ارائه می‌دهد تا به شما در تصمیم‌گیری برای استفاده از هر فناوری کمک کند.

## ۲. مفاهیم اصلی

### RabbitMQ چیست؟

RabbitMQ یک واسطه پیام عمومی و قابل اعتماد است که از چندین پروتکل مانند AMQP (نسخه‌های 0.9.1 و 1.0)، MQTT و STOMP پشتیبانی می‌کند. از مدل **صف پیام سنتی** پیروی می‌کند که در آن پیام‌ها به مصرف‌کنندگان تحویل داده شده و پس از تأیید حذف می‌شوند.

```
تولیدکننده ---> [Exchange] ---> [صف] ---> مصرف‌کننده
                    |
                    +--------> [صف] ---> مصرف‌کننده
```

**ویژگی‌های کلیدی:**
- پیام‌ها پس از مصرف و تأیید حذف می‌شوند
- پشتیبانی از مسیریابی پیچیده از طریق exchange‌ها (مستقیم، موضوعی، پخشی، سرآیندی)
- مدل تحویل فشاری (Push) — واسطه پیام‌ها را به مصرف‌کنندگان ارسال می‌کند
- پشتیبانی داخلی از تلاش مجدد، صف‌های نامه مرده، و صف‌های اولویت‌دار
- رابط کاربری مدیریتی غنی به صورت پیش‌فرض

### Apache Kafka چیست؟

Kafka یک پلتفرم جریان رویداد توزیع‌شده است که در ابتدا توسط LinkedIn توسعه یافت. یک **لاگ فقط-افزودنی** را مدل‌سازی می‌کند که در آن رویدادها نوشته شده، برای یک دوره نگهداری قابل تنظیم ذخیره شده و توسط یک یا چند گروه مصرف‌کننده به صورت مستقل مصرف می‌شوند.

```
تولیدکننده ---> [موضوع: پارتیشن 0] ---> گروه مصرف‌کننده A
                [موضوع: پارتیشن 1] ---> گروه مصرف‌کننده A
                [موضوع: پارتیشن 2] ---> گروه مصرف‌کننده B (مستقل)
```

**ویژگی‌های کلیدی:**
- پیام‌ها برای یک دوره قابل تنظیم نگهداری می‌شوند (با مصرف حذف نمی‌شوند)
- مدل تحویل کششی (Pull) — مصرف‌کنندگان با سرعت خود می‌خوانند
- مصرف‌کنندگان موقعیت خود را از طریق آفست‌ها پیگیری می‌کنند
- برای مقیاس‌پذیری افقی در خوشه‌های توزیع‌شده ساخته شده
- پشتیبانی از بازپخش و پردازش مجدد رویدادهای تاریخی

## ۳. دو الگوی متمایز

کلید انتخاب بین RabbitMQ و Kafka در درک دو الگوی اساسی نهفته است:

### پردازشگران پس‌زمینه (صف‌های وظیفه)

پردازشگران پس‌زمینه وظایفی را پردازش می‌کنند که از چرخه اصلی درخواست-پاسخ خارج شده‌اند. وظیفه باید **یک بار** پردازش شود و پس از اتمام، کار تمام است.

**مثال‌ها:**
- ارسال ایمیل
- پردازش پرداخت‌ها
- تولید PDF یا گزارش
- فراخوانی API‌های شخص ثالث
- تغییر اندازه تصویر یا اسکن فایل

**ویژگی‌ها:**
- هر وظیفه توسط یک پردازشگر مدیریت می‌شود
- پس از تکمیل وظیفه، کنار گذاشته می‌شود
- خود وظیفه ارزش بلندمدتی ندارد

### پردازش رویداد-محور

پردازش رویداد-محور شامل **پخش** این واقعیت است که چیزی اتفاق افتاده و اجازه می‌دهد چندین سرویس مستقل به همان رویداد واکنش نشان دهند.

**مثال — کاربر یک پرداخت را تکمیل می‌کند:**
- سرویس A: ارسال ایمیل تأیید
- سرویس B: به‌روزرسانی سرویس پرداخت
- سرویس C: به‌روزرسانی سرویس سفارش
- سرویس D: تخصیص راننده تحویل
- سرویس E: اطلاع‌رسانی به فروشنده
- سرویس F: اجرای تحلیل‌ها (احتمالاً ساعت‌ها بعد)

**ویژگی‌ها:**
- چندین مصرف‌کننده همان رویداد را به صورت مستقل پردازش می‌کنند
- همه مصرف‌کنندگان در لحظه واکنش نشان نمی‌دهند — برخی بعداً پردازش می‌کنند (تحلیل دسته‌ای)
- رویدادها ارزش بلندمدت برای حسابرسی، بازپخش و پردازش مجدد دارند

### چرا این تمایز مهم است

| جنبه | پردازشگران پس‌زمینه | پردازش رویداد-محور |
|------|---------------------|-------------------|
| هدف | انجام کار | واکنش به رویدادها |
| مصرف‌کنندگان | یک مصرف‌کننده برای هر وظیفه | چندین مصرف‌کننده مستقل |
| طول عمر پیام | پس از پردازش حذف می‌شود | برای بازپخش نگهداری می‌شود |
| زمان‌بندی | در اسرع وقت پردازش می‌شود | بلادرنگ یا تأخیری |
| بهترین انتخاب | **RabbitMQ** | **Kafka** |

## ۴. تفاوت‌های فنی کلیدی

### نگهداری پیام

| ویژگی | RabbitMQ | Kafka |
|-------|----------|-------|
| رفتار پیش‌فرض | پیام‌ها پس از تأیید حذف می‌شوند | پیام‌ها برای دوره تنظیم‌شده نگهداری می‌شوند |
| تشبیه | لیست کارها (پس از انجام خط زده می‌شود) | دفتر خاطرات (ورودی‌ها باقی می‌مانند) |
| مدل ذخیره‌سازی | صف (FIFO، پیام‌ها حذف می‌شوند) | لاگ فقط-افزودنی (غیرقابل تغییر) |

RabbitMQ پیام‌ها را مانند آیتم‌های یک لیست کار می‌بیند — وقتی پردازشگر وظیفه‌ای را پردازش و تأیید می‌کند، پیام حذف می‌شود. Kafka پیام‌ها را مانند ورودی‌های یک دفتر خاطرات می‌بیند — هر رویداد در لاگ نوشته شده و برای یک دوره نگهداری قابل تنظیم (روزها، هفته‌ها یا نامحدود) حفظ می‌شود.

> **نکته:** از نسخه 3.9 RabbitMQ، **صف‌های جریان (Stream Queues)** معرفی شدند که لاگ فقط-افزودنی مشابه Kafka را مدل‌سازی می‌کنند. پیام‌های جریان پایدار، تکراری و قابل بازپخش هستند — اما این یک افزوده جدیدتر است و مدل سنتی RabbitMQ نیست.

### مدل مصرف‌کننده

```
RabbitMQ (مبتنی بر فشار):
واسطه --فشار--> مصرف‌کننده A
واسطه --فشار--> مصرف‌کننده B
(واسطه توزیع و توازن بار را کنترل می‌کند)

Kafka (مبتنی بر کشش):
مصرف‌کننده A --کشش--> واسطه (با سرعت خود می‌خواند)
مصرف‌کننده B --کشش--> واسطه (با سرعت خود می‌خواند)
(مصرف‌کنندگان توان عملیاتی خود را کنترل می‌کنند)
```

| ویژگی | RabbitMQ | Kafka |
|-------|----------|-------|
| مدل تحویل | فشاری (واسطه به مصرف‌کنندگان ارسال می‌کند) | کششی (مصرف‌کنندگان پیام درخواست می‌کنند) |
| توازن بار | ارسال عادلانه داخلی | موازی‌سازی مبتنی بر پارتیشن |
| کنترل مصرف‌کننده | محدود — واسطه تصمیم می‌گیرد | کامل — مصرف‌کنندگان آفست را کنترل می‌کنند |
| توقف/ازسرگیری | به صورت بومی پشتیبانی نمی‌شود | مصرف‌کنندگان آزادانه می‌توانند متوقف و از سر بگیرند |

### قابلیت بازپخش

اینجاست که Kafka تفاوت قابل توجهی ایجاد می‌کند.

**سناریو:** یک باگ در سرویس تحلیل، درآمد هفته گذشته را اشتباه محاسبه کرده است.

- **با Kafka:** باگ را رفع کنید، آفست مصرف‌کننده را به دوشنبه گذشته برگردانید و تمام رویدادهای پرداخت را مجدداً پردازش کنید. داده‌ها هنوز در لاگ هستند.
- **با RabbitMQ:** آن پیام‌ها از بین رفته‌اند. باید داده‌ها را از پایگاه داده بازسازی کنید (اگر ذخیره کرده باشید).

### مسیریابی

| ویژگی | RabbitMQ | Kafka |
|-------|----------|-------|
| مدل مسیریابی | پیچیده — exchange با اتصالات، کاراکترهای جایگزین، عبارات منظم | ساده — موضوعات و پارتیشن‌ها |
| انعطاف‌پذیری | بسیار انعطاف‌پذیر (مستقیم، موضوعی، پخشی، سرآیندی) | مسیریابی حداقلی؛ مصرف‌کنندگان در موضوعات مشترک می‌شوند |
| بهترین برای | نیازمندی‌های مسیریابی پیچیده | pub-sub ساده با توان عملیاتی بالا |

### مقیاس‌پذیری

| ویژگی | RabbitMQ | Kafka |
|-------|----------|-------|
| مدل مقیاس‌پذیری | عمدتاً عمودی (افزایش قدرت) | افقی (افزایش ماشین‌ها) |
| توان عملیاتی | هزاران پیام در ثانیه | میلیون‌ها پیام در ثانیه |
| حجم داده | سریع‌ترین وقتی صف‌ها خالی هستند | طراحی شده برای حجم‌های بزرگ داده با حداقل سربار |
| پیچیدگی خوشه | ساده‌تر برای عملیات | نیاز به درک پارتیشن‌ها، واسطه‌ها، توازن مجدد |

### مدیریت وضعیت

| ویژگی | RabbitMQ | Kafka |
|-------|----------|-------|
| پیگیری پیام | واسطه مصرف‌شده/تأییدشده/تأییدنشده را پیگیری می‌کند | مصرف‌کنندگان آفست‌های خود را مدیریت می‌کنند |
| تأیید | تأیید هر پیام؛ پیام با تأیید حذف می‌شود | مبتنی بر آفست؛ حذف هر پیام وجود ندارد |
| پیچیدگی | ساده‌تر برای درک | مفاهیم بیشتر (پارتیشن‌ها، گروه‌های مصرف‌کننده، آفست‌ها) |

## ۵. چه زمانی RabbitMQ را انتخاب کنیم

RabbitMQ هنگام ساخت سیستم‌های سنتی پردازشگر پس‌زمینه برتری دارد:

- **وظایف یک‌بار پردازش و دور ریخته می‌شوند:** ارسال ایمیل، پردازش تصاویر، فراخوانی API‌های پرداخت — عملیات ارسال-و-فراموش که پس از پردازش نیازی به پیام ندارید.

- **سادگی عملیاتی مهم است:** RabbitMQ از نظر مفهومی ساده‌تر برای راه‌اندازی و مدیریت است. منحنی یادگیری ملایم‌تر و سربار عملیاتی کمتری دارد.

- **نیاز به الگوهای کارگر داخلی:** پشتیبانی عالی از صف‌های کار، تلاش مجدد، صف‌های نامه مرده و صف‌های اولویت‌دار — همه داخلی و آماده استفاده.

- **نیازمندی‌های توان عملیاتی متوسط:** اگر هزاران (نه میلیون‌ها) وظیفه در ثانیه پردازش می‌کنید، RabbitMQ به راحتی آن را مدیریت می‌کند.

- **نیازمندی‌های مسیریابی پیچیده:** اگر نیاز به مسیریابی پیام بر اساس کاراکترهای جایگزین، الگوهای عبارت منظم یا سرآیندها دارید، سیستم exchange در RabbitMQ این انعطاف‌پذیری را فراهم می‌کند.

- **ارتباط میکروسرویس:** به عنوان واسطه بین میکروسرویس‌ها برای واگذاری وظایف — مثلاً ثبت سفارش، به‌روزرسانی وضعیت، ارسال اطلاع‌رسانی، پردازش پرداخت.

- **پردازش مبتنی بر اولویت:** وقتی تعریف اولویت پیام برای جریان کاری شما مهم است.

```
مورد استفاده: پردازش سفارش تجارت الکترونیک

[سرویس سفارش] ---> RabbitMQ ---> [پردازشگر ایمیل]
                        |-------> [پردازشگر پرداخت]
                        |-------> [پردازشگر موجودی]

هر وظیفه یک‌بار پردازش شده، سپس حذف می‌شود.
```

## ۶. چه زمانی Kafka را انتخاب کنیم

Kafka انتخاب مناسب هنگام ساخت سیستم‌های رویداد-محور است:

- **چندین سرویس به همان رویداد واکنش نشان می‌دهند:** یک رویداد پرداخت باید توسط شش سرویس مختلف به صورت مستقل پردازش شود — هر کدام با گروه مصرف‌کننده خود، همان رویداد را با سرعت خود می‌خوانند.

- **نیاز به قابلیت بازپخش:** بازیابی از باگ‌ها، پردازش مجدد داده با منطق جدید، یا تغذیه داده‌های تاریخی به سرویس جدید. نگهداری Kafka این را ممکن می‌سازد.

- **ساخت خطوط لوله داده:** رویدادهایی که از سیستم شما عبور می‌کنند نمایانگر تغییرات وضعیت هستند که چندین سیستم پایین‌دستی باید از آن‌ها مطلع شوند — مصرف‌کنندگان بلادرنگ و دسته‌ای همان جریان را می‌خوانند.

- **جریان‌های رویداد با حجم بالا:** داده‌های جریان کلیک، حسگرهای IoT، تحلیل بلادرنگ، تجمیع لاگ — Kafka میلیون‌ها پیام در ثانیه را در خوشه‌های توزیع‌شده مدیریت می‌کند.

- **نیازمندی‌های منبع‌یابی رویداد:** وقتی نیاز به ذخیره، خواندن، خواندن مجدد و تحلیل داده‌های جریانی دارید. ایده‌آل برای سیستم‌های حسابرسی‌شده یا آن‌هایی که نیاز به ذخیره دائمی پیام دارند.

- **پردازش داده بلادرنگ:** وقتی با Kafka Streams یا ksqlDB برای پردازش جریان و تحلیل بلادرنگ ترکیب می‌شود.

```
مورد استفاده: پخش رویداد پرداخت

[سرویس پرداخت] ---> موضوع Kafka: "payments"
                          |
        +-----------------+-----------------+
        |                 |                 |
   [سرویس ایمیل]   [سرویس سفارش]   [سرویس تحلیل]
   (بلادرنگ)        (بلادرنگ)        (دسته‌ای، نیمه‌شب پردازش می‌شود)

تمام سرویس‌ها همان رویداد را به صورت مستقل می‌خوانند.
تحلیل‌ها می‌توانند در صورت نیاز رویدادها را بازپخش کنند.
```

## ۷. اشتباهات رایج

### استفاده از Kafka برای صف‌های کار ساده
راه‌اندازی یک خوشه Kafka فقط برای ارسال ایمیل یا پردازش وظایف ساده پس‌زمینه بیش از حد لازم است. سربار عملیاتی (واسطه‌ها، پارتیشن‌ها، گروه‌های مصرف‌کننده، مدیریت آفست) قابل توجه است. برای صف‌های کارگر ساده، از RabbitMQ یا حتی Redis با Bull استفاده کنید.

### استفاده از RabbitMQ وقتی نیاز به داده‌های تاریخی دارید
ساخت خط لوله تحلیل با RabbitMQ به این معناست که اگر هر مصرف‌کننده‌ای از کار بیفتد، داده‌ها را از دست می‌دهید. تیم‌ها مجبور می‌شوند همه چیز را در پایگاه داده ذخیره کنند — اساساً نسخه ضعیفی از لاگ Kafka می‌سازند.

### در نظر نگرفتن پیچیدگی عملیاتی
Kafka قدرتمند اما پیچیده است. نیاز دارید پارتیشن‌ها، گروه‌های مصرف‌کننده، توازن مجدد و مدیریت آفست را درک کنید. اگر تیم شما کوچک است یا تجربه‌ای با سیستم‌های توزیع‌شده ندارد، بار عملیاتی ممکن است از مزایا بیشتر باشد.

### نادیده گرفتن سناریوهای خرابی مصرف‌کننده
وقتی یک مصرف‌کننده دو ساعت از کار می‌افتد چه اتفاقی می‌افتد؟
- **RabbitMQ:** پیام‌ها در حافظه صف می‌شوند (می‌تواند مشکلاتی در مصرف منابع ایجاد کند)
- **Kafka:** پیام‌ها در لاگ منتظر خوانده شدن هستند (برای این طراحی شده)

### فراموش کردن گرسنگی پارتیشن (Kafka)
بر خلاف صف سنتی که هر پردازشگر موجود وظیفه بعدی را برمی‌دارد، Kafka مصرف‌کنندگان را به پارتیشن‌های خاصی اختصاص می‌دهد. اگر کار به صورت نامتوازن بین پارتیشن‌ها توزیع شده باشد، برخی مصرف‌کنندگان بیکار و برخی دیگر بیش از حد بارگذاری می‌شوند.

## ۸. خلاصه مقایسه

| معیار | RabbitMQ | Kafka |
|-------|----------|-------|
| **نوع** | واسطه پیام | پلتفرم جریان رویداد |
| **مدل** | صف (پیام‌ها با تأیید حذف می‌شوند) | لاگ (پیام‌ها نگهداری می‌شوند) |
| **تحویل** | مبتنی بر فشار | مبتنی بر کشش |
| **مسیریابی** | پیچیده (exchange‌ها، اتصالات) | ساده (موضوعات، پارتیشن‌ها) |
| **بازپخش** | پشتیبانی نمی‌شود (به جز صف‌های جریان) | پشتیبانی بومی از طریق آفست‌ها |
| **توان عملیاتی** | هزاران/ثانیه | میلیون‌ها/ثانیه |
| **مقیاس‌پذیری** | عمودی | افقی |
| **ترتیب** | FIFO در هر صف | ترتیب در هر پارتیشن |
| **پیچیدگی** | کمتر | بیشتر |
| **گروه‌های مصرف‌کننده** | مصرف‌کنندگان رقابتی در یک صف | گروه‌های مصرف‌کننده مستقل |
| **نگهداری** | تا زمان تأیید | قابل تنظیم (زمان یا حجم) |
| **بهترین برای** | صف‌های وظیفه، کارهای پس‌زمینه | جریان رویداد، خطوط لوله داده |
| **پروتکل‌ها** | AMQP، MQTT، STOMP | پروتکل باینری سفارشی |
| **رابط مدیریت** | رابط وب داخلی | ابزارهای شخص ثالث |
| **منحنی یادگیری** | ملایم‌تر | شیب‌دارتر |

## ۹. چارچوب تصمیم‌گیری

```
                        آیا نیاز دارید...؟
                              |
              +---------------+---------------+
              |                               |
    وظایف را یک‌بار پردازش کنید       به رویدادها واکنش نشان دهید / داده جریان کنید
    (ارسال و فراموش)                  (چندین مصرف‌کننده، بازپخش)
              |                               |
         RabbitMQ                          Kafka
              |                               |
     +--------+--------+           +----------+----------+
     |                  |           |                     |
  مسیریابی ساده   مسیریابی پیچیده   پردازش              دسته‌ای/تحلیل
  (صف مستقیم)    (exchange‌ها)      بلادرنگ            (بازپخش آفست‌ها)
```

**RabbitMQ را انتخاب کنید اگر:**
1. نیاز به صف‌بندی ساده وظایف با معناشناسی ارسال-و-فراموش دارید
2. منطق مسیریابی پیچیده مورد نیاز است
3. تیم شما سادگی عملیاتی را ترجیح می‌دهد
4. نیازمندی‌های توان عملیاتی متوسط هستند (< ده‌ها هزار/ثانیه)
5. نیاز به صف‌های اولویت‌دار یا پیام‌های تأخیری دارید

**Kafka را انتخاب کنید اگر:**
1. چندین سرویس باید به صورت مستقل همان رویدادها را مصرف کنند
2. نیاز به بازپخش پیام یا منبع‌یابی رویداد دارید
3. در حال ساخت خط لوله داده یا سیستم تحلیل هستید
4. نیاز به میلیون‌ها پیام در ثانیه دارید
5. رویدادها ارزش بلندمدت دارند و نیاز به نگهداری دارند

**استفاده از هر دو را در نظر بگیرید:**
در بسیاری از معماری‌های دنیای واقعی، Kafka و RabbitMQ مکمل هستند. Kafka ستون فقرات جریان رویداد (پخش رویدادها، خطوط لوله داده) و RabbitMQ پردازش وظایف خاص (ارسال ایمیل، فراخوانی API) را مدیریت می‌کند. آن‌ها متقابلاً انحصاری نیستند.

## ۱۰. مثال معماری دنیای واقعی

```
                    +------------------+
                    |  درگاه پرداخت    |
                    +--------+---------+
                             |
                    رویداد: "payment.completed"
                             |
                      +------v------+
                      |    Kafka    |
                      |   موضوع    |
                      +------+------+
                             |
         +-------------------+-------------------+-------------------+
         |                   |                   |                   |
    [سرویس سفارش]      [تحلیل‌ها]           [سرویس                [سرویس
     (بلادرنگ)         (دسته‌ای شبانه)       اطلاع‌رسانی]          حسابرسی]
         |                                       |
         | وظیفه: "ارسال تأییدیه"                | وظیفه: "ارسال پیامک"
         |                                       |
    +----v----+                             +----v----+
    | RabbitMQ|                             | RabbitMQ|
    |  صف     |                             |  صف     |
    +----+----+                             +----+----+
         |                                       |
    [پردازشگر ایمیل]                        [پردازشگر پیامک]
```

در این معماری:
- **Kafka** رویداد پرداخت را به تمام سرویس‌های علاقه‌مند پخش می‌کند
- **RabbitMQ** پردازش وظایف خاص (ارسال ایمیل، پیامک) را مدیریت می‌کند که وظیفه یک‌بار پردازش شده و کنار گذاشته می‌شود

## ۱۱. موضوعات مرتبط

- **[معماری رویداد-محور](../event-driven/event-driven-architecture.fa.md)** — سبک معماری گسترده‌تر که از سیستم‌های پیام‌رسانی استفاده می‌کند
- **[CQRS](../data-patterns/cqrs.fa.md)** — جداسازی مسئولیت Command و Query، اغلب با Kafka برای معماری‌های رویداد-محور استفاده می‌شود
- **[الگوی Saga](../distributed-transactions/saga.fa.md)** — مدیریت تراکنش توزیع‌شده با استفاده از صف‌های پیام
- **[قضیه CAP](../fundamentals/cap-theorem.fa.md)** — درک مصالحه‌ها در سیستم‌های توزیع‌شده
- **[معماری Microservices](../architecture/microservices.fa.md)** — سبک معماری که بیشترین بهره را از سیستم‌های پیام‌رسانی می‌برد
- **[Circuit Breaker](../resilience/circuit-breaker.fa.md)** — الگوی تاب‌آوری برای مدیریت شکست‌های پیام‌رسانی
- **Apache Kafka Streams / ksqlDB** — پردازش جریان ساخته شده بر روی Kafka
- **پروتکل‌های صف پیام** — مقایسه پروتکل‌های AMQP، MQTT، STOMP
- **صف‌های نامه مرده** — الگوی مدیریت خطا برای شکست‌های پردازش پیام
- **Redis Streams** — جایگزین سبک برای موارد استفاده جریانی ساده‌تر

## ۱۲. منابع

- [RabbitMQ vs Kafka: A Practical Guide — Abdulmateen Tairu (Medium)](https://medium.com/@taycode/rabbitmq-vs-kafka-a-practical-guide-61b82c096cf7)
- [When to use RabbitMQ over Kafka? — Stack Overflow Discussion](https://stackoverflow.com/questions/42151544/when-to-use-rabbitmq-over-kafka)
- [CloudAMQP: When to use RabbitMQ or Apache Kafka](https://www.cloudamqp.com/blog/2019-12-12-when-to-use-rabbitmq-or-apache-kafka.html)
- [Kafka versus RabbitMQ: A Comparative Study (ACM)](http://dl.acm.org/citation.cfm?id=3093908)
